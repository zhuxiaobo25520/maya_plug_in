//                              1                2                  3              4        5                   6                      7             8                    9                    10                       11                12           13             14            15         16          17                18               19              20              21            22           23                                                  
global string$UI_array[]={"UI_head_mode","UI_head_controller","UI_head_bn","UI_zxb_eye","UI_zxb_eye_point_up","UI_zxb_eye_point_dw","UI_jaw_bn","UI_jaw_controller","UI_mouth_outer_wire","UI_mouth_inside_wire","UI_mouth_oral_wire","UI_nose","UI_noseguard","UI_basis_nasi","UI_nose_R","UI_cheek","UI_cheekbone_R","UI_jwa_point","UI_eye_L_mode","UI_eye_R_mode","UI_eye_R_wire","UI_eye_L_wire","UI_eye_L_lash"};

global proc zxb_fase_window_proc(){

if(`window -ex zxb_jisuanlianbu_ciji_Win`) deleteUI  zxb_jisuanlianbu_ciji_Win;
window -wh 420 200 -t "面部" zxb_jisuanlianbu_ciji_Win;
scrollLayout; 
columnLayout; 
columnLayout -adjustableColumn 0; 
frameLayout -label "准备"   -collapsable 3 -cl 1   -labelWidth 20 -width 500   ; 
rowColumnLayout -nc 1 -cw 1 500  ;
text -l "--------------准备--------------"   ;
separator;
rowColumnLayout -nc 3 -cw 1 240 -cw 2 140  -cw 3 100 ;

checkBox -l "眼睛镜像方式(方向)" -value 1 xingwei;
checkBox -l "不检查头部对称" -value 1 hede_vs;
checkBox -l "对称角色" -value 1 duicheng;
/*checkBox -l "面部次级簇创建" -value 1 hede_cluster;
text -l "  "   ;
text -l "  "   ;*/
global string$UI_array[];
///                  1           2        3            4       5            6          7         8            9          10         11     12     13     14    15     16     17       18         19           20              21        22          23                                            
string$UI_name[]={"头部模型","头部控制器","头部关节","眼睛关节","眼皮最高点","眼皮最低点","下巴关节","下巴控制器","嘴巴外环线","嘴巴内环线","口腔环线","鼻子","鼻头","鼻底","鼻翼R","脸颊R","颧骨R","下巴尖","L眼球模型或眼膜","R眼球模型或眼膜","眼眶线R","眼眶线L","睫毛泪腺模型"};
          //     1   2   3   4   5   6   7   8   9   10 11  12  13  14  15  16  17  18  19  20   21  22 23                                                              
string$UI_EX[]={"0","0","0","0","0","0","0","0","1","1","1","0","0","0","0","0","0","0","0","0","1","1","1"};
int$ui_size=size($UI_array);
int$uiname_size=size($UI_name);
if($ui_size!=$uiname_size){error ("UI数组不一致\n");}
for ($i=0;$i<size($UI_array);$i++)
{
 string$UI_in_maya=$UI_array[$i];
 string$UI_in_vs=$UI_name[$i];
 int$jiaobiao=$UI_EX[$i];
 string$UI_in_maya_button=$UI_array[$i]+"_button";
textFieldGrp  -cw2 100 130 -l $UI_in_vs  -ed 0  $UI_in_maya;
button -l  "载入"  -c ("zxb_zairufangfa_int_proc(\""+$UI_in_maya+"\",\""+$UI_in_maya_button+"\","+$jiaobiao+")") $UI_in_maya_button ;
button -l  "重新载入"  -c ("zxb_zairufangfa_C_proc(\""+$UI_in_maya_button+"\",\""+$UI_in_maya+"\")") ;
 }


setParent ..; 
setParent ..; 
setParent ..; 
setParent ..; 
separator;
frameLayout -label "创建"   -collapsable 3 -cl 1   -labelWidth 20 -width 500  ; // 可折叠 
rowColumnLayout -nc 1 -cw 1 500  ;

text -l "--------------创建--------------"   ;
separator;
rowColumnLayout -nc 2 -cw 1 250 -cw 2 250 ;

string$UI_establish[]={"zuibazhengti_button","zuibazhengti_button_delete","hedebs_button","headhunhebianxing_button","headhunhebianxing_edit_button","headhunhebianxing_add_button","hedemianbankuan_button","hedemianbankuan_delete_button","hedemianbankuan_wancheng_button","hedemianbankuan_bianji_button","hedemianbankuan_Add_button","hedemianbankuan_Add_delete_button","hede_open_reverse_button","lip_BN_button","lip_controller_button","lip_Curve_button","lip_bs_button","UI_face_Cluster_button","eye_button","eyelid_button","eye_secondary_button","UI_lip_zuibalalian","UI_lip_zuiba_boliang","UI_fuzhao_eye_pde_ciji","UI_qvxiangensui_mode","UI_serve_button"};
                         //          1           2                 3             4            5                6            7          8             9                10               11                  12               13                   1            15              16             17                 18              19             20            21              22             23          24               25                  26                                       
string$UI_establish_name[]={"创建嘴巴整体绑定","删除嘴巴整体绑定","创建head混合变形","删除混合变形","编辑混合变形","添加混合变形","创建表情面板","删除表情面板","完成表情面板框","编辑表情面板框","添加表情控制控框制器","删除表情控制控框制器","链接嘴巴混合变形","创建嘴巴次级关节","创建嘴巴次级控制器","创建抿嘴曲线","创建抿嘴曲线混合变形","创建面部簇","创建眼睛目标约束","创建眼皮绑定","创建眼皮次级绑定","创建拉链绑定","创建嘴巴波浪","眼睛次模型级自动附着","碰撞曲线跟随模型","保存UI上的名称"};
//                                   1                       2                                  3                    4                5  6         7                    8                   9                            10                              11                       12                            13                       14                           15                    16                   17                                18                        19                                              20                                     21                                      22            23       24                  25
string$UI_establish_proc[]={"zxb_xiababangding_proc","zxb_xiababangding_delete_proc","zxb_hunhebianx_proc","zxb_delete_head_bs_proc","","","zxb_head_biankuang","zxb_head_chongxing","zxb_mianbanwancheng_proc","zxb_mianbanbianji_proc","zxb_mianban_Addmianban_proc","zxb_mianban_Add_delete_proc","zxb_open_reverse_proc","zxb_button_lipjoint_proc","zxb_secondary_controller","zxb_extract_Curves_lip","zxb_extract_Curves_bs_lip","zxb_face_to_Cluster_proc","zxb_chuangjianyanjingguyanjie_fangfa_proc","zxb_chuangjianyanpiguanjie_fangfa_proc","zxb_yanjing_yanpi_qvxian_fangfa_proc","zxb_zuibalalian_all_proc","","zxb_fuzhao_mode_proc","zxb_mesh_nurbsSurface_to_obj_proc","zxb_UI_mingzi_serve"};
int$ui_establish_size=size($UI_establish);
int$uiname_establish_size=size($UI_establish_name);
int$UI_establish_proc_size=size($UI_establish_proc);
if($ui_establish_size==$uiname_establish_size&&$ui_establish_size==$UI_establish_proc_size)
  {
  for ($i=0;$i<size($UI_establish);$i++)
      {
       string$establish_button=$UI_establish[$i];
       string$establish_name=$UI_establish_name[$i];
       string$establish_proc=$UI_establish_proc[$i];
       button -l  $establish_name  -c $establish_proc  -en 1 $establish_button;
      }
      
       
  }
else
    {error ("UI数组不一致\n");}






setParent ..; 
frameLayout -label "瞳孔"   -collapsable 3 -cl 1   -labelWidth 20 -width 500   ; 
rowColumnLayout -nc 3 -cw 1 240 -cw 2 140  -cw 3 100 ;
string$UI_pupil[]={"UI_pupil_middle","UI_pupil_up","UI_eyr_mode_L","UI_eyr_mode_R","UI_eye_create_mesh","UI_eye_create_Surfaces","UI_eye_mode_mesh"};
string$UI_pupil_name[]={"瞳孔中间点","瞳孔最高点","->L眼球模型","<-R眼球模型","生成模型","曲面模型","当前模型"};
int$ui_pupil_size=size($UI_pupil);
int$uiname_pupil_size=size($UI_pupil_name);
if($ui_pupil_size!=$uiname_pupil_size){error ("UI数组不一致\n");}
for ($i=0;$i<size($UI_pupil);$i++)
{
 string$UI_in_maya=$UI_pupil[$i];
 string$UI_in_vs=$UI_pupil_name[$i];
 string$UI_in_maya_button=$UI_array[$i]+"_button";
if($i>3)
   {
    textFieldGrp  -cw2 100 130 -l $UI_in_vs  -ed 0  $UI_in_maya;
    text -l "----------------------------"   ;
    text -l "----------------------------"   ;
//button -l  "载入"  -c ("zxb_zairufangfa_B_proc(\""+$UI_in_maya+"\",\""+$UI_in_maya_button+"\")") $UI_in_maya_button ;
//button -l  "重新载入"  -c ("zxb_zairufangfa_C_proc(\""+$UI_in_maya_button+"\",\""+$UI_in_maya+"\")") ;
    }
else if($i>1)
      {
       textFieldGrp  -cw2 100 130 -l $UI_in_vs  -ed 0  $UI_in_maya;
       button -l  "载入"  -c ("zxb_zairufangfa_suzu_A_proc(\""+$UI_in_maya+"\",\""+$UI_in_maya_button+"\")") $UI_in_maya_button ;
       button -l  "重新载入"  -c ("zxb_zairufangfa_C_proc(\""+$UI_in_maya_button+"\",\""+$UI_in_maya+"\")") ;  
      }
      if($i<2)
      {
       textFieldGrp  -cw2 100 130 -l $UI_in_vs  -ed 0  $UI_in_maya;
       button -l  "载入"  -c ("zxb_zairufangfa_B_proc(\""+$UI_in_maya+"\",\""+$UI_in_maya_button+"\")") $UI_in_maya_button ;
       button -l  "重新载入"  -c ("zxb_zairufangfa_C_proc(\""+$UI_in_maya_button+"\",\""+$UI_in_maya+"\")") ;  
      }
  
 }
setParent ..; 
textFieldGrp  -cw2 100 400 -l "预设混合变形" -tx " tongBSA tongBSB tongBSC tongBSD tongBSE "   UI_eye_name_preinstall_BS;


columnLayout -adj 1 -w 300 ;
button -l  "生成曲面以及模型"  -c "zxb_pupil_bs_mode_extract_proc"  -en 1 UI_pupil_bs_mode_extract_button ;
button -l  "生成瞳孔绑定"  -c "zxb_tongkongsuofang_shengcbangd_proc"  -en 1 UI_pupil_binding_extract_button ;
rowColumnLayout -nc 2 -cw 1 240 -cw 2 240;

textFieldGrp  -cw2 130 130 -l "添加属性控制器" -tx "" -ed 0  kongzhiqi;
string$kongzhiqi="kongzhiqi";
button -l "添加属性控制器" -c ("zxb_zairufangfa_A_proc(\""+$kongzhiqi+"\")") ;
textFieldGrp  -cw2 130 130 -l "载入AB控制器:内瞳孔" -tx "" -ed 0  kongzhiqi_ab;
string$kongzhiqi_ab="kongzhiqi_ab";
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+$kongzhiqi_ab+"\")") ;

textFieldGrp  -cw2 130 130 -l "载入A控制器:外瞳孔" -tx "" -ed 0  kongzhiqi_a;
string$kongzhiqi_a="kongzhiqi_a";
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+$kongzhiqi_a+"\")") ;

textFieldGrp  -cw2 100 100 -l "放大 " -tx "2"   fangda;
textFieldGrp  -cw2 100 100 -l "缩小 " -tx "0.2"   suoxiao;
textFieldGrp  -cw2 100 100 -l "缩小x轴" -tx "0.2"   suoxiaox;
textFieldGrp  -cw2 100 100 -l "放大x轴" -tx "1.5"   fangdax;

textFieldGrp  -cw2 100 100 -l "缩小Y轴" -tx "0.2"   suoxiaoy;
textFieldGrp  -cw2 100 100 -l "放大Y轴" -tx "1.5"   fangday;
//floatSlider; 
setParent ..; 
textFieldGrp  -cw2 100 400 -l "放大缩小 " -tx " tongBSAA tongBSBB tongBSCC tongBSDD tongBSEE tongBSFF " -ed 0   yueshe_BS_A;

button -l  "生成瞳孔混合变形"  -c "zxb_tongkong_BSProc"  -en 1 UI_pupil_bs_extract_button ;
setParent ..; 
setParent ..; 
columnLayout -adj 1 -w 300 gtBSColumlayout;
frameLayout -label "创建拉链"   -collapsable 3 -cl 1   -labelWidth 20 -width 500   ; // 可折叠 



text -l "--------------提取曲线--------------" -h 25;

rowColumnLayout -nc 2 -cw 1 240 -cw 2 140;

textFieldGrp  -cw2 200 50 -l "选中线中线（最平的一段）" -tx "  " -ed 0  UI_mouth_temp_wire;
string$xian="UI_mouth_temp_wire";
button -l "载入线" -c ("zxb_zairufangfa_A_proc(\""+$xian+"\")") lalian_button_zairuxian ;


textFieldGrp  -cw2 100 130 -l "曲线前缀" -tx "lalian"   UI_mouth_zipper_prefix;

text -l "  " ;

textFieldGrp  -cw2 200 70 -l "反向嘴巴模型（闭合模型）" -tx "  " -ed 0  zxb_zairumode;
string$mode="zxb_zairumode";
button -l "载模型" -c ("zxb_zairufangfa_A_proc(\""+$mode+"\")") lalian_button_fanxiang;


 setParent..;
button -l "创建张嘴曲线A" -c "zxb_zuiba_tiqv_lalian_open_proc" lalian_button_qvxianA;   
button -l "创建闭嘴曲线无后缀" -c "zxb_zuiba_tiqv_lalian_close_proc" lalian_button_qvxian;
button -l "创建跟随曲线D" -c "zxb_zuiba_tiqv_lalian_follow_proc" lalian_button_qvxianD;
text -l "--------------创建拉链--------------" -h 20  -bgc 0.3 0.7 0.3;
rowColumnLayout -nc 2 -cw 1 240 -cw 2 140;




checkBox -l "选中点" -value 0 panduan_dian;
checkBox -l "反选控定位器（拉链效果默认闭合的话勾选他）" -value 1 fanxuan;

textFieldGrp  -cw2 150 100 -l "跟随曲线（D曲线）" -tx " "   UI_mouth_zipper_wire_follow_D;
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+"UI_mouth_zipper_wire_follow_D"+"\")") UI_mouth_zipper_wire_follow_D_button;


textFieldGrp  -cw2 150 100 -l "张开 闭合 曲线" -tx " "   UI_mouth_zipper_wire_close_open;
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+"UI_mouth_zipper_wire_close_open"+"\")") UI_mouth_zipper_wire_close_open_button;



textFieldGrp  -cw2 150 100 -l "张开曲线(曲线A)" -tx " "   UI_mouth_zipper_wire_open_A;
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+"UI_mouth_zipper_wire_open_A"+"\")")  UI_mouth_zipper_wire_open_A_button;



textFieldGrp  -cw2 150 100 -l "闭合曲线(曲线B)" -tx " "   UI_mouth_zipper_wire_close_B;
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+"UI_mouth_zipper_wire_close_B"+"\")")   UI_mouth_zipper_wire_close_B_button;


//button -l "提取反向嘴曲线(暂时无用)" -c "zxb_xuanzebutongmoxing_jiluxuanzhededian";
//textFieldGrp  -cw2 100 130 -l "载入基础模型" -tx "模型" -ed 0  zxb_zairumodea;
//string$mode="zxb_zairumode";
//button -l "载入基础模型" -c ("zxb_zairufangfa_A_proc(\""+$mode+"\")") ;
setParent ..; 
button -l "定位器控制曲线（D曲线）" -c "zxb_dingweiqi_kongzhiqvxian" UI_mouth_zipper_follow_DD_button ; 
button -l "曲线控制定位器(张开 闭合 曲线)" -c "zxb_dingweiqi_gensuiqvxian" UI_mouth_zipper_open_AABB_button;
button -l "创建拉链" -c "zxb_global_bolangzui" UI_mouth_zipper_Create_button;



text -l "--------------创建线包裹--------------" -h 20  -bgc 0.3 0.7 0.3;
rowColumnLayout -nc 2 -cw 1 240 -cw 2 140;



textFieldGrp  -cw2 150 130 -l "载入基础模型" -tx "模型" -ed 0  zxb_zairumodeA;
string$modeA="zxb_zairumodeA";
button -l "载入模型" -c ("zxb_zairufangfa_A_proc(\""+$modeA+"\")") ;

textFieldGrp  -cw2 150 130 -l "载入D曲线 按顺序选中" -tx "曲线" -ed 0  Dqvxian;
string$Dqvxian="Dqvxian";
button -l "载入D曲线" -c ("zxb_zairufangfa_A_proc(\""+$Dqvxian+"\")") ;



textFieldGrp  -cw2 150 130 -l "载入张嘴曲线 按顺序选中" -tx "曲线" -ed 0  zhangzuiqvxian;
string$zhangzuiqvxian="zhangzuiqvxian";
button -l "张嘴曲线" -c ("zxb_zairufangfa_A_proc(\""+$zhangzuiqvxian+"\")") ;

setParent ..; 
button -l "生成包裹" -c "zxb_lalianbaoguo_poc";




text -l "--------------设置驱动--------------" -h 20  -bgc 0.3 0.7 0.3;
rowColumnLayout -nc 2 -cw 1 240 -cw 2 140;



textFieldGrp  -cw2 100 130 -l "载入控制器" -tx "控制器" -ed 0  zxb_zairukongzhiqi;
string$mkongzhiqi="zxb_zairukongzhiqi";
button -l "控制器" -c ("zxb_zairufangfa_A_proc(\""+$mkongzhiqi+"\")") ;

textFieldGrp  -cw2 100 130 -l "载入定位器" -tx "定位器" -ed 0  zxb_dingweiqi;
string$dingweqi="zxb_dingweiqi";
button -l "定位器" -c ("zxb_zairufangfa_A_proc(\""+$dingweqi+"\")") ;



setParent ..; 


button -l "设置驱动" -c "zxb_zd_sheziqvdong_poc";





text -l "--------------骨骼跟随曲线--------------" -h 20  -bgc 0.3 0.7 0.3;
button -l "生成" -c "xiao_gugegengsuiqvxian_proc_columnLayout";

separator;

setParent ..; 

frameLayout -label "创建嘴巴波浪"   -collapsable 3 -cl 1   -labelWidth 20 -width 500  ; // 可折叠 

text -l "--------------生成波浪--------------" -h 20  -bgc 0.3 0.7 0.3;
button -l "选中D曲线" -c "zxb_bolangzui";
setParent ..; 
frameLayout -label "创建睫毛碰撞"   -collapsable 3 -cl 1   -labelWidth 20 -width 500  ; // 可折叠 
rowColumnLayout -nc 3 -cw 1 240 -cw 2 140  -cw 3 100 ;
textFieldGrp  -cw2 150 100 -l "睫毛次级ROOT关节" -tx " "   UI_jiemao_root_bn;
button -l "载入跟关节" -c ("zxb_zairufangfa_A_proc(\""+"UI_jiemao_root_bn"+"\")") UI_jiemao_root_bn_button;
text -l " " ;
setParent ..; 
button -l "创建睫毛FK" -c "zxb_jiemao_ciji_kongzhiqi";
rowColumnLayout -nc 3 -cw 1 240 -cw 2 140  -cw 3 100 ;
string$pengzhuang_qvxian_ss[]={"UI_jiemao_pengzhuang_qvxian_up_L","UI_jiemao_pengzhuang_qvxian_dw_L","UI_jiemao_pengzhuang_qvxian_up_R","UI_jiemao_pengzhuang_qvxian_dw_R"};

string$pengzhuang_qvxian_ss_tex[]={"碰撞曲线上L","碰撞曲线下L","碰撞曲线上R","碰撞曲线下R"};
for ($i=0;$i<size($pengzhuang_qvxian_ss);$i++)
     {
         
      string$qvxian=$pengzhuang_qvxian_ss[$i];
       string$qvxian_button=$qvxian+"_button";
      string$pengzhuang_tex=$pengzhuang_qvxian_ss_tex[$i];
      textFieldGrp  -cw2 150 100 -l $pengzhuang_tex -tx " "   $qvxian;
      button -l "载入曲线" -c ("zxb_zairufangfa_A_proc(\""+$qvxian+"\")") $qvxian_button;
      button -l  "重新载入"  -c ("zxb_zairufangfa_C_proc(\""+$qvxian_button+"\",\""+$qvxian+"\")") ;
      }







setParent ..; 








button -l "创建碰撞曲线跟随模型" -c "zxb_mesh_nurbsSurface_to_obj_proc";


rowColumnLayout -nc 1 -cw 1 500  ;
rowColumnLayout -nc 2 -cw 1 240 -cw 2 140;



textFieldGrp  -cw2 150 100 -l "载入在原地位置的曲线" -tx "曲线" -ed 0  UI_yuandi_qvxian;
string$qvxian="UI_yuandi_qvxian";
button -l "载入在原地位置的曲线" -c ("zxb_zairufangfa_A_proc(\""+$qvxian+"\")") ;

textFieldGrp  -cw2 100 130 -l "定位器个数" -tx "20"   UI_yuandi_loc;
string$dingweiqi="UI_yuandi_loc";
button -l "载入定位器个数" -c ("zxb_zairufangfa_A_proc(\""+$dingweiqi+"\")") ;

textFieldGrp  -cw2 100 130 -l "旋转角度" -tx "360"   UI_yuandi_jiaodu;
string$jiaodu="UI_yuandi_jiaodu";
button -l "载入角度" -c ("zxb_zairufangfa_A_proc(\""+$jiaodu+"\")") ;
setParent ..; 

button -l "设置关节碰撞角度（选中关节）" -c "zxb_jiemao_pengzhuangguanjie_chengxu_proc";






rowColumnLayout -nc 3 -cw 1 240 -cw 2 140  -cw 3 100 ;


string$pengzhuang_qvxian_ss[]={"UI_jiemao_pengzhuang_bn_up_L","UI_jiemao_pengzhuang_bn_dw_L","UI_jiemao_pengzhuang_bn_up_R","UI_jiemao_pengzhuang_bn_dw_R"};

string$pengzhuang_qvxian_ss_tex[]={"碰撞关节上L","碰撞关节下L","碰撞关节上R","碰撞关节下R"};
for ($i=0;$i<size($pengzhuang_qvxian_ss);$i++)
     {
         
      string$qvxian=$pengzhuang_qvxian_ss[$i];
       string$qvxian_button=$qvxian+"_button";
      string$pengzhuang_tex=$pengzhuang_qvxian_ss_tex[$i];
      textFieldGrp  -cw2 150 100 -l $pengzhuang_tex -tx " "   $qvxian;
      button -l "载入跟关节" -c ("zxb_zairufangfa_A_proc(\""+$qvxian+"\")") $qvxian_button;
      button -l  "重新载入"  -c ("zxb_zairufangfa_C_proc(\""+$qvxian_button+"\",\""+$qvxian+"\")") ;
      }







setParent ..; 

button -l "创建睫毛关节碰撞" -c "zxb_jiemao_pengzhuang_proc";
setParent ..; 
setParent ..; 
showWindow  ;

}



global proc zxb_ui_jiazai() 
{
string$face_loc="zxb_face_loc";
string$UI_arraySS=`zxb_UI_mingzi`;
string$UI_array[]=stringToStringArray($UI_arraySS," ");
string$UI_ex="UI_ex_judge";

int$ex=`objExists $face_loc`;    ///判断
if($ex==0)
  {
    spaceLocator -p 0 0 0 -n $face_loc;
    
    string$BUYIDONGZU="Face_Group";
    int$ex=`objExists $BUYIDONGZU`;    ///判断
    if($ex==0)
       {
       group  -em  -n $BUYIDONGZU;
       }
    parent $face_loc $BUYIDONGZU;
    
    for($iii=0;$iii<size($UI_array);$iii++)
       {
       string$temp_shuxing=$UI_array[$iii];
       zxb_ADD_shuxing_string_proc($face_loc,$temp_shuxing); 
       
        }

    
    zxb_ADD_shuxing_double_proc($face_loc,$UI_ex);
 }


float$ex_A=`getAttr($face_loc+"."+$UI_ex)`;
if($ex_A==1)
  {
      
 
  for($iii=0;$iii<size($UI_array);$iii++)
      {
     string$shuxing=$UI_array[$iii];
     
     string$temp_shuxing=`getAttr ($face_loc+"."+$shuxing)`;
     textFieldGrp -e -tx $temp_shuxing $shuxing; 
     
     button -e -en 0 ($shuxing+"_button");
      }
 
            
  }

    
}





global proc string zxb_UI_mingzi()
{
string$mingzi="";
global string$UI_array[];
//string$UI_array[]={"UI_head_mode","UI_head_controller","UI_jaw_bn","UI_jaw_controller","UI_mouth_outer_wire","UI_mouth_inside_wire","UI_mouth_temp_wire","UI_mouth_zipper_prefix","UI_mouth_zipper_wire_follow_D","UI_mouth_zipper_wire_open_A","UI_mouth_zipper_wire_close_B","UI_mouth_zipper_wire_close_open"};

for($i=0;$i<size($UI_array);$i++)
   {
   $mingzi+=($UI_array[$i]+" ");
   }
   
   return $mingzi;
}


global proc  zxb_UI_mingzi_serve()
{
  int $ex=`objExists "zxb_face_loc"`;//查询这个物体是否纯在
  if($ex==0)
    {
    zxb_ui_jiazai;
    string$UI_arraySS=`zxb_UI_mingzi`;
    string$UI_array[]=stringToStringArray($UI_arraySS," ");
    string$face_loc="zxb_face_loc";
    setAttr "zxb_face_loc.UI_ex_judge" 1;
    for($iii=0;$iii<size($UI_array);$iii++)
           {
            string$shuxing=$UI_array[$iii];
            string$teststring=`textFieldGrp -q -tx $shuxing `;
            setAttr -type "string" ($face_loc+"."+$shuxing) $teststring;
     
           }
  }
  else{
      string$UI_arraySS=`zxb_UI_mingzi`;
      string$UI_array[]=stringToStringArray($UI_arraySS," ");
      string$face_loc="zxb_face_loc";
     setAttr "zxb_face_loc.UI_ex_judge" 1;
     for($iii=0;$iii<size($UI_array);$iii++)
           {
            string$shuxing=$UI_array[$iii];
            string$teststring=`textFieldGrp -q -tx $shuxing `;
            setAttr -type "string" ($face_loc+"."+$shuxing) $teststring;
     
           }
    
      }

 button -e -en 0 UI_serve_button ;

}

////////////////////////////////////自己固定程序绑定方法/////////////////////////////////////////////
////////////////////////////////////自己固定程序绑定方法/////////////////////////////////////////////
////////////////////////////////////自己固定程序绑定方法/////////////////////////////////////////////
////////////////////////////////////自己固定程序绑定方法/////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////


///////载入文字//////////////////
global proc zxb_zairufangfa_A_proc(string$tempname)
{
string $sel[]=`ls -sl`;
string $obj="";
for($i=0;$i<size($sel);$i++)
    {
    $obj+=($sel[$i]+" ");
    }
textFieldGrp -e -tx ($obj) $tempname;
}


/////////显示按钮按钮并清空文字///////
global proc zxb_zairufangfa_C_proc(string$butt,string $tempname)
{

button -e -en 1 $butt;
textFieldGrp -e -tx "" $tempname;

}
/////////显示按钮按钮///////
global proc zxb_zairufangfa_vsanniu_proc(string$butt)
{

button -e -en 1 $butt;

}

////////////关闭按钮///////////////
global proc zxb_zairufangfa_vsanniu_on_proc(string$butt)
{

button -e -en 0 $butt;

}

////////////关闭按钮///////////////
global proc zxb_zairufangfa_D_proc(string$butt)
{

button -e -en 0 $butt;
}
/////////编辑文字并隐藏按钮///////
global proc zxb_zairufangfa_B_proc(string$tempname,string$butt)
{
string $sel[]=`ls -sl`;
textFieldGrp -e -tx $sel[0] $tempname;
button -e -en 0 $butt;
}


/////////编辑文字并隐藏按钮///////
 global proc zxb_zairufangfa_int_proc(string$tempname,string$butt,int$vs)
{
string $sel[];
clear $sel;
if($vs==0)
  {
  $sel=`ls -sl`;
  textFieldGrp -e -tx $sel[0] $tempname;
  button -e -en 0 $butt;
  }
if($vs==1)
  {
  $sel=`ls -sl -fl`;
  string$temp="";
  for ($i=0;$i<size($sel);$i++)
      {
        $temp+=$sel[$i]+" ";
        }
  textFieldGrp -e -tx $temp $tempname;
  button -e -en 0 $butt;
  }

}


/////////////载入数组///////////////
global proc zxb_zairufangfa_suzu_proc(string$tempname,string$butt)
{
string $sel[]=`ls -sl -fl`;
string$suzu="";
for ($i=0;$i<size($sel);$i++)
    {
    $suzu+=$sel[$i]+" ";
    }
textFieldGrp -e -tx  $suzu $tempname;
button -e -en 0 $butt;
}
/////////////载入数组///////////////
global proc zxb_zairufangfa_suzu_A_proc(string$tempname,string$butt)
{
string $sel[]=`ls -sl `;
string$suzu="";
for ($i=0;$i<size($sel);$i++)
    {
    $suzu+=$sel[$i]+" ";
    }
textFieldGrp -e -tx  $suzu $tempname;
button -e -en 0 $butt;
}


///////////////载入一堆字符//////////////
global proc string zxb_array_to_stringproc(string$tempname[])
{

string $obj="";
for($i=0;$i<size($tempname);$i++)
    {
    $obj+=(" "+$tempname[$i]);
    }
 return $obj;
}

//////////////////添加属性/////////////////////
global proc zxb_ADD_shuxing_string_proc(string$kongzhiqi,string$shuxing)
{
  int$ex=`objExists ($kongzhiqi+"."+$shuxing)`;    ///判断
  select -r $kongzhiqi;
  if($ex==0){addAttr -ln $shuxing  -dt "string";} 
}


//////////////////添加属性/////////////////////
global proc zxb_ADD_shuxing_double_proc(string$kongzhiqi,string$shuxing)
{
  int$ex=`objExists ($kongzhiqi+"."+$shuxing)`;    ///判断
  select -r $kongzhiqi;
  if($ex==0){addAttr -ln $shuxing -at double   -dv 0 -k 1;} 
}

//////////////////添加属性/////////////////////
global proc zxb_ADD_shuxing_double_A_proc(string$kongzhiqi,string$shuxing)
{
  int$ex=`objExists ($kongzhiqi+"."+$shuxing)`;    ///判断
  select -r $kongzhiqi;
  if($ex==0){addAttr -ln $shuxing -at double  -min 0 -max 10  -dv 0 -k 1;} 
}

//////////////////添加属性/////////////////////
global proc zxb_ADD_shuxing_double_B_proc(string$kongzhiqi,string$shuxing,float$min,float$max)
{
  int$ex=`objExists ($kongzhiqi+"."+$shuxing)`;    ///判断
  select -r $kongzhiqi;
  if($ex==0){addAttr -ln $shuxing -at double  -min $min -max $max  -dv 0 -k 1;} 
}


///////////////////////创建空组
global proc zxb_ADD_kongzu_proc(string$kongzu)
{  
 int$ex=`objExists $kongzu`; ///判断
 if($ex==0){ group -empty -n $kongzu;}
   
}
//////////选中物体创建空组//////////////
global proc zxb_ADD_kongzuA_proc(string$kongzu,string$wuti)
{  
 int$ex=`objExists $kongzu`; ///判断
 if($ex==0)
 { 
 select -r $wuti;
 group  -n $kongzu;
 }
   
}
/////////////////////////////////////////创建节点
global proc zxb_ADD_jiedian_proc(string$jiedian_name,string$jiedia)

{
   int$ex=`objExists $jiedian_name`;    ///判断
   if($ex==0){shadingNode -asUtility  $jiedia -n $jiedian_name;//创建范围节点
   }
   
}


/////////////////////////////////////////创建节点
global proc zxb_ADD_createNode_proc(string$jiedian_name,string$jiedia)

{
   int$ex=`objExists $jiedian_name`;    ///判断
   if($ex==0){createNode   $jiedia -n $jiedian_name;//创建范围节点
   }
   
}
/////////隐藏按钮并载入文字

global proc zxb_butt_tex_proc(string $butt,string $textFieldGrpa)
{

button -e -en 0 $butt;
zxb_zairufangfa_A_proc($textFieldGrpa);
}

//////////反向保存关节名称//////////////
global proc string zxb_baocunguanjie_mingzi_proc(string$mingzi, int$qunlujing)
{
         string $IKS[];
         clear$IKS;
         if($qunlujing==0){$IKS=`listRelatives -c -ad   -type "joint"$mingzi `; }
         if($qunlujing==1){$IKS=`listRelatives -c -ad    -type "joint"-pa $mingzi `; }
         string$all_bn[];
         clear $all_bn;  
         $all_bn[0]=$mingzi; 
        for($j=0;$j<size($IKS);$j++)
           {
               string$temp_bn=$IKS[$j];
               int$temp_a=size($IKS)-$j;
               $all_bn[$temp_a]=$temp_bn;
               
               
           }
           
          string$mingziss="";
         for($j=0;$j<size($all_bn);$j++)
             {
              string$temp=$all_bn[$j]+" ";
              $mingziss+=$temp;
              }
              
              
         return $mingziss;

}







///////////////////复制关节并重新命名////////////////////////////////////////

global proc string zxb_chongxingmingming_bn_mingzi_proc(string$bn,string$qianzui)
  {
  select -r $bn;
  string$mingzi=$bn+$qianzui+"temp";
  string$mingzi_a=$bn+$qianzui;
  duplicate -rr -n $mingzi ;
  string$pa_bn=zxb_baocunguanjie_mingzi_proc($mingzi,1);
  string$pa_bns[]= stringToStringArray($pa_bn, " ");//关节
  string$bn_name="";
  string$bn_namea="";
  for($ii=size($pa_bns)-1;$ii>=0;$ii--)
     {
            string$temp_bn=$pa_bns[$ii];
            string$name=$mingzi_a+$ii;
            select -r $temp_bn;
            rename $temp_bn $name;
            if($ii==0)
               {
                 $bn_namea=$name;
                 }
       }
  string$bn_name=zxb_baocunguanjie_mingzi_proc($bn_namea,0);   
  return  $bn_name;
   
   }
  
  
  
  
  
  //////////////////////////通过曲线返回U参数///////////////////////////////
  global proc float zxb_return_curve_U(float$x,float$y,float$z,string$qvxian)
{
    
float$u=0;
string$shangxiaqvxian_nearestPointOnCurve=$qvxian+"zxb_return_curve_U_nearestPointOnCurve";
string $xingjiedian[]=`listRelatives -s $qvxian`;
string$qvxian_shap=$xingjiedian[0];
zxb_ADD_createNode_proc($shangxiaqvxian_nearestPointOnCurve,"nearestPointOnCurve");
connectAttr -force ($qvxian_shap+".worldSpace[0]")  ($shangxiaqvxian_nearestPointOnCurve+".inputCurve");
setAttr ($shangxiaqvxian_nearestPointOnCurve+".inPositionX") $x;
setAttr ($shangxiaqvxian_nearestPointOnCurve+".inPositionY") $y;
setAttr ($shangxiaqvxian_nearestPointOnCurve+".inPositionZ") $z;
string$parameter=`getAttr ($shangxiaqvxian_nearestPointOnCurve+".parameter")`;
$u=$parameter;
return$u;
delete $shangxiaqvxian_nearestPointOnCurve;
}
  
  
//////////////////通过曲线返回U位置///////////////////////////
global proc float[]  zxb_return_curve_place(float$x,float$y,float$z,string$qvxian)
{
    

float$ee[];
clear $ee;
string$shangxiaqvxian_nearestPointOnCurve=$qvxian+"zxb_return_curve_U_nearestPointOnCurve";
string $xingjiedian[]=`listRelatives -s $qvxian`;
string$qvxian_shap=$xingjiedian[0];
zxb_ADD_createNode_proc($shangxiaqvxian_nearestPointOnCurve,"nearestPointOnCurve");
connectAttr -force ($qvxian_shap+".worldSpace[0]")  ($shangxiaqvxian_nearestPointOnCurve+".inputCurve");
setAttr ($shangxiaqvxian_nearestPointOnCurve+".inPositionX") $x;
setAttr ($shangxiaqvxian_nearestPointOnCurve+".inPositionY") $y;
setAttr ($shangxiaqvxian_nearestPointOnCurve+".inPositionZ") $z;
string$parameter=`getAttr ($shangxiaqvxian_nearestPointOnCurve+".parameter")`;
$u=$parameter;
return$ee;
delete $shangxiaqvxian_nearestPointOnCurve;
}  




//////////////////////计算位置的平均值///////////////////////////
global proc float zxb_qvfengshangzi ()
{
string$tempString[]=`ls -sl -fl`;

float $tys[];
float $tysAverage;
for ($y=0;$y<size($tempString);$y++)
	{
	$pos=`xform -q -ws -t $tempString[$y]`;
	$tys[$y]=$pos[1];
	$tysAverage+=$tys[$y];
	}
$tysAverage=$tysAverage/size($tempString);
return $tysAverage;
}



///////////////////////计算Y轴法线的朝向///////////////////////////

global proc float zxb_normal_pingjunshu(string$mode)
{
string$tempString[]=`ls -sl -fl`;
string$temp_mode=$mode;

float$shu=0;
string$mode_shps[]=`listRelatives -s $temp_mode`; 
for ($y=0;$y<size($tempString);$y++)
	{
	string$mesh_OnMesh="Temp_closestPointOnMesh";
	zxb_ADD_createNode_proc($mesh_OnMesh, "closestPointOnMesh");
	connectAttr -force ($mode_shps[0]+".worldMesh[0]") ($mesh_OnMesh+".inMesh");
	string$temp_cv=$tempString[$y];
	float $cv_pos[]=`xform -q -ws -t $temp_cv`;
	setAttr -type float3 ($mesh_OnMesh+".inPosition") $cv_pos[0] $cv_pos[1] $cv_pos[2];
	float$a=getAttr ($mesh_OnMesh+".result.normal.normalY");
    $shu+=$a;
    delete $mesh_OnMesh;
	}
int$r=size($tempString);
float$pingjun=$shu/$r;
return $pingjun;
}





//////////////////////////创建FK控制器//////////////////////////////////////////////////
global proc  zxb_FK_controller_proc(string$head_bn)
{
string$temp_a_bn[];
 clear$temp_a_bn;
$temp_a_bn[0]=$head_bn;
string $bn[]=$temp_a_bn;
int $bnnum=size($bn);

for($jj=0;$jj<$bnnum;$jj++)
   {
    select -r ($bn[$jj]);
	string $sels[] = `ls -sl`;
	
	int $size=size($sels);	
	/////////////////////////////
	string $baseJoint = $sels[0];
	
	string $endJoint;
	
	string $childs[]=`listRelatives -c -ad $sels[0]`;
	int $num=size($childs);
	$endJoint=$childs[0];
	//////////////////////////////////////	
	string $typs=`nodeType  $baseJoint`;
	string $type=`nodeType  $endJoint`;
	if($typs!="joint")error "需要选择两个关节";
	if($type!="joint")error "需要选择两个关节";

	select -r  $baseJoint;
	
    for($a=($num-1);$a>0;$a--){
    
    select -add ($childs[$a]);
}

string $sel[]=`ls -sl`;

string $tokem[];
int $tonum=`tokenize ($sel[0]) "_" $tokem`;
string $side=$tokem[1];

for($i=0;$i<size($sel);$i++){
  circle -ch 0 -o on -nr 1 0 0 -r 1 -n ($sel[$i]+"Con") ;
  select -r ($sel[$i]+"Con");
  group -n ($sel[$i]+"ConGrp");
  group -n ($sel[$i]+"ConGrpA");
  select -r ($sel[$i]);
  select -add ($sel[$i]+"ConGrpA");
  delete `parentConstraint`;
  
  select -r ($sel[$i]+"Con");
  select -add ($sel[$i]);
  parentConstraint;
  //scaleConstraint; 
 
  setAttr -lock true ($sel[$i]+"Con.v");
  string $shape[]=`listRelatives -s ($sel[$i]+"Con")`;
    setAttr ($shape[0]+".overrideEnabled") 1;
  if($side=="l"){
    setAttr ($shape[0]+".overrideColor") 22;   
  }else if($side=="r"){
    setAttr ($shape[0]+".overrideColor") 13;   
  }else{
        setAttr ($shape[0]+".overrideColor") 6;     
  }  
}

for($i=0;$i<(size($sel)-1);$i++){
    $j=$i+1;
    select -r ($sel[$j]+"ConGrpA");
    select -add ($sel[$i]+"Con");
    parent;
}

int $size=size($sel);
/////////////////////
addAttr -ln "rotx"  -at double -k 1 ($sel[$size-1]+"Con");
addAttr -ln "roty"  -at double -k 1 ($sel[$size-1]+"Con");
addAttr -ln "rotz"  -at double -k 1 ($sel[$size-1]+"Con");
addAttr -ln "showCon"  -at bool -k 1 ($sel[$size-1]+"Con");

for($i=0;$i<size($sel);$i++){
    connectAttr -f ($sel[$size-1]+"Con.rotx") ($sel[$i]+"ConGrp.rotateX");
    connectAttr -f ($sel[$size-1]+"Con.roty") ($sel[$i]+"ConGrp.rotateY");
    connectAttr -f ($sel[$size-1]+"Con.rotz") ($sel[$i]+"ConGrp.rotateZ");    
}

for($i=0;$i<(size($sel)-1);$i++){
    string $shap[]=`listRelatives -s ($sel[$i]+"Con")`;

    connectAttr -f ($sel[$size-1]+"Con.showCon") ($shap[0]+".v");
        }
    }
}




////////////////////////////////////////关节创建曲线/////////////////////////////////////////////////////////////////
global proc  zxb_curve_establish_proc(string$cbns[],string$qvxian)
{
  string$mingzi="curve -d 3 ";
  for($jj=0;$jj<size($cbns);$jj++)
      {
          string$mingzi_bnn=$cbns[$jj];
          float $temp[]=`xform -q -ws -t $mingzi_bnn`;
          $mingzi+="-p "+$temp[0]+" "+$temp[1]+" "+$temp[2]+" ";
      }
   $mingzi+=" -n "+ $qvxian;
   eval($mingzi); 
}
       
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////初始化区域/////////////////////////////////////////////////////////////////////////////////////////








/////创建下巴绑定////
global proc zxb_xiababangding_proc()
{
  zxb_ui_jiazai;  
  string $xiaba_bn=`textFieldGrp -q -tx  UI_jaw_bn`;
  string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
  
  
  int$ex=`objExists $xiaba_bn`; 
  if($ex==0){ error  "下巴关节没有载入";}
  int$ex=`objExists $head_qvxian`; 
  if($ex==0){ error  "头部控制器没有载入" ;}
  zxb_ADD_kongzu_proc("head_all_bn_Group");
  zxb_ADD_kongzu_proc("head_all_loc_Group");
  zxb_ADD_kongzu_proc("head_all_curve_Group");
  zxb_ADD_kongzu_proc("head_all_nurbsSphere_Group");
 zxb_ADD_kongzu_proc("head_all_Cluster_Group");
 zxb_ADD_kongzu_proc("head_all_hairfollicle");
  zxb_ADD_kongzu_proc("not_move");
  zxb_ADD_kongzu_proc("jaw_loc_Group");
  zxb_ADD_kongzu_proc("head_curve_Group");
  zxb_ADD_kongzu_proc("head_pupil_curve_Group");
  parent("head_curve_Group")  ("head_all_curve_Group");
  parent("head_all_nurbsSphere_Group")("Face_Group");
  parent("jaw_loc_Group")("head_all_loc_Group");
  parent ("head_all_bn_Group")("Face_Group");
  parent ("not_move")("Face_Group");
  parent ("head_all_loc_Group")("Face_Group");
  parent ("head_all_curve_Group")("Face_Group");
  parent("head_all_Cluster_Group")("Face_Group");
  parent("head_all_hairfollicle")("Face_Group");
  parent("head_pupil_curve_Group")("head_all_curve_Group");
  parentConstraint$head_qvxian("head_curve_Group");
 
  
  int$ex=`objExists ($head_qvxian+".jaw")`;    ///判断
  select -r $head_qvxian;
  if($ex==0){addAttr -ln "jaw"  -dt "string";}  
  
  int$ex=`objExists ($head_qvxian+".UI_jaw_bn")`;    ///判断
  select -r $head_qvxian;
  if($ex==0){addAttr -ln "UI_jaw_bn"  -dt "string";}  
  
  int$ex=`objExists ($head_qvxian+".jaw_root_bn")`;    ///判断
  select -r $head_qvxian;
  if($ex==0){addAttr -ln "jaw_root_bn"  -dt "string";}  
  
  int$ex=`objExists ($head_qvxian+".jaw_zhengti_bn")`;    ///判断
  select -r $head_qvxian;
  if($ex==0){addAttr -ln "jaw_zhengti_bn"  -dt "string";}  
  
  string$qvxian_jaw="";  
  string$qvxian_jaw_bn=""; 
  string$qvxian_jaw_root_bn=""; 
  string$qvxian_jaw_zhengti_bn=""; 
  string$jaw_bn=$xiaba_bn;
  select -r $jaw_bn ;
  
  string $jaw=($jaw_bn+"_BN");
  duplicate -rr -n $jaw;
  string$ziwuti[]=`listRelatives -c  -pa $jaw`;
  string $jaw_end=($jaw_bn+"_BN_end");
  rename $ziwuti[0] $jaw_end;
  string$qvxian_jaw_bn=$jaw;
  setAttr -type "string"($head_qvxian+".UI_jaw_bn") $qvxian_jaw_bn;

  string$grp=($jaw+"_jaw_bn_grp");
  int$ex=`objExists $grp`;    ///判断
  $qvxian_jaw+=$grp+" ";
  if($ex==0)
     {
       group  -em  -n $grp;
     }
  parent $jaw $grp;
  string$bn_con=($jaw+"_com");
  string$qvxian_grpA=($bn_con+"_A");
  string$qvxian_grpB=($bn_con+"_B");
  string$qvxian_grpC=($bn_con+"_C");
  $qvxian_jaw+=$qvxian_grpC+" ";
  float$banjing=`getAttr ($jaw_end+".tx")`;
  
  circle -c 0 0 0 -nr 0 1 0 -sw 360 -r ($banjing*0.3) -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $bn_con ;
  group -n $qvxian_grpA;
  group -n $qvxian_grpB;
  group -n $qvxian_grpC;
  delete `pointConstraint $jaw_end $qvxian_grpC`;
  float$tx=`getAttr  ($jaw_end+".tx")`;
  select -r ($bn_con+".cv[0:9999]") ;
  //move -r -os -wd ($tx*0.3) 0 0 ;
  float$bn_pos[]=`xform -q -ws -t $jaw`;
  string$jaw_root=($jaw+"_root");
  select -cl  ;
  joint -p  $bn_pos[0] $bn_pos[1] $bn_pos[2] -n $jaw_root ;
  move -r 0 0 ($tx*-0.5) ;
  parent $jaw_root $grp;
  parent $jaw $jaw_root;
  
  parent  $qvxian_grpC ("head_curve_Group");
  $qvxian_jaw_root_bn=$jaw_root;
   setAttr -type "string"($head_qvxian+".jaw_root_bn") $qvxian_jaw_root_bn;
 // select -r $jaw_root;
  //SelectHierarchy;
  //joint -e  -oj xyz -secondaryAxisOrient yup -ch -zso;

  
  
  string$jaw_locA=($jaw+"_locA");
  string$loc_GRPA=($jaw_locA+"_A");
  string$loc_GRPB=($jaw_locA+"_B");
  
  spaceLocator -p 0 0 0 -n $jaw_locA ;
  group -n $loc_GRPA;
  group -n $loc_GRPB;
  
  delete `pointConstraint $jaw_bn $loc_GRPB`;
  parent $loc_GRPB $jaw_root;
  parent  $jaw $jaw_locA;
  
  
  
  
  string$jaw_locB=($jaw+"_locB");
  string$loc_GRPAA=($jaw_locA+"_AA");
  string$loc_GRPBB=($jaw_locA+"_BB");
  $qvxian_jaw+=$loc_GRPBB+" ";
  setAttr -type "string"($head_qvxian+".jaw") $qvxian_jaw;
  spaceLocator -p 0 0 0 -n $jaw_locB ;
  group -n $loc_GRPAA;
  group -n $loc_GRPBB;
  
  string$FUwuti[]=`listRelatives -p  $jaw_bn`;
  parent  $loc_GRPBB ("jaw_loc_Group");
  
  delete`pointConstraint $jaw_bn $loc_GRPBB`;
  pointConstraint $FUwuti[0] $loc_GRPBB;
  pointConstraint  $jaw_bn $jaw_locB;

 connectAttr -f ($jaw_bn+".rotate") ($jaw+".rotate");
  connectAttr -f ($jaw_locB+".t") ($jaw_locA+".t");
   
  setAttr ($grp+".visibility") 0;
  
    string$BUYIDONGZU="Face_Group";
  int$ex=`objExists $BUYIDONGZU`;    ///判断
  if($ex==0)
     {
       group  -em  -n $BUYIDONGZU;
     }
    parent $grp("head_all_bn_Group");
  
  
  select -r  $jaw_bn;
  string$zuiba_zhengti=($jaw_bn+"_zhengti");
  
  duplicate -rr -n $zuiba_zhengti;
  
  
    string$zhengti_grp=($jaw_bn+"_zhengti_grp");
  int$ex=`objExists $zhengti_grp`;    ///判断
  if($ex==0)
     {
       group  -em  -n $zhengti_grp;
     }
  
  string$ziwuti_A[]=`listRelatives -c  -pa $zuiba_zhengti`;
  string $jawzhengti_end=($zuiba_zhengti+"_BN_end");
  rename $ziwuti_A[0] $jawzhengti_end;
  move -r 0 ($tx*0.05) 0 ;
  $qvxian_jaw_zhengti_bn=$zuiba_zhengti;
  setAttr -type "string"($head_qvxian+".jaw_zhengti_bn") $qvxian_jaw_zhengti_bn;
 transformLimits -tx -1 1 -etx 1 1 $bn_con;
 transformLimits -ty -1 1 -ety 1 1 $bn_con;
 transformLimits -tz -1 1 -etz 1 1 $bn_con;
 transformLimits -tz 0 0 -etz 1 1 $bn_con;
 
 transformLimits -ry 0 0 -ery 1 1 $bn_con;
 transformLimits -rx 0 0 -erx 1 1 $bn_con;
 transformLimits -rz -30 30 -erz 1 1 $bn_con;
 
 delete`pointConstraint  $zuiba_zhengti $zhengti_grp  `;
 parent $zhengti_grp $grp;
 parent $zuiba_zhengti $zhengti_grp;
 setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($bn_con+".ty") ($zuiba_zhengti+".ty");  
 setDrivenKeyframe -itt "linear" -ott "spline" -v -1 -dv -1 -cd ($bn_con+".ty") ($zuiba_zhengti+".ty"); 
   
  setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($bn_con+".ty") ($zuiba_zhengti+".ty"); 
  setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 1 -cd ($bn_con+".ty") ($zuiba_zhengti+".ty"); 
  
   setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 0 -cd ($bn_con+".ty") ($zuiba_zhengti+".sx"); 
   setDrivenKeyframe -itt "linear" -ott "spline" -v 1.1 -dv 1 -cd ($bn_con+".ty") ($zuiba_zhengti+".sx"); 
   
  setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($bn_con+".tx") ($zuiba_zhengti+".ry"); 
  setDrivenKeyframe -itt "linear" -ott "spline" -v -5 -dv 1 -cd ($bn_con+".tx") ($zuiba_zhengti+".ry"); 

  setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($bn_con+".tx") ($zuiba_zhengti+".ry"); 
  setDrivenKeyframe -itt "linear" -ott "spline" -v 5 -dv -1 -cd ($bn_con+".tx") ($zuiba_zhengti+".ry");
  
  
  setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($bn_con+".rz") ($zuiba_zhengti+".rx"); 
  setDrivenKeyframe -itt "linear" -ott "spline" -v 10 -dv 30 -cd ($bn_con+".rz") ($zuiba_zhengti+".rx");  
  
  setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($bn_con+".rz") ($zuiba_zhengti+".rx"); 
  setDrivenKeyframe -itt "linear" -ott "spline" -v -10 -dv -30 -cd ($bn_con+".rz") ($zuiba_zhengti+".rx");  
  zxb_zairufangfa_D_proc("zuibazhengti_button");
  
  
  zxb_zairufangfa_vsanniu_proc("zuibazhengti_button_delete");
  
}  

////////删除嘴巴整体////////////////////
global proc zxb_xiababangding_delete_proc()
{
     string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
    string$zu_s=`getAttr ($head_qvxian+".jaw")`;
    string $array[] = stringToStringArray($zu_s, " ");//字符串转化数组
    delete $array;
    zxb_zairufangfa_vsanniu_on_proc("zuibazhengti_button_delete");
    zxb_zairufangfa_vsanniu_proc("zuibazhengti_button");
}

/////////////////创建混合变形////////
/////////////////创建混合变形////////
global proc zxb_hunhebianx_proc()
{
  string $xiaba_mode=`textFieldGrp -q -tx  UI_head_mode`;
  string $xiaba_head_con=`textFieldGrp -q -tx UI_head_controller `;
  
  int$ex=`objExists $xiaba_mode`; 
  if($ex==0){ error  "头部模型没有载入";}
  
  int$ex=`objExists $xiaba_head_con`; 
  if($ex==0){ error  "头部控制器没有载入";}
  
  
  string$jaw_root=`getAttr ($xiaba_head_con+".jaw_root_bn")`;
  int$ex=`objExists $jaw_root`; 
  if($ex==0){ error  "下巴根关节不存在 请创建下巴绑定";}
  
  string$jaw_zhengti=`getAttr ($xiaba_head_con+".jaw_zhengti_bn")`;
  int$ex=`objExists $jaw_zhengti`; 
  if($ex==0){ error  "嘴巴整体关节不存在 请创建下巴绑定";}
  
  string$jaw_bn=`getAttr ($xiaba_head_con+".UI_jaw_bn")`;
  
  int$ex=`objExists $jaw_bn`; 
  if($ex==0){ error  "下巴关节不存在 请创建下巴绑定";}
  int$ex=`objExists "zxb_face_bs"`; 
  if($ex==1){ error  "混合变形已经创建 请清除 zxb_face_bs";}
  zxb_zairufangfa_D_proc("hedebs_button");
  
  
  string$mode=$xiaba_mode;
 /* string$zhangzui=($mode+"_open_mouth_lay");
  string$zhengti=($mode+"_mouth_whole_lay");
  string$fanxiang=($mode+"_repeated_mouth_lay");
  string$zhangzui_A=($mode+"_open_A_mouth_lay");*/
  

  
  string$modegrp="head_bs_grop_lay";
  zxb_ADD_shuxing_string_proc($xiaba_head_con,$modegrp);//添加混合变形模型组得属性
  setAttr -type "string"($xiaba_head_con+"."+$modegrp) $modegrp;
  select -cl  ;
  zxb_ADD_kongzu_proc($modegrp);
  string $fuwuti[]=`listRelatives -p $modegrp`; 
  int$ex=`objExists $fuwuti[0]`; ///判断
  if($ex==0){ parent $modegrp "Face_Group" ;}
  //                                 1                 2                 3                 4                   5               6                7
  string$fase_bs_mode_nemes[]={"open_mouth_lay","mouth_whole_lay","repeated_mouth_lay","open_A_mouth_lay","eye_lip_lay","eye_lip_ciji_lay"};//混合变形模型列表
  //string$fase_bs_mode_nemes[]={};//睫毛 泪腺等 混合变形模型列表
  string$zidonguv="zxb_face_UV_mode_lay";
  select -r $mode;
  duplicate -rr -n $zidonguv;
  
  hilite  $zidonguv ;
  selectMode -component ;
  select -r ( $zidonguv+".f[0:9999999999999999999999]");
  polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 0 -l 2 -sc 1 -o 1 -p 6 -ps 0.2 -ws 0 ( $zidonguv+".f[0:9999999999999999999999]");
  select -r  $zidonguv;
  DeleteHistory;
  parent $zidonguv $modegrp;
  
  select -cl  ;
  select -r  $mode;
  select -add $zidonguv ;
  string$blendShape_s[]=`blendShape`;
  setAttr ($blendShape_s[0]+"."+$xiaba_mode) 1;
  setAttr ($zidonguv+".visibility") 0;
  string$uv_mode="zxb_face_UV_mode";
  zxb_ADD_shuxing_string_proc($xiaba_head_con,$uv_mode);
  setAttr -type "string"($xiaba_head_con+"."+$uv_mode) $uv_mode;
  
  string$mode_lst="";
  select -r $mode;
  string$bss[]=`blendShape`;
  rename $bss[0] "zxb_face_bs";//创建混合变形
  string $mode_shepe[]=`listRelatives -s $mode`; 
  string $tweak1_s[]=`listConnections -d 0 -s 1  ($mode_shepe[0]+".tweakLocation")`;//列出链接属性  -d输入   -s输出  -p 列出属性
  string $skinCluster_s[]=`listConnections -d 0 -s 1  ($mode_shepe[0]+".inMesh")`;//列出链接属性  -d输入   -s输出  -p 列出属性
  
  reorderDeformers $tweak1_s[0] "zxb_face_bs" $mode;
  for ($i=0;$i<size($fase_bs_mode_nemes);$i++)
      {
       string$temp_mode=$fase_bs_mode_nemes[$i]; 
       $mode_lst+=$temp_mode+" ";
       select -r $mode;
       duplicate -rr -n $temp_mode;
       string $fuwuti_temp_a[]=`listRelatives -p $temp_mode`; 
       if( $fuwuti_temp_a[0]!=$modegrp){parent$temp_mode $modegrp;}
       
       setAttr ($temp_mode+".visibility") 0;
       string $listOfShapesInNode[] =`listAttr -k -m "zxb_face_bs"`;
       int$idex=0;
       $idex=size($listOfShapesInNode)-2;
       blendShape -e  -t $mode $idex $temp_mode 1 "zxb_face_bs";
       setAttr ("zxb_face_bs."+$temp_mode) 1;

       if($i==0)
         {
          select -r $jaw_root;
          select -add $jaw_bn;
          select -add $temp_mode;
          skinCluster; 
          }
       if($i==1)
         {
          select -r $jaw_root;
          select -add $jaw_zhengti;
          select -add $temp_mode;
          skinCluster; 
          }
       if($i==2)
         {
          select -r $jaw_root;
          select -add $jaw_bn;
          select -add $temp_mode;
          skinCluster; 
          }
       if($i==3)
         {
          select -r $jaw_root;
          select -add $jaw_bn;
          select -add $temp_mode;
          skinCluster; 
          setAttr ("zxb_face_bs."+$temp_mode) 0;
          }
        
      }
  
  //string$reverse=($mode+"_reverse_mouth_lay");
  zxb_ADD_shuxing_string_proc($xiaba_head_con,"base_bs_mode");//添加保存混合变形模型得名字属性
  //string$base_bs_string="";
  //$base_bs_string+=($zhangzui+" "+$zhengti+" "+$fanxiang+" ");
  setAttr -type "string"($xiaba_head_con+".base_bs_mode") $mode_lst;//保存混合变形模型名


  
  
  zxb_ADD_shuxing_string_proc($xiaba_head_con,"base_bs_shuxing");//添加混合变形属性
   string$base_bs_shuxing="";
  $base_bs_shuxing+="zxb_face_bs";
  setAttr -type "string"($xiaba_head_con+".base_bs_shuxing") $base_bs_shuxing;//保存混合变形属性
  
  
  string$lailian="";
  $lailian+=$fase_bs_mode_nemes[2]+" "+$fase_bs_mode_nemes[3]+" ";
  zxb_ADD_shuxing_string_proc($xiaba_head_con,"base_bs_lalian");//添加拉链嘴巴模型
  setAttr -type "string" ($xiaba_head_con+".base_bs_lalian") $lailian;//保存拉链嘴巴混合变形模型数据
   
 
  

  
  zxb_zairufangfa_vsanniu_proc("headhunhebianxing_button"); 
}




/////////////删除混合变形/////////
global proc zxb_delete_head_bs_proc()
{
   string$head_con=`textFieldGrp  -q -tx  UI_head_controller`;
   string$head_bs=`getAttr ($head_con+".base_bs_shuxing")`;
   string$head_mode=`getAttr ($head_con+".base_bs_mode")`;
   
   string$array[]= stringToStringArray($head_mode, " ");//字符串转化数组
   select -r $head_bs;
   delete $head_bs;
   select -r $array;
   delete $array;
   zxb_zairufangfa_vsanniu_proc("hedebs_button"); 
   zxb_zairufangfa_vsanniu_on_proc("headhunhebianxing_button");
}
/////////////编辑混合变形/////////
global proc zxb_edit_head_bs_proc()
{}

/////////////添加混合变形/////////
global proc zxb_ADD_head_bs_proc()
{}


///////////////////检查模型是否对称//////////////////////
global proc zxb_zairufangfa_toubu_proc(string$tempname,string$butt)
{
string $sel[]=`ls -sl`;
textFieldGrp -e -tx $sel[0] $tempname;
button -e -en 0 $butt;
int$aa=`checkBox -q  -v hede_vs`;
if($aa==0){zxb_jianchamoxing ("确定");}

}
global proc int zxb_jianchamoxing (string $okMessage)
{
global string $gMainProgressBar;
int $tempInt[];
int $numVtxs,$mirrortVtx,$i;
int $return=1;
float $mag;
float $posA[],$posB[];
string $sel[]=`ls -sl`;
string $m;

if (!size($sel))
	error "没有选择模型";

//check Transform
$tempFloat=`getAttr ($sel[0]+".t")`;
if ($tempFloat[0]!=0) $m+="TranslateX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="TranslateY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="TranslateZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".r")`;
if ($tempFloat[0]!=0) $m+="RotateX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="RotateY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="RotateZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".s")`;
if ($tempFloat[0]!=1) $m+="ScaleX = "+$tempFloat[0]+", should be 1\n";
if ($tempFloat[1]!=1) $m+="ScaleY = "+$tempFloat[1]+", should be 1\n";
if ($tempFloat[2]!=1) $m+="ScaleZ = "+$tempFloat[2]+", should be 1\n";
$tempFloat=`getAttr ($sel[0]+".rp")`;
if ($tempFloat[0]!=0) $m+="RotatePivotX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="RotatePivotY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="RotatePivotZ = "+$tempFloat[2]+", should be 0\n";
$tempFloat=`getAttr ($sel[0]+".sp")`;
if ($tempFloat[0]!=0) $m+="ScalePivotX = "+$tempFloat[0]+", should be 0\n";
if ($tempFloat[1]!=0) $m+="ScalePivotY = "+$tempFloat[1]+", should be 0\n";
if ($tempFloat[2]!=0) $m+="ScalePivotZ = "+$tempFloat[2]+", should be 0\n";

if ($m!="")
	$m=$m+"\上面的旋转值非默认值.\n"
			+"在构建正面朝上时会导致错误\n"
			+"建议使用冻结坐标工具,\n"
			+"在绑定之前.";
if ($m!="")
	{
	$dialog=`confirmDialog -t "确认" -m $m -b $okMessage -b "取消" -db "取消" -ds "取消"`;
	if ($dialog!=$okMessage)
		$return=0;
	return $return;
	}

//Symmetry check
if (`objExists closestSampler`) delete closestSampler;
createNode -n closestSampler closestPointOnMesh;
connectAttr -f ($sel[$i]+".outMesh") closestSampler.inMesh;
$tempInt=`polyEvaluate -v $sel[$i]`;
$numVtxs=$tempInt[0];
select -cl;
progressBar -e -st "检查顶点" -bp -ii 1 -min 0 -max $numVtxs $gMainProgressBar;
for ($i=0;$i<$numVtxs;$i++)
	{
	if (`progressBar -q -ic $gMainProgressBar`)
		{progressBar -e -ep $gMainProgressBar;break;}
	progressBar -e -s 1 $gMainProgressBar;
	$posA=`xform -q -ws -t ($sel[0]+".vtx["+$i+"]")`;
	if ($posA[0]>0.001)
		continue;
	setAttr closestSampler.inPosition ($posA[0]*-1) $posA[1] $posA[2];
	$mirrortVtx=`getAttr closestSampler.closestVertexIndex`;
	$posB=`xform -q -ws -t ($sel[0]+".vtx["+$mirrortVtx+"]")`;
	$mag=`mag <<($posA[0]-($posB[0]*-1)),($posA[1]-$posB[1]),($posA[2]-$posB[2])>>`;
	if ($mag>0.001)
		select -add ($sel[0]+".vtx["+$i+"]") ($sel[0]+".vtx["+$mirrortVtx+"]");
	}
progressBar -e -ep $gMainProgressBar;
delete closestSampler;
refresh;
if (size(`ls -sl`))
	{
	$dialog=`confirmDialog -t "顶点" -m "选定的顶点不对称" -b $okMessage -b "取消" -db "确认" -ds "确认"`;
	if ($dialog!=$okMessage)
		$return=0;
	}
else
	print "//模型是对称的.\n";

return $return;
}



/////////////////////创建面板/
global proc zxb_head_biankuang(){
$teststring=`textFieldGrp -q -tx UI_head_mode `;
$con=`textFieldGrp -q -tx UI_head_controller `;

int$ex=`objExists $teststring`; 
if($ex==0){ error  "头部模型没有载入" ;}

int$ex=`objExists $con`; 
if($ex==0){ error  "头部控制器没有载入" ;}

string $mode_sheps[]=`listRelatives -s $teststring`;
int$ex=`objExists ($mode_sheps[0]+".outMesh")`; 
if($ex==0){ error  "载入的头部物体不是多边形网格" ;}
$gtCN=$teststring;
zxb_zairufangfa_D_proc("hedemianbankuan_button");
string $gtCname;
$gtCname=$gtCN+"_";
string$head=$gtCname;
string$qvxian= ($gtCname+"faceFrame");
int $state=`objExists  ($gtCname+"faceFrame")`;

if($state==1) error "当前名字已被使用，请用其它名字!!!";

curve -d 3 -p -6 -6 0 -p 6 -6 0 -p 6 -6 0 -p 6 -6 0 -p 6 6 0 -p 6 6 0 -p 6 6 0 -p -6 6 0 -p -6 6 0 
-p -6 6 0 -p -6 -6 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 8 -k 8  -n ($gtCname+"faceFrame");
setAttr ($gtCname+"faceFrame.scaleX") 0.5;
select -r ($gtCname+"faceFrame");
channelBoxCommand -freezeScale;
select -r ($gtCname+"faceFrame");
duplicate -rr -n ($gtCname+"faceFrame1");
scale 0.975 0.975 0.975;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;

pickWalk -d down;
select -add ($gtCname+"faceFrame");
parent -s -r;
delete ($gtCname+"faceFrame1");

select -r ($gtCname+"faceFrame");
addAttr -ln "FrameHnum"  -at long;

float$obx_Max[]=`getAttr ($con+".boundingBoxMax")`;////绑定box节点
float$soce=$obx_Max[0]*0.1;

//setAttr -type float3  ($qvxian+".t") $obx_Max[0] $obx_Max[1] $obx_Max[2];
string$kongzu=$qvxian+"_grp";
zxb_ADD_kongzuA_proc( $kongzu,$qvxian);
setAttr ($kongzu+".scale") $soce $soce $soce;

delete`pointConstraint $con $kongzu`;//点约束
setAttr ($kongzu+".translateX") $obx_Max[0] ;
setAttr ($kongzu+".translateZ") $obx_Max[2] ;

string$miaban="head_mianabn";
zxb_ADD_shuxing_string_proc($con,$miaban);
setAttr -type "string"($con+"."+$miaban) $kongzu;

parent  $kongzu ("head_curve_Group");

string$Mouth_MM="Mouth_MM";
string$Mouth_M="Mouth_M";
string$Mouth_L="Mouth_L";
string$Mouth_R="Mouth_R";
string$Cheek_L="Cheek_L";
string$Cheek_R="Cheek_R";
string$Nose_L="Nose_L";
string$Nose_R="Nose_R";
string$Eye_L="Eye_L";
string$Eye_R="Eye_R";
string$Brow_L="Brow_L";
string$Brow_R="Brow_R";




string$mouth_MM="mouth_MM";
string$mouth_M="mouth_M";
string$mouth_L="mouth_L";
string$mouth_R="mouth_R";
string$nose_L="nose_L";
string$nose_R="nose_R";
string$cheek_L="cheek_L";
string$cheek_R="cheek_R";
string$eye_L="eye_L";
string$eye_R="eye_R";
string$brow_L="brow_L";
string$brow_R="brow_R";



string$mianban_mouth_MM=$head+$mouth_MM;
string$mianban_mouth_M=$head+$mouth_M;
string$mianban_mouth_R=$head+$mouth_R;
string$mianban_mouth_L=$head+$mouth_L;
string$mianban_cheek_L=$head+$cheek_L;
string$mianban_cheek_R=$head+$cheek_R;
string$mianban_eye_L=$head+$eye_L;
string$mianban_eye_R=$head+$eye_R;
string$mianban_eye_LUp=$head+$eye_L+"Up";
string$mianban_eye_LDown=$head+$eye_L+"Down";
string$mianban_eye_RUp=$head+$eye_R+"Up";
string$mianban_eye_RDown=$head+$eye_R+"Down";
string$mianban_brow_L=$head+$brow_L;
string$mianban_brow_R=$head+$brow_R;

string$mianban_nose_L=$head+$nose_L;
string$mianban_nose_R=$head+$nose_R;
string$shuzu="";
$shuzu+=$mianban_mouth_MM+" "+$mianban_mouth_M+" "+$mianban_mouth_R+" "+$mianban_mouth_L+" "+$mianban_nose_L+" "+$mianban_nose_R+" "+$mianban_cheek_L+" "+$mianban_cheek_R+" "+$mianban_eye_L+" "+$mianban_eye_R+" "+$mianban_brow_L+" "+$mianban_brow_R+" "+$mianban_eye_LUp+" "+$mianban_eye_LDown+" "+$mianban_eye_RUp+" "+$mianban_eye_RDown+" ";
string$allcon="Head_allcon";
zxb_ADD_shuxing_string_proc($con,$allcon);
setAttr -type "string" ($con+"."+$allcon) $shuzu;

string$mianban_Mouth_MM=$head+$Mouth_MM;
zxb_chuangjananniu_proc(1,$mouth_MM,0,$Mouth_MM);
setAttr -type float3($mianban_Mouth_MM+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Mouth_MM+".translateY") -3;
setAttr ($mianban_Mouth_MM+".translateX") -1.5;

string$mianban_Mouth_M=$head+$Mouth_M;
zxb_chuangjananniu_proc(1,$mouth_M,0,$Mouth_M);
setAttr -type float3($mianban_Mouth_M+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Mouth_M+".translateY") -3;
setAttr ($mianban_Mouth_M+".translateX") 1.5;


string$mianban_Mouth_R=$head+$Mouth_R;
zxb_chuangjananniu_proc(1,$mouth_R,0,$Mouth_R);
setAttr -type float3($mianban_Mouth_R+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Mouth_R+".translateY") -5;
setAttr ($mianban_Mouth_R+".translateX") -1.5;

string$mianban_Mouth_L=$head+$Mouth_L;
zxb_chuangjananniu_proc(1,$mouth_L,0,$Mouth_L);
setAttr -type float3($mianban_Mouth_L+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Mouth_L+".translateY") -5;
setAttr ($mianban_Mouth_L+".translateX") 1.5;



string$mianban_Nose_L=$head+$Nose_L;
zxb_chuangjananniu_proc(1,$nose_L,0,$Nose_L);
setAttr -type float3($mianban_Nose_L+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Nose_L+".translateX") -1.5;
setAttr ($mianban_Nose_L+".translateY") -1;


string$mianban_Nose_R=$head+$Nose_R;
zxb_chuangjananniu_proc(1,$nose_R,0,$Nose_R);
setAttr -type float3($mianban_Nose_R+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Nose_R+".translateX") 1.5;
setAttr ($mianban_Nose_R+".translateY") -1;


string$mianban_Cheek_L=$head+$Cheek_L;
zxb_chuangjananniu_proc(1,$cheek_L,0,$Cheek_L);
setAttr -type float3($mianban_Cheek_L+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Cheek_L+".translateY") 1;
setAttr ($mianban_Cheek_L+".translateX") 1.5;

string$mianban_Cheek_R=$head+$Cheek_R;
zxb_chuangjananniu_proc(1,$cheek_R,0,$Cheek_R);
setAttr -type float3($mianban_Cheek_R+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Cheek_R+".translateX") -1.5;
setAttr ($mianban_Cheek_R+".translateY") 1;

string$mianban_Eye_L=$head+$Eye_L;
zxb_chuangjananniu_proc(4,$eye_L,0,$Eye_L);
setAttr -type float3($mianban_Eye_L+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Eye_L+".translateY") 3;
setAttr ($mianban_Eye_L+".translateX") -1.5;


string$mianban_Eye_R=$head+$Eye_R;
zxb_chuangjananniu_proc(4,$eye_R,0,$Eye_R);
setAttr -type float3($mianban_Eye_R+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Eye_R+".translateY") 3;
setAttr ($mianban_Eye_R+".translateX") 1.5;


string$mianban_Brow_L=$head+$Brow_L;
zxb_chuangjananniu_proc(1,$brow_L,0,$Brow_L);
setAttr -type float3($mianban_Brow_L+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Brow_L+".translateY") 5;
setAttr ($mianban_Brow_L+".translateX")1.5;


string$mianban_Brow_R=$head+$Brow_R;
zxb_chuangjananniu_proc(1,$brow_R,0,$Brow_R);
setAttr -type float3($mianban_Brow_R+".scale") 0.5 0.5 0.5;
setAttr ($mianban_Brow_R+".translateY") 5;
setAttr ($mianban_Brow_R+".translateX") -1.5;



zxb_zairufangfa_vsanniu_proc("hedemianbankuan_delete_button");
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_wancheng_button");
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_bianji_button");
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_Add_button");
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_Add_delete_button");

}
///////////删除面板/////////////

global proc zxb_head_chongxing()
{
  string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
  zxb_zairufangfa_vsanniu_proc("hedemianbankuan_button");
  string$mianban=`getAttr ($head_qvxian+".head_mianabn")`;
  delete $mianban;
  zxb_zairufangfa_vsanniu_proc("hedemianbankuan_button");
  zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_delete_button");
  zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_wancheng_button");
  zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_bianji_button");
  zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_Add_button");
  zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_Add_delete_button");
}



///////////////按钮////////////////////
global proc zxb_chuangjananniu_proc(int$xinghzuang,string $xiaba,int$fangxiang,string$mingzi)
{
    //int$xinghzuang=2;string $xiaba="xiaba";$fangxiang=0;
    
$teststring=`textFieldGrp -q -tx UI_head_mode `;
$gtCN=$teststring;

string $gtCname;
$gtCname=$gtCN+"_";
int $selec=$xinghzuang;
float $minH=-1;
float $maxH=1;
float $minV=-1;
float $maxV=1;
string $name=$xiaba;
int $fnm=`getAttr ($gtCname+"faceFrame.FrameHnum")`;
setAttr ($gtCname+"faceFrame.FrameHnum") ($fnm+1);

if($selec==1){
int $vv=$fangxiang;
//////////////////////////////
curve -d 3 -p -1 1 0 -p 1 1 0 -p 1 1 0 -p 1 1 0 -p 1 -1 0 -p 1 -1 0 -p 1 -1 0 -p -1 -1 0 -p -1 -1 0 
-p -1 -1 0 -p -1 1 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 8 -k 8 -n ($gtCname+$mingzi);

select -r ($gtCname+$mingzi);

duplicate -rr -n ($gtCname+$mingzi+"_temp");
scale 1.1 1.1 1.1;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;
pickWalk -d down;

select -add ($gtCname+$mingzi);
parent -s -r;
delete ($gtCname+$mingzi+"_temp");

select -r ($gtCname+$mingzi);
scale 1.2 1.2 1.2;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;

if($vv==1)
{
setAttr ($gtCname+$mingzi+".rz") 45;
select -r ($gtCname+$mingzi+".cv[0:*]");
rotate -r 0 0 -45;
}

circle -ch 0 -o on -r 0.15 -n ($gtCname+$name);
string $b[]=`ls -sl`;

setAttr -lock true ($b[0]+".rx");
setAttr -lock true ($b[0]+".ry");
setAttr -lock true ($b[0]+".rz");
setAttr -lock true ($b[0]+".sx");
setAttr -lock true ($b[0]+".sy");
setAttr -lock true ($b[0]+".sz");
setAttr -lock true ($b[0]+".v");
setAttr -lock true ($b[0]+".tz");

select -add ($gtCname+$mingzi);
parent;
string $tempN[]=`ls -sl`;
transformLimits -tx $minH $maxH -etx 1 1 ($tempN[0]);
transformLimits -ty $minV $maxV -ety 1 1 ($tempN[0]);
transformLimits -tz 0 0  -etz 1 1 ($tempN[0]);

textCurves -ch 0 -f "Times New Roman|h-13|w400|c0" -t $name;
string $sel[]=`ls -sl`;
rename $sel[0] ($gtCname+$name+"temp");
string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;

for($i=0;$i<size($childs);$i++)
{
  string $c[]=`listRelatives -fullPath -c ($childs[$i])`;
  for($j=0;$j<size($c);$j++)
  {
  select -r ($c[$j]);
  select -add ($gtCname+$name+"temp");
  parent;
  }
delete ($childs[$i]);
}

string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;
select -r $childs[0];
rename $name;
string $currentN[]=`ls -sl`;

for($i=1;$i<size($childs);$i++)
   {
  select -r ($childs[$i]);
  makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
  pickWalk -d down;
  select -add $currentN[0];
  parent -s -r;
  delete ($childs[$i]);
}


select -r $currentN[0];
CenterPivot;
scale 0.75 0.75 0.75;
spaceLocator -p 0 0 0 -n ($name+"temp");
move 0 -1.5 0 ;
select -add $currentN[0];
delete `pointConstraint`;
delete ($name+"temp");
select -r $currentN[0];

group -n ($xiaba+"faceConName");
CenterPivot;
select -add ($gtCname+$mingzi);
parent;
delete ($gtCname+$name+"temp");


select -r ($gtCname+$mingzi);
select -add ($gtCname+"faceFrame") ;
parent;
setAttr ($gtCname+$mingzi+".tx") 0;
setAttr ($gtCname+$mingzi+".ty") 0;
setAttr ($gtCname+$mingzi+".tz") 0;
setAttr ($gtCname+$mingzi+".sx") 1;
setAttr ($gtCname+$mingzi+".sy") 1;
setAttr ($gtCname+$mingzi+".sz") 1;

}
/////////////////////////////////////////////////
if($selec==2){
curve -d 3 -p -1 1 0 -p 1 1 0 -p 1 1 0 -p 1 1 0 -p 1 0 0 -p 1 0 0 -p 1 0 0 -p -1 0 0 -p -1 0 0 -p -1 0 0 -p -1 1 0 
-k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 8 -k 8 -n ($gtCname+$mingzi);

select -r ($gtCname+$mingzi);
CenterPivot;
setAttr ($gtCname+$mingzi+".scaleY") 0.15;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;

duplicate -rr -n ($gtCname+$mingzi+"_temp");
scale 1.1 2 1.1;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;
pickWalk -d down;

select -add ($gtCname+$mingzi);
parent -s -r;
delete ($gtCname+$mingzi+"_temp");

circle -ch 0 -o on -r 0.24 -n ($gtCname+$name);
move 0 0.5 0;
makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;

string $b[]=`ls -sl`;


select -r ($b[0]+".cv[1]") ($b[0]+".cv[5]") ;
select -tgl ($b[0]+".cv[3]") ($b[0]+".cv[7]") ;
scale  0.6 0.6 0.6 ;
select -r ($b[0]+".cv[0:7]");
scale 1 1.3 1;

setAttr -lock true ($b[0]+".rx");
setAttr -lock true ($b[0]+".ry");
setAttr -lock true ($b[0]+".rz");
setAttr -lock true ($b[0]+".sx");
setAttr -lock true ($b[0]+".sy");
setAttr -lock true ($b[0]+".sz");
setAttr -lock true ($b[0]+".v");
setAttr -lock true ($b[0]+".tz");
setAttr -lock true ($b[0]+".ty");
select -r $b;
select -add ($gtCname+$mingzi);
parent;


string $tempN[]=`ls -sl`;
transformLimits -tx $minH $maxH -etx 1 1 ($tempN[0]);
transformLimits -ty 0 0 -ety 1 1 ($tempN[0]);
transformLimits -tz 0 0  -etz 1 1 ($tempN[0]);

textCurves -ch 0 -f "Times New Roman|h-13|w400|c0" -t $name;
string $sel[]=`ls -sl`;
rename $sel[0] ($gtCname+$name+"temp");
string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;

for($i=0;$i<size($childs);$i++)
{
string $c[]=`listRelatives -fullPath -c ($childs[$i])`;
for($j=0;$j<size($c);$j++)
{
select -r ($c[$j]);
select -add ($gtCname+$name+"temp");
parent;
}
delete ($childs[$i]);
}

string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;
select -r $childs[0];
rename $name;
string $currentN[]=`ls -sl`;
for($i=1;$i<size($childs);$i++)
{
select -r ($childs[$i]);
makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
pickWalk -d down;
select -add $currentN[0];
parent -s -r;
delete ($childs[$i]);
}


select -r $currentN[0];
CenterPivot;
scale 0.75  0.75 0.75;
spaceLocator -p 0 0 0 -n ($name+"temp");
move 0 -0.05 0 ;
select -add $currentN[0];
delete `pointConstraint`;
delete ($name+"temp");
select -r $currentN[0];;
group -n ($xiaba+"faceConName");
CenterPivot;
select -add ($gtCname+$mingzi);
parent;
delete ($gtCname+$name+"temp");


select -r ($gtCname+$mingzi);
select -add ($gtCname+"faceFrame") ;
parent;
setAttr ($gtCname+$mingzi+".tx") 0;
setAttr ($gtCname+$mingzi+".ty") 0;
setAttr ($gtCname+$mingzi+".tz") 0;
setAttr ($gtCname+$mingzi+".sx") 1;
setAttr ($gtCname+$mingzi+".sy") 1;
setAttr ($gtCname+$mingzi+".sz") 1;
setAttr ($gtCname+$mingzi+".rx") 0;
setAttr ($gtCname+$mingzi+".ry") 0;
setAttr ($gtCname+$mingzi+".rz") 0;
}
///////////////////////////////////////////////////////


if($selec==3){
curve -d 3 -p 0 -1 0 -p 1 -1 0 -p 1 -1 0 -p 1 -1 0 -p 1 1 0 -p 1 1 0 -p 1 1 0 -p 0 1 0 -p 0 1 0 -p 0 1 0 -p 0 -1 0 
-k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 8 -k 8 -n ($gtCname+$mingzi);

select -r ($gtCname+$mingzi);
CenterPivot;

scale 0.15 1 1 ($gtCname+$mingzi);
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;

duplicate -rr -n ($gtCname+$mingzi+"_temp");
scale 2 1.1 1.1;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;
pickWalk -d down;

select -add ($gtCname+$mingzi);
parent -s -r;
delete ($gtCname+$mingzi+"_temp");

circle -ch 0 -o on -r 0.25 -n ($gtCname+$name);
move 0.5 0 0;
makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
string $b[]=`ls -sl`;
select -r ($b[0]+".cv[1]") ($b[0]+".cv[5]") ;
select -tgl ($b[0]+".cv[3]") ($b[0]+".cv[7]") ;
scale  0.6 0.6 0.6 ;
select -r ($b[0]+".cv[0:7]");
scale 1.3 1 1;

setAttr -lock true ($b[0]+".rx");
setAttr -lock true ($b[0]+".ry");
setAttr -lock true ($b[0]+".rz");
setAttr -lock true ($b[0]+".sx");
setAttr -lock true ($b[0]+".sy");
setAttr -lock true ($b[0]+".sz");
setAttr -lock true ($b[0]+".v");
setAttr -lock true ($b[0]+".tz");
setAttr -lock true ($b[0]+".tx");

select -r $b;
select -add ($gtCname+$mingzi);
parent;


string $tempN[]=`ls -sl`;
transformLimits -tx 0 0 -etx 1 1 ($tempN[0]);
transformLimits -ty $minV $maxV -ety 1 1 ($tempN[0]);
transformLimits -tz 0 0  -etz 1 1 ($tempN[0]);

textCurves -ch 0 -f "Times New Roman|h-13|w400|c0" -t $name;
string $sel[]=`ls -sl`;
rename $sel[0] ($gtCname+$name+"temp");
string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;

for($i=0;$i<size($childs);$i++){
string $c[]=`listRelatives -fullPath -c ($childs[$i])`;
for($j=0;$j<size($c);$j++){
select -r ($c[$j]);
select -add ($gtCname+$name+"temp");
parent;
}
delete ($childs[$i]);
}

string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;
select -r $childs[0];
rename $name;
string $currentN[]=`ls -sl`;
for($i=1;$i<size($childs);$i++){
select -r ($childs[$i]);
makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
pickWalk -d down;
select -add $currentN[0];
parent -s -r;
delete ($childs[$i]);
}


select -r $currentN[0];
CenterPivot;
scale 0.75 0.75 0.75;
spaceLocator -p 0 0 0 -n ($name+"temp");
move 0.5 -1.5 0 ;
select -add $currentN[0];
delete `pointConstraint`;
delete ($name+"temp");
select -r $currentN[0];;
group -n ($xiaba+"faceConName");
CenterPivot;
select -add ($gtCname+$mingzi);
parent;
delete ($gtCname+$name+"temp");




select -r ($gtCname+$mingzi);
select -add ($gtCname+"faceFrame") ;
parent;
setAttr ($gtCname+$mingzi+".tx") 0;
setAttr ($gtCname+$mingzi+".ty") 0;
setAttr ($gtCname+$mingzi+".tz") 0;
setAttr ($gtCname+$mingzi+".sx") 1;
setAttr ($gtCname+$mingzi+".sy") 1;
setAttr ($gtCname+$mingzi+".sz") 1;
setAttr ($gtCname+$mingzi+".rx") 0;
setAttr ($gtCname+$mingzi+".ry") 0;
setAttr ($gtCname+$mingzi+".rz") 0;
}

//////////////////////////////////////////////


if($selec==4){
curve -d 3 -p -1 1 0 -p 1 1 0 -p 1 1 0 -p 1 1 0 -p 1 -1 0 -p 1 -1 0 -p 1 -1 0 -p -1 -1 0 -p -1 -1 0 
-p -1 -1 0 -p -1 1 0 -k 0 -k 0 -k 0 -k 1 -k 2 -k 3 -k 4 -k 5 -k 6 -k 7 -k 8 -k 8 -k 8 -n ($gtCname+$mingzi);

select -r ($gtCname+$mingzi);

duplicate -rr -n ($gtCname+$mingzi+"_temp");
scale 1.1 1.1 1.1;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;
pickWalk -d down;

select -add ($gtCname+$mingzi);
parent -s -r;
delete ($gtCname+$mingzi+"_temp");

select -r ($gtCname+$mingzi);
scale 1.2 1.2 1.2;
makeIdentity -apply true -t 0 -r 1 -s 1 -n 0;


circle -ch 0 -o on -r 0.35 -n ($gtCname+$name);
string $b[]=`ls -sl`;
scale 1 0.75 1 $b[0];

setAttr -lock true ($b[0]+".rx");
setAttr -lock true ($b[0]+".ry");
setAttr -lock true ($b[0]+".rz");
setAttr -lock true ($b[0]+".sx");
setAttr -lock true ($b[0]+".sy");
setAttr -lock true ($b[0]+".sz");
setAttr -lock true ($b[0]+".v");
setAttr -lock true ($b[0]+".tz");
select -r $b;
select -add ($gtCname+$mingzi);
parent;
string $tempN[]=`ls -sl`;
transformLimits -tx -1 1 -etx 1 1 ($tempN[0]);
transformLimits -ty -.5 .5 -ety 1 1 ($tempN[0]);
transformLimits -tz 0 0  -etz 1 1 ($tempN[0]);
///////////////
circle -ch 0 -o on -r 0.35 -n ($gtCname+$name+"Up");
string $b[]=`ls -sl`;
move 0 0.5 0 $b[0];
select -r $b;
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;


select -r ($b[0]+".cv[5]") ;
move -r 0 0.225 0 ;
select -r ($b[0]+".cv[4:6]") ;
move -r 0 0.225 0 ;


setAttr -lock true ($b[0]+".rx");
setAttr -lock true ($b[0]+".ry");
setAttr -lock true ($b[0]+".rz");
setAttr -lock true ($b[0]+".sx");
setAttr -lock true ($b[0]+".sy");
setAttr -lock true ($b[0]+".sz");
setAttr -lock true ($b[0]+".v");
setAttr -lock true ($b[0]+".tz");
select -r ($b);
select -add ($gtCname+$mingzi);
parent;
string $tempN[]=`ls -sl`;

transformLimits -tx -1 1 -etx 1 1 ($tempN[0]);
transformLimits -ty -.5 .5 -ety 1 1 ($tempN[0]);
transformLimits -tz 0 0  -etz 1 1 ($tempN[0]);

///////////////////////////

circle -ch 0 -o on -r 0.35 -n ($gtCname+$name+"Down");
string $b[]=`ls -sl`;
move 0 -0.5 0 $b[0];
select -r ($b);
makeIdentity -apply true -t 1 -r 1 -s 1 -n 0;

select -r ($b[0]+".cv[1]") ;
move -r 0 -0.225 0 ;
select -r ($b[0]+".cv[0:2]") ;
move -r 0 -0.225 0 ;

setAttr -lock true ($b[0]+".rx");
setAttr -lock true ($b[0]+".ry");
setAttr -lock true ($b[0]+".rz");
setAttr -lock true ($b[0]+".sx");
setAttr -lock true ($b[0]+".sy");
setAttr -lock true ($b[0]+".sz");
setAttr -lock true ($b[0]+".v");
setAttr -lock true ($b[0]+".tz");
select -r ($b);
select -add ($gtCname+$mingzi);
parent;
string $tempN[]=`ls -sl`;

transformLimits -tx -1 1 -etx 1 1 ($tempN[0]);
transformLimits -ty -.5 .5 -ety 1 1 ($tempN[0]);
transformLimits -tz 0 0  -etz 1 1 ($tempN[0]);
//////////////////////////////////////////

textCurves -ch 0 -f "Times New Roman|h-13|w400|c0" -t $name;
string $sel[]=`ls -sl`;
rename $sel[0] ($gtCname+$name+"temp");
string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;

for($i=0;$i<size($childs);$i++){
string $c[]=`listRelatives -fullPath -c ($childs[$i])`;
for($j=0;$j<size($c);$j++){
select -r ($c[$j]);
select -add ($gtCname+$name+"temp");
parent;
}
delete ($childs[$i]);
}

string $childs[]=`listRelatives -fullPath -c  ($gtCname+$name+"temp")`;
select -r $childs[0];
rename $name;
string $currentN[]=`ls -sl`;
for($i=1;$i<size($childs);$i++){
select -r ($childs[$i]);
makeIdentity -apply true -t 1 -r 1 -s 0 -n 0;
pickWalk -d down;
select -add $currentN[0];
parent -s -r;
delete ($childs[$i]);
}

select -r $currentN[0];
CenterPivot;
scale 0.75  0.75  0.75 ;
spaceLocator -p 0 0 0 -n ($name+"temp");
move 0 -1.5 0 ;
select -add $currentN[0];
delete `pointConstraint`;
delete ($name+"temp");
select -r $currentN[0];;
group -n ($xiaba+"faceConName");
CenterPivot;
select -add ($gtCname+$mingzi);
parent;
delete ($gtCname+$name+"temp");

select -r ($gtCname+$mingzi);
select -add ($gtCname+"faceFrame") ;
parent;
setAttr ($gtCname+$mingzi+".tx") 0;
setAttr ($gtCname+$mingzi+".ty") 0;
setAttr ($gtCname+$mingzi+".tz") 0;
setAttr ($gtCname+$mingzi+".sx") 1;
setAttr ($gtCname+$mingzi+".sy") 1;
setAttr ($gtCname+$mingzi+".sz") 1;
    }
}


 
 
 
 
 
 
//////////////完成表情控制面板////////////////////////////
global proc zxb_mianbanwancheng_proc(){
$teststring=`textFieldGrp -q -tx UI_head_mode `;

$gtCN=$teststring;

string $gtCname;
$gtCname=$gtCN+"_";
string $shape[]=`listRelatives  -s ($gtCname+"faceFrame")`;

for($j=0;$j<size($shape);$j++){
setAttr ($shape[$j]+".overrideEnabled") 1;
setAttr ($shape[$j]+".overrideColor") 22;
}

string $frameH[]=`listRelatives  -c -type "transform" ($gtCname+"faceFrame")`;
for($i=0;$i<size($frameH);$i++)
{

string $shape[]=`listRelatives  -c -s ($frameH[$i])`;
for($j=0;$j<size($shape);$j++)
 {
setAttr ($shape[$j]+".overrideEnabled") 1;
setAttr ($shape[$j]+".overrideDisplayType") 1;
  }

string $childs[]=`listRelatives -fullPath -c -type "transform" ($frameH[$i])`;
int $size=size($childs);

setAttr ($childs[($size-1)]+".overrideEnabled") 1;
setAttr ($childs[($size-1)]+".overrideDisplayType") 1;

for($j=0;$j<size($childs)-1;$j++)
     {
setAttr ($childs[$j]+".overrideEnabled") 1;
setAttr ($childs[$j]+".overrideColor") 22;
        }
    } 
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_bianji_button");   
zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_wancheng_button");   

zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_Add_button");
zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_Add_delete_button");
      
}

//////////////编辑面板//////////////////
global proc zxb_mianbanbianji_proc(){
$teststring=`textFieldGrp -q -tx UI_head_mode `;
$gtCN=$teststring;

string $gtCname;
$gtCname=$gtCN+"_";

string $frameH[]=`listRelatives -fullPath -c -type "transform"  ($gtCname+"faceFrame")`;
for($i=0;$i<size($frameH);$i++){

string $shape[]=`listRelatives -fullPath -c -s ($frameH[$i])`;
for($j=0;$j<size($shape);$j++){
setAttr ($shape[$j]+".overrideEnabled") 0;
setAttr ($shape[$j]+".overrideDisplayType") 0;
}

string $childs[]=`listRelatives -fullPath -c -type "transform"  ($frameH[$i])`;
int $size=size($childs);

setAttr ($childs[($size-1)]+".overrideEnabled") 0;
setAttr ($childs[($size-1)]+".overrideDisplayType") 0;

    }
    
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_wancheng_button"); 
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_Add_button");
zxb_zairufangfa_vsanniu_proc("hedemianbankuan_Add_delete_button");
zxb_zairufangfa_vsanniu_on_proc("hedemianbankuan_bianji_button");
}


//////////添加控制器面板////////////////////
global proc zxb_mianban_Addmianban_proc()
{
if(`window -ex zxb_ADD_mianbucon`) deleteUI  zxb_ADD_mianbucon;
window -wh 420 200 -t "添加控制器" zxb_ADD_mianbucon;
columnLayout -adjustableColumn 0; 
checkBox -l "默认方框 选中长条" -value 0 zxb_add_changtiao;
textFieldGrp  -cw2 100 130 -l "外控制器名字前缀大写"    W_con_name;
textFieldGrp  -cw2 100 130 -l "内控制器名字前缀小写"    N_con_name;
button -l  "添加控制器"  -c "zxb_mianban_Add_proc";
showWindow  ;
}


global proc zxb_mianban_Add_proc()
{
    int$aa=`checkBox -q -v zxb_add_changtiao`;
    string$teststring=`textFieldGrp -q -tx UI_head_mode `;
    string$con=`textFieldGrp -q -tx  UI_head_controller`;
    string$W_Neme=`textFieldGrp -q -tx W_con_name `;
    string$N_Neme=`textFieldGrp -q -tx N_con_name `;
    $head=$teststring+"_";
    int$bb=1;
    if($aa==0){$bb=1;}
    if($aa==1){$bb=2;}
    zxb_chuangjananniu_proc($bb,$N_Neme,0,$W_Neme);
    
    
    string$add_head_allcon="add_head_allcon";
    zxb_ADD_shuxing_string_proc($con,$add_head_allcon);
    string$conshuzu=`getAttr ($con+".add_head_allcon")`; 
    string$array_B[] = stringToStringArray($conshuzu, " ");//字符串转化数组
    int$ex=`objExists $array_B[0]`;
    string$addmingzi="";
    if($ex==1)
       {
         for ($i=0;$i<size($array_B);$i++)
              {
               string$temp_mingzxi=$array_B[$i];
               $addmingzi+=$temp_mingzxi+" "+$N_Neme+" ";
               //int$a=size($array_B)-1;
               
               }
       }else
             {
              string$n_neme=$N_Neme+" ";
             setAttr -type "string" ($con+".add_head_allcon") $n_neme  ;
    
             }
       
   if($ex==1){ setAttr -type "string" ($con+".add_head_allcon")  $addmingzi ;}
    
    /*string$dede=$head+$N_Neme;
    string$temp=`getAttr ($con+".Head_allcon")`;
    $temp+=$temp+$dede+" ";
    setAttr -type "string" ($con+".Head_allcon") $temp;*/
}



global proc zxb_mianban_Add_delete_proc()
{
    string$bianliang[]=`ls -sl`;
    string$con=`textFieldGrp -q -tx  UI_head_controller`;
    string$temp=`getAttr ($con+".Head_allcon")`;
    string$array[] = stringToStringArray($temp, " ");//字符串转化数组
    int$ex=`objExists $bianliang[0]`; 
    if($ex==0){ error "请选择表情控制框";}

   string $andbn[]=`listRelatives -c -fullPath  -type "transform" $bianliang[0]`;
   string $rrrrr[]=`listRelatives -c  -type "transform" $bianliang[0]`;
   string$mingzi="";
   for($j=0;$j<size($andbn);$j++)
   {
       string $tempss[]=`listRelatives -s   $andbn[$j]`;
       int$ex=`objExists $tempss[0]`;    ///判断
      if($ex==1){$mingzi=$rrrrr[$j];}
   }
   
 

    string$all_name="";
    
    
   for ($y=0;$y<size($array);$y++)
        {
        string$name=$array[$y];
        if($name==$mingzi)
          {
              //$all_name+=$name+" ";
          $all_name=$name;
          }
        }

   //setAttr -type "string" ($con+".Head_allcon") $all_name ;

    int$ex=`objExists $all_name`; 
    if($ex==1){ error "选中的控制器是默认控制器";}else{ delete $bianliang[0];}
  
}




//////////////////////////////////////////
global proc zxb_open_reverse_proc()
{
 
   string$FKJaw_M_kongzhiqi=`textFieldGrp -q -tx UI_jaw_controller `;
    string$toubu=`textFieldGrp -q -tx UI_head_controller `;
   string$hean_mode=` getAttr ($toubu+".base_bs_lalian")`;
   string $array[]= stringToStringArray($hean_mode, " ");//字符串转化数组
   
   string$hean_bs=` getAttr ($toubu+".base_bs_shuxing")`;
     
   string$open_reverse="open_reverse";
   select -r $FKJaw_M_kongzhiqi;
   zxb_ADD_shuxing_double_A_proc($FKJaw_M_kongzhiqi,$open_reverse);
   string$jiedian=($FKJaw_M_kongzhiqi+"_setRange");
   zxb_ADD_jiedian_proc($jiedian,"setRange");
   
   connectAttr -f ($FKJaw_M_kongzhiqi+".open_reverse") ($jiedian+".valueX");
   setAttr ($jiedian+".oldMaxX") 10;
   setAttr ($jiedian+".maxX") 1;
   
   string$erverse_jiedian=($FKJaw_M_kongzhiqi+"_erverse");
   
   zxb_ADD_jiedian_proc($erverse_jiedian,"reverse");
   
   connectAttr -f  ($jiedian+".outValueX") ($erverse_jiedian+".inputX");
   connectAttr -f ($erverse_jiedian+".outputX") ($hean_bs+"."+$array[1]);
   connectAttr -f ($jiedian+".outValueX") ($hean_bs+"."+$array[0]);
   button -e -en 0 hede_open_reverse_button;
   
}



////////////////////////////选择其他模型上的线
global proc string zxb_xuanzebutongmoxing_jiluxuanzhededian(int $panduan, string $mesh_name)
{
    
   //string $mesh_name="head_mesh_zuiba_nianlian";
   string $bianliang[]=`ls -sl -fl`;

 //int $panduan=0;
   string $dian="vtx";
   if($panduan==0)
    {
    $dian="e";
    }else
    {
     $dian="vtx";
     }

   select -cl  ;


  for ($ll=0;$ll<size($bianliang);$ll++)
  {
    string $temp_name[];
    int $chafen=`tokenize $bianliang[$ll] "[" $temp_name`;
    int $chafen=`tokenize $temp_name[1] "]" $temp_name`;
    int $xuhao=$temp_name[0];
    select -add ($mesh_name+"."+$dian+"["+$xuhao+"]");
   // print  $temp_name;
    
   }
   
   string$aaa="";
   string $qq[]=`ls -sl -fl`;
    for ($ll=0;$ll<size($qq);$ll++)
        {
         string$temp=$qq[$ll];
         $aaa+=$temp+" " ;
         }
   return $aaa;
}

/////////////////////////////////自动创建拉链嘴巴/////////////////////////////////////////////
global proc zxb_zuibalalian_all_proc() 
{
    string$Controller=`textFieldGrp -q -tx UI_head_controller `;//头部控制器
    string$lalian_modess=` getAttr ($Controller+".base_bs_lalian ")`;
    string $lalian_modes[]= stringToStringArray($lalian_modess, " ");//反向嘴巴模型
    string$qvxian_insidess=`textFieldGrp -q -tx  UI_mouth_inside_wire`;//
    string $qvxian_inside[]= stringToStringArray($qvxian_insidess, " ");//反向嘴巴模型
    
   string$repeated=$lalian_modes[1];
   textFieldGrp -e -tx  $lalian_modes[1] zxb_zairumode ;//载入反向模型
   button -e -en 0 lalian_button_fanxiang;
   
   
   select -r $qvxian_inside;
   string$open_qvxian_s=zxb_xuanzebutongmoxing_jiluxuanzhededian(0 , $lalian_modes[0]);
   textFieldGrp -e -tx  $open_qvxian_s UI_mouth_temp_wire ;//曲线
   button -e -en 0  lalian_button_zairuxian;
   
   string$aaaa=`zxb_zuiba_tiqv_lalian_open_proc`;
   string$bbbb=`zxb_zuiba_tiqv_lalian_close_proc`;
   string$cccc=`zxb_zuiba_tiqv_lalian_follow_proc`;
   
    string$temp_op=`textFieldGrp -q -tx  UI_mouth_zipper_wire_open_A`;
    string$temp_close=`textFieldGrp -q -tx  UI_mouth_zipper_wire_close_B`;
    string$temp_op_close=$temp_op+$temp_close;
    textFieldGrp -e -tx  $temp_op_close UI_mouth_zipper_wire_close_open ;//曲线
    button -e -en 0  UI_mouth_zipper_wire_close_open_button;
    //button -e -en 0 zidong_button;
    
    
    zxb_dingweiqi_kongzhiqvxian;
    zxb_dingweiqi_gensuiqvxian;
    zxb_global_bolangzui;
    
    button -e -en 0 UI_mouth_zipper_follow_DD_button;
    button -e -en 0 UI_mouth_zipper_open_AABB_button;
    button -e -en 0  UI_mouth_zipper_Create_button;
    string$temp_qvxians=$aaaa+$bbbb+$cccc;
    string $all_qvxians[]= stringToStringArray($temp_qvxians, " ");//反向嘴巴模型
    string$Face_zipper_Group="Face_zipper_Group";
    zxb_ADD_kongzu_proc($Face_zipper_Group);
    parent $Face_zipper_Group "Face_Group";
    for ($i=0;$i<size($all_qvxians);$i++)
        { 
        string$qvxian=$all_qvxians[$i];
        parent $qvxian $Face_zipper_Group;
        }
   
}







///////////////////////////提取上下曲线方法////////////////////////////////////////////////////
global proc string zxb_zuiba_tiqvqvxianfangfa_proc(int$a,string$mingzi,string$qianzui,string$xian_A)
{
//int$a=1;
//string$mingzi="open";
//string$xian_Ass[]= stringToStringArray($xian_A, " ");//字符串转化数组
string$xian=$xian_A;
//string$modess=`textFieldGrp -q -tx  zxb_zairumode`;
//string$Aqvxianss=`textFieldGrp -q -tx zxb_qvxianmingzi `;
 // string$Aqvxians[];
 // clear $Aqvxians;
 // int $nemt=`tokenize $Aqvxianss" " $Aqvxians`;//分离字符串存到变量
  string$Axianxian=$qianzui;


string$qvxianss[]= stringToStringArray($xian, " ");//字符串转化数组
string $bianliang[]=$qvxianss;//提取曲线名字


string$temp_qvxian[];
clear $temp_qvxian;
int $nemt=`tokenize $bianliang[0]"."  $temp_qvxian`;//分离字符串存到变量
string$moxing=$temp_qvxian[0];

select -r $bianliang;
ConvertSelectionToVertices;
string $dingdian[]=`ls -sl -fl`;


      string$R_cv="";
      string$L_cv="";
     string$vtxs[]=$dingdian;
     float$dd=-100000000000000;
     float$xx=1000000000000000;
     string$dian_L="";
     string$dian_R="";
     for ($i=0;$i<size($vtxs);$i++)
          {
           string$vtx=$vtxs[$i];
           float$bn_pos[]=`xform -q -ws -t $vtx`;
           if($bn_pos[0]>$dd)
             {
             $dd=$bn_pos[0];
             $dian_L=$vtx;
             }
             if($bn_pos[0]<$xx)
             {
             $xx=$bn_pos[0];
             $dian_R=$vtx;
             }
             
           }
           
            $L_cv=$dian_L;   
     $R_cv=$dian_R;
 float $R_POS[]=`xform -q -ws -t $R_cv`; 
 string$qvxian_mingzi=$Axianxian+"_temp_curve";
  select -r $qvxianss;
  polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $qvxian_mingzi;
 DeleteHistory;
 float$pamte=zxb_return_curve_U($R_POS[0],$R_POS[1],$R_POS[2],$qvxian_mingzi);
 select -r ($qvxian_mingzi+".u["+$pamte+"]") ;
float $tempp_POS[]=`xform -q -ws -t $dingdian[0]`; 
int$jisuan=size($dingdian)-1;
float $tempp_POS_A[]=`xform -q -ws -t $dingdian[$jisuan]`; 
float $R_POaS=$R_POS[0]+$R_POS[1]+$R_POS[2];
float $R_PObS=$tempp_POS[0]+$tempp_POS[1]+$tempp_POS[2];
if($R_POaS!=$R_PObS)
  {
    moveNurbsCurveSeam;
   }
 select -r ($qvxian_mingzi+".cv[0:999999999]");
 
 string $qvxian_A[]=`ls -sl -fl`;
 
 
string$dianLL="";
 //string$temp_cv=$dingdian[$i];
float $cv_pos[]=`xform -q -ws -t $L_cv`;
float$maga=1000000000000;
     
for($iii=0;$iii<size($qvxian_A);$iii++)
   { 
     string$mag_cv=$qvxian_A[$iii];
     float $mag_po[]=`xform -q -ws -t $mag_cv`;
     float $weizhi=mag(<<$cv_pos[0],$cv_pos[1],$cv_pos[2]>>-<< $mag_po[0] ,$mag_po[1] ,$mag_po[2]>>);////////计算距离
     if($weizhi<$maga){$maga=$weizhi;$dianLL=$mag_cv;}
     } 
    
//print $dianLL;
  string$ccv[];
  clear $ccv;
  int $nemt=`tokenize $dianLL"[" $ccv`;//分离字符串存到变量
   int $nemt=`tokenize $ccv[1]"]" $ccv`;//分离字符串存到变量
  string$shu=$ccv[0];
 
 
 int$qvxiancv_size=size($qvxian_A);
int$temp_a=$shu;

float$exa=0;
float$exb=0;


if($a==0)
{
select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
$exb=`zxb_qvfengshangzi`;

select -r ($qvxian_mingzi+".cv[0:999999999]");
select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
$exa=`zxb_qvfengshangzi`;
}
if($a==1)
 {
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $exa=zxb_normal_pingjunshu($moxing);
  
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $exb=`zxb_normal_pingjunshu($moxing)`;
  }


string$up_qvxiancvs[];
clear$up_qvxiancvs;
string$dw_qvxiancvs[];
clear$dw_qvxiancvs;



if($exb>$exa)
  {
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
 $dw_qvxiancvs =`ls -sl -fl`;
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $up_qvxiancvs =`ls -sl -fl`;
  }
if($exa>$exb)
  {
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $up_qvxiancvs =`ls -sl -fl`;
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $dw_qvxiancvs=`ls -sl -fl`;
   }

   
 //select -r $dingdian ;
//string $xiangliang[]=`ls -sl -fl`;
string$UP_zuijing="";
string$DW_zuijing="";


for($o=0;$o<2;$o++)
{
    string$temp_suzu[];
    clear$temp_suzu;
   if($o==0){$temp_suzu=$up_qvxiancvs;}
   if($o==1){$temp_suzu=$dw_qvxiancvs;}
   for($i=0;$i<size($temp_suzu);$i++)
    {
     string$temp_cv=$temp_suzu[$i];
     float $cv_pos[]=`xform -q -ws -t $temp_cv`;
     float$mag=1000000000000;
     string$dian="";
     for($ii=0;$ii<size($dingdian);$ii++)
        { 
         string$mag_cv=$dingdian[$ii];
         float $mag_po[]=`xform -q -ws -t $mag_cv`;
         float $weizhi=mag(<<$cv_pos[0],$cv_pos[1],$cv_pos[2]>>-<< $mag_po[0] ,$mag_po[1] ,$mag_po[2]>>);////////计算距离
         if($weizhi<$mag){$mag=$weizhi;$dian=$mag_cv+" ";}
         } 
     if($o==0){$UP_zuijing+=$dian;}
     if($o==1){$DW_zuijing+=$dian;}  
     }
    
 }   
       string$up_zuijingdw[]= stringToStringArray($UP_zuijing, " ");//字符串转化数组
       string$dw_zuijingdw[]= stringToStringArray($DW_zuijing, " ");//字符串转化数组 
       
string$head_qvxian=$Axianxian+"_"+$mingzi+"_UP";//open  

//select -r $up_zuijingdw;
//select -r $dw_zuijingdw; 
select -r $up_zuijingdw;
select -add $R_cv;
select -add $L_cv;
ConvertSelectionToContainedEdges;
polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $head_qvxian;

string$head_qvxian_b=$Axianxian+"_"+$mingzi+"_DW";//open
select -r $dw_zuijingdw;
select -add $R_cv;
select -add $L_cv;
ConvertSelectionToContainedEdges;
polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $head_qvxian_b;


string$temp_mingzi="";
$temp_mingzi+=$head_qvxian+" "+$head_qvxian_b+" ";
delete $qvxian_mingzi;



string$dian_LRA=$head_qvxian+".cv[0]";
float $pos_A[]=`xform -q -ws -t$dian_LRA`;
string$dian_LRB=$head_qvxian_b+".cv[0]";
float $pos_B[]=`xform -q -ws -t $dian_LRB`;

if($pos_A[0]!=$pos_B[0]){reverseCurve -ch 1 -rpo 1 $head_qvxian;}


 return $temp_mingzi;
}



//////////////定位器控制器曲线/////////////////////

global proc  zxb_dingweiqi_kongzhiqvxian()
{
//string $bianliang[]=`ls -sl`;//选中曲线D  没有历史记录的曲线
 string $bianliang_sss=`textFieldGrp -q -tx  UI_mouth_zipper_wire_follow_D`;
string $bianliang[]= stringToStringArray($bianliang_sss, " ");//字符串转化数组
string $qianzui=`textFieldGrp -q -tx UI_mouth_zipper_prefix `;


string$curve_temp="zxb_"+$qianzui+"_curve_follow__grp";

zxb_ADD_kongzu_proc($curve_temp);
parent $curve_temp "Face_Group";
for($i=0;$i<size($bianliang);$i++) 
{
    string $qvxian_A=$bianliang[$i];
    select -r ($qvxian_A+".cv[0:999999999999]");
    string  $cvs[]=`ls -sl -fl`;
    
    int $panduan=`objExists ($qvxian_A+"_locGrp")`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete ($qvxian_A+"_locGrp");
        }
     select -cl  ;
     group -empty -n ($qvxian_A+"_locGrp");
     setAttr ($qvxian_A+"_locGrp.visibility") 0;
     setAttr -lock true ($qvxian_A+"_locGrp"+".v");
     
     parent($qvxian_A+"_locGrp") $curve_temp ;
     int $panduanA=`objExists ($qvxian_A+"_gengsui_"+"nearestPointOnCurve")`;//查询这个物体是否纯在
     if($panduanA==1){ delete ($qvxian_A+"_gengsui_"+"nearestPointOnCurve");}
     createNode nearestPointOnCurve -n  ($qvxian_A+"_gengsui_"+"nearestPointOnCurve");//创建曲线最近点节点
     string $qvxian_shp[]=`listRelatives -s $qvxian_A`;
     connectAttr -force ($qvxian_shp[0]+".worldSpace[0]")  ($qvxian_A+"_gengsui_"+"nearestPointOnCurve.inputCurve");
       
    for($j=0;$j<size($cvs);$j++) 
    {
        string  $cvdian_bianliang=$cvs[$j];
       spaceLocator -p 0 0 0 -n($qvxian_A+"_loc_A_"+$j);
       spaceLocator -p 0 0 0 -n($qvxian_A+"_loc_B_"+$j);
       parent ($qvxian_A+"_loc_B_"+$j)  ($qvxian_A+"_loc_A_"+$j);
       
       select -r ($qvxian_A+"_loc_B_"+$j);
       group -n  ($qvxian_A+"_locgrp_"+$j);
       group -n  ($qvxian_A+"_locgrp_A"+$j);
       group -n  ($qvxian_A+"_locgrp_B"+$j);
       //parent  ($qvxian_A+"_locgrp_B"+$j) ($qvxian_A+"_loc_A_"+$j);
       parent  ($qvxian_A+"_loc_A_"+$j) ($qvxian_A+"_locGrp");
       float $poslist[]= `xform -q -ws -t  $cvdian_bianliang`;
       setAttr -type float3 ($qvxian_A+"_gengsui_"+"nearestPointOnCurve"+".inPosition") $poslist[0] $poslist[1] $poslist[2];
       float $poslist_A[]=`getAttr ($qvxian_A+"_gengsui_"+"nearestPointOnCurve"+".position")`;
      xform -ws -t    $poslist_A[0] $poslist_A[1] $poslist_A[2] ($qvxian_A+"_loc_A_"+$j);//定位器1的位置
       xform -ws -t  $poslist[0] $poslist[1] $poslist[2]($qvxian_A+"_loc_B_"+$j) ;//定位器1的位置
       string $loc_shp[]=`listRelatives -s ($qvxian_A+"_loc_B_"+$j)`;
       connectAttr -f ($loc_shp[0]+".worldPosition[0]") ($qvxian_shp[0]+".controlPoints["+$j+"]");
     }
     
     delete  ($qvxian_A+"_gengsui_"+"nearestPointOnCurve");
}

 button -e -en 0 UI_mouth_zipper_follow_DD_button;//
}

////////////////////////////曲线控制器定位器//////////////////////////////////////////

global proc  zxb_dingweiqi_gensuiqvxian()
{
//string $bianliang[]=`ls -sl`;//选中另外4条曲线
string $bianliang_sss=`textFieldGrp -q -tx  UI_mouth_zipper_wire_close_open`;
string $bianliang[]= stringToStringArray($bianliang_sss, " ");//字符串转化数组
string $qianzui=`textFieldGrp -q -tx UI_mouth_zipper_prefix `;

string$qvxianzu="zxb_"+$qianzui+"_curve_open_close_grp";

zxb_ADD_kongzu_proc($qvxianzu);
parent $qvxianzu "Face_Group";
 int $panduan_A=`objExists ("temp_qvxian_nearestPointOnCurve")`;//查询这个物体是否纯在
 if($panduan_A==1){delete ("temp_qvxian_nearestPointOnCurve"); }
createNode nearestPointOnCurve -n  ("temp_qvxian_nearestPointOnCurve");//创建曲线最近点节点

for($i=0;$i<size($bianliang);$i++) 
{
    string $qvxian=$bianliang[$i]; 
     string $qvxian_shp[]=`listRelatives -s $qvxian`;
     connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ("temp_qvxian_nearestPointOnCurve.inputCurve") ;
    
 
    
     int $panduan=`objExists ($qvxian+"_B_Grp")`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete ($qvxian+"_B_Grp");
        }
    
     select -cl  ;
     group -empty -n ($qvxian+"_B_Grp");
     setAttr ($qvxian+"_B_Grp.visibility") 0;
     setAttr -lock true ($qvxian+"_B_Grp"+".v");
     parent ($qvxian+"_B_Grp") $qvxianzu; 
     
    int $panduan=`objExists ($qvxian+"_A_Grp")`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete ($qvxian+"_A_Grp");
        }
     select -cl  ;
     group -empty -n ($qvxian+"_A_Grp");
     setAttr ($qvxian+"_A_Grp.visibility") 0;
     setAttr -lock true ($qvxian+"_A_Grp"+".v");
    parent ($qvxian+"_A_Grp") $qvxianzu; 
   select -r ($qvxian+".cv[0:99999999999]");
    string $cvs[]=`ls -sl -fl`;
    
  global string $gSelect;
global string $gMainProgressBar;
setToolTo $gSelect;
progressBar -e -st ("创建定位器...") -bp -ii 1 -min 0 -max `size($cvs)` $gMainProgressBar;
    for($j=0;$j<size($cvs);$j++) 
    {
         if(`progressBar -q -ic $gMainProgressBar`)
         break;
         progressBar -e -s 1 $gMainProgressBar;
         string $cv_dian=$cvs[$j];
        spaceLocator -p 0 0 0 -n ($qvxian+"_loc_A_"+$j);
        spaceLocator -p 0 0 0 -n ($qvxian+"_loc_B_"+$j);
        parent ($qvxian+"_loc_B_"+$j) ($qvxian+"_B_Grp");
        parent ($qvxian+"_loc_A_"+$j)  ($qvxian+"_A_Grp");
        float $pos_a[]=`xform -q -ws -t $cvs[$j]`;
        setAttr  -type float3 ("temp_qvxian_nearestPointOnCurve.inPosition")  $pos_a[0] $pos_a[1] $pos_a[2];
         addAttr -ln ("canshu")  -at double   -dv 0 -k  1 ($qvxian+"_loc_A_"+$j);//添加属性
        float $canshu=`getAttr "temp_qvxian_nearestPointOnCurve.parameter"`;
        setAttr  ($qvxian+"_loc_A_"+$j+".canshu") $canshu;
        setAttr -lock true ($qvxian+"_loc_A_"+$j+".canshu");
        
         int $panduan_A=`objExists ($qvxian+"_pointOnCurveInfo_loc_"+$j)`;//查询这个物体是否纯在
         if($panduan_A==1){delete ($qvxian+"_pointOnCurveInfo_loc_"+$j); }
        createNode "pointOnCurveInfo" -n ($qvxian+"_pointOnCurveInfo_loc_"+$j);//创建曲线信息节点
        connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ($qvxian+"_pointOnCurveInfo_loc_"+$j+".inputCurve");
        connectAttr -force ($qvxian+"_loc_A_"+$j+".canshu") ($qvxian+"_pointOnCurveInfo_loc_"+$j+".parameter");
        connectAttr -force ($qvxian+"_pointOnCurveInfo_loc_"+$j+".position") ($qvxian+"_loc_A_"+$j+".t");
        
        float $pos_c[]=`getAttr ($qvxian+"_pointOnCurveInfo_loc_"+$j+".position")`;
         setAttr -type float3 ($qvxian+"_loc_B_"+$j+".t") $pos_c[0] $pos_c[1] $pos_c[2];
     }
     progressBar -e -ep $gMainProgressBar;
    
}
delete ("temp_qvxian_nearestPointOnCurve");


button -e -en 0 UI_mouth_zipper_open_AABB_button;
}






///////////////////////创建拉链效果/////////////////////////
global proc zxb_global_bolangzui(){

//string $bianliang[]=`ls -sl`;//选中默认曲线

string $openA_sss=`textFieldGrp -q -tx  UI_mouth_zipper_wire_open_A`;
string $openAs[]= stringToStringArray($openA_sss, " ");//字符串转化数组

string $close_sss=`textFieldGrp -q -tx  UI_mouth_zipper_wire_close_B`;
string $close_Bs[]= stringToStringArray($close_sss, " ");//字符串转化数组

 string $follow_sss=`textFieldGrp -q -tx  UI_mouth_zipper_wire_follow_D`;
string$follow_Ds[]= stringToStringArray($follow_sss, " ");//字符串转化数组

 string $qianzui_sss=`textFieldGrp -q -tx  UI_mouth_zipper_prefix`;
 string$qianzui_a[];
  clear $qianzui_a;
  int $nemt=`tokenize $qianzui_sss" " $qianzui_a`;//分离字符串存到变量
  string$qianzui=$qianzui_a[0];

string $bianliang[]=$close_Bs;
 int $fanxiang_a=`checkBox -q  -value fanxuan`;
 int $panduan_a=`objExists ($bianliang[0]+"_curveInfo")`;
 if($panduan_a==1){delete ($bianliang[0]+"_curveInfo");}
shadingNode -asUtility curveInfo -n ($bianliang[0]+"_curveInfo");

string $qvxian_shp[]=`listRelatives -c ($bianliang[0])`;
connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ($bianliang[0]+"_curveInfo.inputCurve");

 int $panduan=`objExists ($bianliang[0]+".changdu")`;
if($panduan==0){addAttr -ln "changdu"  -at double  -dv 0 -k 1($bianliang[0]);}
setAttr -lock 0  ($bianliang[0]+".changdu");
connectAttr -force  ($bianliang[0]+"_curveInfo.arcLength") ($bianliang[0]+".changdu");
setAttr -lock 1  ($bianliang[0]+".changdu");


select -r  ($bianliang[0]+".cv[0:9999999999]") ;
string $qvxian_dian[]=`ls -sl -fl`;
int $qvxian_size=size($qvxian_dian);
float $pos_A[]=`xform -q -ws -t ($bianliang[0]+".cv[0]")`;
float $pos_B[]=`xform -q -ws -t ($bianliang[0]+".cv["+($qvxian_size-1)+"]")`;
float $pos_l_panduan[]=$pos_A;
float $pos_r_panduan[]=$pos_B;
if ( $pos_r_panduan[0]>$pos_l_panduan[0])
{
     $pos_l_panduan=$pos_B;
     $pos_r_panduan=$pos_A;
}

string$zuiba_loc_L=($bianliang[0]+"LL_ZUIBA_LOC");
string$zuiba_loc_R=($bianliang[0]+"RR_ZUIBA_LOC");
spaceLocator -p 0 0 0 -n $zuiba_loc_L;
spaceLocator -p 0 0 0 -n $zuiba_loc_R;
xform  -ws -t  $pos_l_panduan[0]  $pos_l_panduan[1]  $pos_l_panduan[2] $zuiba_loc_L;
xform  -ws -t  $pos_r_panduan[0]  $pos_r_panduan[1]  $pos_r_panduan[2] $zuiba_loc_R;


 int $panduan_b=`objExists ($zuiba_loc_L+".shuaijian")`;
 float $changdu=`getAttr ($bianliang[0]+".changdu")`;
 float $changduzhi= $changdu/5.0;
if($panduan_b==0)
{
addAttr -ln "shuaijian"  -at double  -dv $changduzhi -k 1 ($zuiba_loc_L);
setAttr -keyable false -channelBox true ($zuiba_loc_L+".shuaijian");
}

move -r  ($changduzhi*1.25) 0 0 ($zuiba_loc_L) ;
move -r  ($changduzhi*-1.25) 0 0 ($zuiba_loc_R) ;
//print `size($qvxian_dian)`;
for($j=0;$j<size($bianliang);$j++)
{
 

for($i=0;$i<size($qvxian_dian);$i++)
 {
     
     string $qvxian_B=$close_Bs[$j];
     string$qvxian_A= $openAs[$j];
     string$qvxian_D=$follow_Ds[$j];
     
     string$qvxian_loc=($qvxian_B+"_loc_A_"+$i);
     string$qvxian_locA=($qvxian_A+"_loc_A_"+$i);
     string$qvxian_locD=($qvxian_D+"_loc_A_"+$i);
    
         select -r $qvxian_loc ;
         select -add $qvxian_locA ;
         select -add $qvxian_locD;
     string $dianyuesu_bianliang[]=`pointConstraint`;
     
     
      int $panduan_C=`objExists ($qvxian_B+"_plusMinusAverage_L_"+$i)`;
      if($panduan_C==1){delete ($qvxian_B+"_plusMinusAverage_L_"+$i); }
     shadingNode -asUtility plusMinusAverage -n ($qvxian_B+"_plusMinusAverage_L_"+$i);//创建加减节点
     connectAttr -force  ($zuiba_loc_L+".tx") ($qvxian_B+"_plusMinusAverage_L_"+$i+".input1D[0]");
     connectAttr -force  ($qvxian_locA+".tx") ($qvxian_B+"_plusMinusAverage_L_"+$i+".input1D[1]");
     setAttr ($qvxian_B+"_plusMinusAverage_L_"+$i+".operation") 2;
      
      int $panduan_F=`objExists ($qvxian_B+"setRange_A_"+$i)`;
      if($panduan_F==1){delete ($qvxian_B+"setRange_A_"+$i); }
     shadingNode -asUtility  setRange -n ($qvxian_B+"setRange_A_"+$i);//创建范围节点
     setAttr ($qvxian_B+"setRange_A_"+$i+".maxX") 1;
     connectAttr -f ($zuiba_loc_L+".shuaijian")($qvxian_B+"setRange_A_"+$i+".oldMaxX");
     connectAttr -f ($qvxian_B+"_plusMinusAverage_L_"+$i+".output1D") ($qvxian_B+"setRange_A_"+$i+".valueX");
     
      
     int $panduan_D=`objExists ($qvxian_B+"_plusMinusAverage_R_"+$i)`;
     if($panduan_D==1){delete ($qvxian_B+"_plusMinusAverage_R_"+$i); }
     shadingNode -asUtility plusMinusAverage -n ($qvxian_B+"_plusMinusAverage_R_"+$i);//创建加减节点
     connectAttr -force  ($zuiba_loc_R+".tx") ($qvxian_B+"_plusMinusAverage_R_"+$i+".input1D[1]");//中间减→→右边 右边数值是负数
     connectAttr -force  ($qvxian_locA+".tx") ($qvxian_B+"_plusMinusAverage_R_"+$i+".input1D[0]");
     setAttr ($qvxian_B+"_plusMinusAverage_R_"+$i+".operation") 2;
     
      int $panduan_F=`objExists ($qvxian_B+"setRange_B_"+$i)`;
      if($panduan_F==1){delete ($qvxian_B+"setRange_B_"+$i); }
     shadingNode -asUtility  setRange -n ($qvxian_B+"setRange_B_"+$i);//创建范围节点
     setAttr ($qvxian_B+"setRange_B_"+$i+".maxX") 1;
     connectAttr -f ($zuiba_loc_L+".shuaijian")($qvxian_B+"setRange_B_"+$i+".oldMaxX");
     connectAttr -f ($qvxian_B+"_plusMinusAverage_R_"+$i+".output1D") ($qvxian_B+"setRange_B_"+$i+".valueX");
     
     
     int $panduan_E=`objExists ($qvxian_B+"_plusMinusAverage_M_"+$i)`;
     if( $panduan_E==1){delete ($qvxian_B+"_plusMinusAverage_M_"+$i);}
     shadingNode -asUtility plusMinusAverage -n ($qvxian_B+"_plusMinusAverage_M_"+$i);//创建加减节点
     setAttr ($qvxian_B+"_plusMinusAverage_M_"+$i+".operation") 2;
     setAttr ($qvxian_B+"_plusMinusAverage_M_"+$i+".input1D[0]") 2;
     connectAttr -f ($qvxian_B+"setRange_A_"+$i+".outValueX")  ($qvxian_B+"_plusMinusAverage_M_"+$i+".input1D[1]");
     connectAttr -f ($qvxian_B+"setRange_B_"+$i+".outValueX")  ($qvxian_B+"_plusMinusAverage_M_"+$i+".input1D[2]");



     int $panduan_E=`objExists ($qvxian_B+"setRange_M_"+$i)`;
     if( $panduan_E==1){delete ($qvxian_B+"setRange_M_"+$i);}
     shadingNode -asUtility  setRange -n ($qvxian_B+"setRange_M_"+$i);//创建范围节点
     setAttr ($qvxian_B+"setRange_M_"+$i+".maxX") 1;
     setAttr ($qvxian_B+"setRange_M_"+$i+".oldMaxX") 1;
     connectAttr -f ($qvxian_B+"_plusMinusAverage_M_"+$i+".output1D") ($qvxian_B+"setRange_M_"+$i+".valueX");
     
     
      int $panduan_E=`objExists ($qvxian_B+"reverse_M_"+$i)`;
     if( $panduan_E==1){delete ($qvxian_B+"reverse_M_"+$i);}
     shadingNode -asUtility reverse -n($qvxian_B+"reverse_M_"+$i); //创建反向节点
     connectAttr -f ($qvxian_B+"setRange_M_"+$i+".outValueX") ($qvxian_B+"reverse_M_"+$i+".inputX");
     if($fanxiang_a==1)
        {
         connectAttr -f  ($qvxian_B+"setRange_M_"+$i+".outValueX") ($dianyuesu_bianliang[0]+"."+$qvxian_loc+"W0")  ;
          connectAttr -f  ($qvxian_B+"reverse_M_"+$i+".outputX") ($dianyuesu_bianliang[0]+"."+$qvxian_locA+"W1") ;
         }
        else{
          connectAttr -f  ($qvxian_B+"reverse_M_"+$i+".outputX") ($dianyuesu_bianliang[0]+"."+$qvxian_loc+"W0")  ;
          connectAttr -f   ($qvxian_B+"setRange_M_"+$i+".outValueX")($dianyuesu_bianliang[0]+"."+$qvxian_locA+"W1") ;
           }
        
 }
 
}
 
 
  button -e -en 0  UI_mouth_zipper_Create_button;
}
 
///////////////////////////生成包裹

global proc zxb_lalianbaoguo_poc()
 {
  string $lalian_modces=`textFieldGrp -q -tx  zxb_zairumodeA`;
  string $qvxianDs=`textFieldGrp -q -tx Dqvxian  `;
  string $zhangzuiqvxians=`textFieldGrp -q -tx zhangzuiqvxian  `;
  
  string$qvxianDss[]=stringToStringArray($qvxianDs, " ");
   string$zhangzuiqvxianss[]=stringToStringArray($zhangzuiqvxians, " ");
  string$mod[];
  clear $mod;
  int $nemt=`tokenize  $lalian_modces " " $mod`;//分离字符串存到变量
  string$lalian_modce=$mod[0];
  
for ($i=0;$i<size($qvxianDss);$i++)
    {
    string$qvxian=$qvxianDss[$i];
    string$qvxian_A=$zhangzuiqvxianss[$i];
    string$baoguoa[]=`wire -gw false -en 1.000000 -ce 0.000000 -li 0.000000 -w $qvxian $lalian_modce`;
    setAttr ($baoguoa[0]+".rotation") 0.2;
    setAttr ($baoguoa[0]+".dropoffDistance[0]") 10;
    select -r  $qvxian_A;
    select -add  $qvxian_A ($qvxian+"BaseWire");
    string$bs[]=`blendShape`;
    
    setAttr ($bs[0]+"."+$qvxian_A) 1;
    
    }


}





////////////////////////骨骼跟随曲线


global proc xiao_gugegengsuiqvxian_proc_columnLayout() 
{
if(`window -ex zxb_chibangWin_columnLayout`) deleteUI zxb_chibangWin_columnLayout; 

window -t "翅膀" zxb_chibangWin_columnLayout; 
columnLayout -adj 1 -w 300 gtBSColumlayout;

 
 text -l " 关节跟随曲线 " -h 25;
 text -l "  " -h 25;
 rowColumnLayout -nc 2 -cw 1 440 -cw 2 340  ;

textFieldGrp  -cw2 100 300 -l "曲线" -tx "曲线" -ed 0  qvxian;
button -l "载入" -c ("zxb_zairufangfa_A_proc(\""+"qvxian"+"\")") ;


setParent ..; 

text -l "  " -h 25;
button -l "创建" -c "zxb_gugegengsuiqvxian_a_proc" ;
showWindow zxb_chibangWin_columnLayout; 
}
 


global proc zxb_gugegengsuiqvxian_a_proc()
{
      string $qvxianss=`textFieldGrp -q -tx  qvxian `;
      string$qvxian_s[]= stringToStringArray($qvxianss, " ");//关节
      
     string $bianliang[]=$qvxian_s;//

 int $panduan_A=`objExists ("temp_qvxian_nearestPointOnCurve")`;//查询这个物体是否纯在
 if($panduan_A==1){delete ("temp_qvxian_nearestPointOnCurve"); }
createNode nearestPointOnCurve -n  ("temp_qvxian_nearestPointOnCurve");//创建曲线最近点节点

for($i=0;$i<size($bianliang);$i++) 
{
    string $qvxian=$bianliang[$i]; 
     string $qvxian_shp[]=`listRelatives -s $qvxian`;
     connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ("temp_qvxian_nearestPointOnCurve.inputCurve") ;
    
     string$qvxian_grp=($qvxian+"_bn_Grp");
    
     int $panduan=`objExists $qvxian_grp`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete $qvxian_grp;
        }
     select -cl  ;
     group -empty -n $qvxian_grp;
     setAttr ($qvxian_grp+".visibility") 0;
    // setAttr -lock true ($qvxian_grp+".v");
     
  

   select -r ($qvxian+".cv[0:99999999999]");
    string $cvs[]=`ls -sl -fl`;
    
  global string $gSelect;
global string $gMainProgressBar;
setToolTo $gSelect;
progressBar -e -st ("创建骨骼...") -bp -ii 1 -min 0 -max `size($cvs)` $gMainProgressBar;
    for($j=0;$j<size($cvs);$j++) 
    {
         if(`progressBar -q -ic $gMainProgressBar`)
         break;
         progressBar -e -s 1 $gMainProgressBar;
         string $cv_dian=$cvs[$j];
         string$bn=($qvxian+"_bn_"+$j);
         select -cl  ;
         joint -p 0 0 0 -n $bn;
       
        parent $bn  $qvxian_grp;
        float $pos_a[]=`xform -q -ws -t $cvs[$j]`;
        setAttr  -type float3 ("temp_qvxian_nearestPointOnCurve.inPosition")  $pos_a[0] $pos_a[1] $pos_a[2];
         addAttr -ln ("canshu")  -at double   -dv 0 -k  1 $bn;//添加属性
        float $canshu=`getAttr "temp_qvxian_nearestPointOnCurve.parameter"`;
        setAttr  ($bn+".canshu") $canshu;
        setAttr -lock true ($bn+".canshu");
        
         int $panduan_A=`objExists ($qvxian+"_pointOnCurveInfo_loc_"+$j)`;//查询这个物体是否纯在
         if($panduan_A==1){delete ($qvxian+"_pointOnCurveInfo_loc_"+$j); }
        createNode "pointOnCurveInfo" -n ($qvxian+"_pointOnCurveInfo_loc_"+$j);//创建曲线信息节点
        connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ($qvxian+"_pointOnCurveInfo_loc_"+$j+".inputCurve");
        connectAttr -force ($bn+".canshu") ($qvxian+"_pointOnCurveInfo_loc_"+$j+".parameter");
        connectAttr -force ($qvxian+"_pointOnCurveInfo_loc_"+$j+".position") ($bn+".t");
        
        float $pos_c[]=`getAttr ($qvxian+"_pointOnCurveInfo_loc_"+$j+".position")`;
        // setAttr -type float3 ($qvxian+"_loc_B_"+$j+".t") $pos_c[0] $pos_c[1] $pos_c[2];
     }
     progressBar -e -ep $gMainProgressBar;
    
}
delete ("temp_qvxian_nearestPointOnCurve");
      
      

}







global proc string zxb_zuiba_tiqv_lalian_open_proc()
{
    
    string$xian_AA=`textFieldGrp -q -tx  UI_mouth_temp_wire`;
    string $open_s_qvxian[]= stringToStringArray($xian_AA, " ");//提取的曲线名字
    string$Aqvxianss=`textFieldGrp -q -tx UI_mouth_zipper_prefix `;
    string$Aqvxians[];
    clear $Aqvxians;
    int $nemt=`tokenize $Aqvxianss" " $Aqvxians`;//分离字符串存到变量
    string$qianzui=$Aqvxians[0];
    
    string $qvxianA=zxb_zuiba_tiqvqvxianfangfa_proc(1,"open",$qianzui,$xian_AA);
    
    textFieldGrp -e -tx $qvxianA UI_mouth_zipper_wire_open_A ;
    button -e -en 0 UI_mouth_zipper_wire_open_A_button ;
    button -e -en 0 lalian_button_qvxianA ;
    return $qvxianA;
}
global proc string zxb_zuiba_tiqv_lalian_close_proc()
{
    string$Aqvxianss=`textFieldGrp -q -tx UI_mouth_zipper_prefix `;//曲线前缀
    string$Aqvxians[];
    clear $Aqvxians;
    int $nemt=`tokenize $Aqvxianss" " $Aqvxians`;
    string$qianzui=$Aqvxians[0];
    
    string$xian_AA=`textFieldGrp -q -tx  UI_mouth_temp_wire`;
    string $open_s_qvxian[]= stringToStringArray($xian_AA, " ");//提取的曲线名字
    string$close_s_mode=`textFieldGrp -q -tx  zxb_zairumode`;//反向嘴巴模型
    select -r $open_s_qvxian;
    string$close_s_qvxian=zxb_xuanzebutongmoxing_jiluxuanzhededian(0 ,$close_s_mode);
    string $close_B=zxb_zuiba_tiqvqvxianfangfa_proc(1,"close",$qianzui,$close_s_qvxian);
    textFieldGrp -e -tx $close_B UI_mouth_zipper_wire_close_B ;
    button -e -en 0 UI_mouth_zipper_wire_close_B_button;
    button -e -en 0 lalian_button_qvxian ;
    return $close_B;
}


global proc string zxb_zuiba_tiqv_lalian_follow_proc()

{  
    string$xian_AA=`textFieldGrp -q -tx  UI_mouth_temp_wire`;
    string $open_s_qvxian[]= stringToStringArray($xian_AA, " ");//提取的曲线名字
    string$Aqvxianss=`textFieldGrp -q -tx UI_mouth_zipper_prefix `;
    string$Aqvxians[];
    clear $Aqvxians;
    int $nemt=`tokenize $Aqvxianss" " $Aqvxians`;//分离字符串存到变量
    string$qianzui=$Aqvxians[0];
    
   
    string $follow_A=zxb_zuiba_tiqvqvxianfangfa_proc(1,"follow",$qianzui,$xian_AA);//生成张嘴嘴巴曲线
    string $follow_s[]= stringToStringArray($follow_A, " ");//提取的曲线名字
    select -r $follow_s;
    DeleteHistory;
    textFieldGrp -e -tx $follow_A UI_mouth_zipper_wire_follow_D ;
    button -e -en 0 UI_mouth_zipper_wire_follow_D_button ;
    button -e -en 0 lalian_button_qvxianD ;
    
    return $follow_A;
}




/////////////////设置拉链驱动/////////////////////
global proc zxb_zd_sheziqvdong_poc()
{
  string $qvxians=`textFieldGrp -q -tx  zxb_zairukongzhiqi`;
  string$qvxianss[];
  clear $qvxianss;
  int $nemt=`tokenize  $qvxians " " $qvxianss`;//分离字符串存到变量
  string$qvxian=$qvxianss[0];
  
  string $locss=`textFieldGrp -q -tx zxb_dingweiqi  `;

  string$locs[]=stringToStringArray($locss, " ");
  
  for ($i=0;$i<size($locs);$i++)
  {
   
   string$loc=$locs[$i];
   int$a=0;
   string$rrll="";
      
   if($i==0){$a=1;$rrll="L";}else{$a=0;$rrll="R";}
   string$loc_b=$locs[$a];
   
   int $ex=`objExists ($qvxian+".lalian_L")`;//查询这个物体是否纯在
   if($ex==0){addAttr -ln "lalian_L"  -at double  -min 0 -max 10 -dv 0 -k  1 $qvxian;}//添加属性  
   
    $ex=`objExists ($qvxian+".lalian_R")`;//查询这个物体是否纯在
    if($ex==0){addAttr -ln "lalian_R"  -at double  -min 0 -max 10 -dv 0 -k  1 $qvxian;}//添加属性  
    
    float$loc_pos=`getAttr ($loc+".tx")`;
    float$loc_b_pos=`getAttr ($loc_b+".tx")`;
   setDrivenKeyframe -itt "linear" -ott "spline" -v $loc_pos -dv 0 -cd ($qvxian+".lalian_"+$rrll) ($loc+".tx");  
   setDrivenKeyframe -itt "linear" -ott "spline" -v $loc_b_pos -dv 10 -cd ($qvxian+".lalian_"+$rrll) ($loc+".tx");  
  }
}

/////////////////////////////////设置嘴巴波浪///////////////////////////
global proc zxb_bolangzui()
{

string $bianliang[]=`ls -sl `;//选中曲线D  

for($i=0;$i<size($bianliang);$i++)
{
   string $qvxian_D=$bianliang[$i];
   select -r $qvxian_D;
  duplicate -rr -n ($qvxian_D+"_bolang");
    string $grpchids[]=`listRelatives -c ($qvxian_D+"_locGrp")`;
    
    int $panduan=`objExists ($qvxian_D+"_bolanggrp") `;
    if ($panduan==0)
    {
        select -cl  ;
        group -empty -n ($qvxian_D+"_bolanggrp");
        setAttr ($qvxian_D+"_bolanggrp.visibility") 0;
        setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolanggrp.v");
     
     }
     
     string$boliang=($bianliang[0]+"_bolang_all");
     
    int $panduan=`objExists $boliang `;
    if ($panduan==0)
    {
        select -cl  ;
        group -empty -n $boliang ;
       setAttr ($boliang+".visibility") 0;
       setAttr -lock true -keyable false -channelBox false ($boliang+".v");
     
     }
     
     parent ($qvxian_D+"_bolanggrp")  $boliang;
     
     /////////////////////////复制曲线D的定位器   属性控制拉链嘴的组//////////////////////////////
   string $objloc_d[];//定义定位器的所有物体  复制出来的定位器的名字
   clear $objloc_d;
   for($j=0;$j<size($grpchids);$j++)
   {
     string $qvxian_D_locA= $grpchids[$j];
     string $loc_chids[]=`listRelatives -c  -type "transform" $qvxian_D_locA`;
     string $obj="";

     for($ii=0;$ii<size($loc_chids);$ii++)
       {
       int $panduan=`objExists ($loc_chids[$ii]+".offsetZ")`;
       if ($panduan==0){$obj=$loc_chids[$ii];}
       }
     select -r $obj ;
     duplicate -rr -n ($obj+"_bolang");
     parent ($obj+"_bolang") ($qvxian_D+"_bolanggrp");
     string $zu_zi[]=`listRelatives -c -ad  -type  "transform" -fullPath ($obj+"_bolang")`;
     string $zu_zi_A[]=`listRelatives -c -ad  -type  "transform" ($obj+"_bolang")`;
     string $bolangloc="";

     for($iii=0;$iii<size($zu_zi);$iii++)////重命名
      {
          string $ziwuti=$zu_zi[$iii];
          //select -r $ziwuti;
          rename  $ziwuti ($zu_zi_A[$iii]+"_bolang");
          string$loc_shap[]=`listRelatives -s ($zu_zi_A[$iii]+"_bolang")`;
          if($loc_shap[0]==""&&$iii==0){ delete($zu_zi_A[$iii]+"_bolang");}
          if($loc_shap[0]!="")
            {
             string$tepe_B=`nodeType $loc_shap[0]`;
            if($tepe_B=="locator"){$bolangloc=($zu_zi_A[$iii]+"_bolang");}
             }

         
         
        
    
       }
      string $loc_zu[]=`listRelatives -c  -type  "transform"  $obj`;
      string $lalian_loczu=$loc_zu[0];

     connectAttr -f ($bolangloc+".t") ($lalian_loczu+".t");
     select -r $bolangloc;

     $objloc_d[$j] = $bolangloc;//把定位器的名称保存到变量里   复制出来的定位器的名字
   }
  // print $objloc_d;
  
  
  
  ///////////////////创建曲线///////////////////
   float $kaishi_pos_A[]=`xform -q -ws -t  ($qvxian_D+".cv[0]")`;
   float $kaishi_pos_B[]=`xform -q -ws -t  ($qvxian_D+".cv[+"+size($grpchids)+"]")`;
    int $panduan=`objExists ($qvxian_D+"_bolang")`;
    if($panduan==1){ delete ($qvxian_D+"_bolang");}
    
  curve -d 1 -p $kaishi_pos_A[0] $kaishi_pos_A[1] $kaishi_pos_A[2] -p $kaishi_pos_B[0] $kaishi_pos_B[1] $kaishi_pos_B[2] -n($qvxian_D+"_bolang"); //创建曲线
  setAttr ($qvxian_D+"_bolang.visibility") 0;
  setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolang.v");
  rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 ($qvxian_D+"_bolang");//重建曲线
  /////////////创建曲线信息节点///////////////////////////
     int $panduan=`objExists ($qvxian_D+"qvxianzuijingdianjiedian")`;
     if($panduan==1){ delete ($qvxian_D+"qvxianzuijingdianjiedian");}
   createNode nearestPointOnCurve -n ($qvxian_D+"qvxianzuijingdianjiedian");//创建曲线最近点节点
   string $qvxian_D_shp[]=`listRelatives -s $qvxian_D`;
   connectAttr -force ($qvxian_D_shp[0]+".worldSpace[0]")  ($qvxian_D+"qvxianzuijingdianjiedian"+".inputCurve");//曲线链接到曲线信息节点

    
    /////////////////判断是否翻转曲线起始点/////////////////
    
    float $dian_temp_kaishi[]=`xform -q -ws -t ($qvxian_D+"_bolang.cv[0]")`;
    float $dian_temp_jiesu[]=`xform -q -ws -t ($qvxian_D+"_bolang.cv[4]")`;
    float $dian_temp_kaishi_A[]=`xform -q -ws -t ($qvxian_D+".cv[0]")`;
    float$dis=mag(<<$dian_temp_kaishi[0],$dian_temp_kaishi[1],$dian_temp_kaishi[2]>>-<<$dian_temp_kaishi_A[0],$dian_temp_kaishi_A[1],$dian_temp_kaishi_A[2]>>);
    float$dis_a=mag(<<$dian_temp_jiesu[0],$dian_temp_jiesu[1],$dian_temp_jiesu[2]>>-<<$dian_temp_kaishi_A[0],$dian_temp_kaishi_A[1],$dian_temp_kaishi_A[2]>>);

    if($dis>$dis_a){reverseCurve -ch 0 -rpo 1 ($qvxian_D+"_bolang");}
    parent ($qvxian_D+"_bolang") $boliang;
    
    //////////////////创建蔟//////////////
    int $cv_size=5;
    for($a=0;$a<$cv_size;$a++)//创建蔟
     {
      select -r ($qvxian_D+"_bolang.cv["+$a+"]"); 
       
     CreateCluster ;
     rename ($qvxian_D+"_bolang_cu_"+$a);
     spaceLocator -p 0 0 0 -n ($qvxian_D+"_bolang_cu_loc_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_D_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_C_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_B_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_A_"+$a);
     setAttr ($qvxian_D+"_bolang_cu_grp_A_"+$a+".visibility") 0;
     setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolang_cu_grp_A_"+$a+".v");
     delete`pointConstraint  ($qvxian_D+"_bolang_cu_"+$a) ($qvxian_D+"_bolang_cu_grp_A_"+$a)`;
     parent ($qvxian_D+"_bolang_cu_"+$a) ($qvxian_D+"_bolang_cu_loc_"+$a);
     parent ($qvxian_D+"_bolang_cu_grp_A_"+$a) $boliang;
      }
     
     ///////////////////////蔟控制复制出来定位器//////////////////////////////
     
     
      int $panduan_A=`objExists ($qvxian_D+"_bolanggrp"+"_A")`;
      if ($panduan_A==0)
      { select -cl  ;
        group -empty -n ($qvxian_D+"_bolanggrp"+"_A");
        setAttr ($qvxian_D+"_bolanggrp"+"_A"+".visibility") 0;
        setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolanggrp"+"_A"+".v");
       }
    string $qvxian_D_boliang_shp[]=`listRelatives -s ($qvxian_D+"_bolang")`;
   connectAttr -force ($qvxian_D_boliang_shp[0]+".worldSpace[0]")  ($qvxian_D+"qvxianzuijingdianjiedian"+".inputCurve");//曲线链接到曲线信息节点
   for($aa=0;$aa<size($objloc_d);$aa++)
   {
        string $loc_d=$objloc_d[$aa];
        float $pos[]=`xform -q -ws -t $loc_d`;
       setAttr -type float3  ($qvxian_D+"qvxianzuijingdianjiedian.inPosition") $pos[0] $pos[1] $pos[2];
      float $weozh=`getAttr  ($qvxian_D+"qvxianzuijingdianjiedian.parameter")`;
      
      int $panduan_l=`objExists ($loc_d+"_pointOnCurveInfo_"+$aa)`;
      if($panduan_l==1){delete ($loc_d+"_pointOnCurveInfo_"+$aa); }
     createNode "pointOnCurveInfo" -n ($loc_d+"_pointOnCurveInfo_"+$aa);//创建曲线最近点节点
     connectAttr -force  ($qvxian_D_boliang_shp[0]+".worldSpace[0]")  ($loc_d+"_pointOnCurveInfo_"+$aa+".inputCurve");
     setAttr ($loc_d+"_pointOnCurveInfo_"+$aa+".parameter") $weozh;
     
     spaceLocator -p 0 0 0 -n ( $loc_d+"_A_loc_"+$a);
     connectAttr -force ($loc_d+"_pointOnCurveInfo_"+$aa+".position") ( $loc_d+"_A_loc_"+$a+".t");
     parent ( $loc_d+"_A_loc_"+$a) ($qvxian_D+"_bolanggrp"+"_A");
     pointConstraint -mo ( $loc_d+"_A_loc_"+$a)   $loc_d;
   }
  
   delete  ($qvxian_D+"qvxianzuijingdianjiedian");
   parent ($qvxian_D+"_bolanggrp"+"_A") $boliang;
   
   ///////////////////创建控制器////////////////////////
   
   string $qvxianname=($qvxian_D+"UP_bolangqvxian");
   if($i==1){$qvxianname=($qvxian_D+"DN_bolangqvxian");}
   float $kaishi_pos_A[]=`xform -q -ws -t  ($qvxian_D+".cv[0]")`;
   float $qvxian_MM_pos[]=`xform -q -ws -t  ($qvxian_D+"_bolang.cv[2]")`;
   float $rsd= `abs($kaishi_pos_A[0]*0.2)`;
  circle -c 0 0 0 -nr 0 1 0 -sw 360 -r $rsd -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $qvxianname; 
  group -n ($qvxianname+"_grp_B");
  group -n ($qvxianname+"_grp_A");
  select -r  ($qvxianname+".cv[0]") ($qvxianname+".cv[2]") ($qvxianname+".cv[4]") ($qvxianname+".cv[6]") ;
  scale -r -p 0cm 0cm 0cm 0.417937 0.417937 0.417937 ;
  if($i==0)
  {  
  move -r -os -wd 0 ($rsd*0.5) 0 ;
  select -r  ($qvxianname+".cv[0:99999999]");
  move -r -os -wd 0 ($rsd*0.5) ($rsd*1.5) ;
  }else
  {
  move -r -os -wd 0 ($rsd*-0.5) 0 ;
  select -r  ($qvxianname+".cv[0:99999999]");
  move -r -os -wd 0 ($rsd*-0.5) ($rsd*1.5) ;
  }
 
  xform  -ws -t $qvxian_MM_pos[0] $qvxian_MM_pos[1] $qvxian_MM_pos[2]($qvxianname+"_grp_A");
  
  string $shape[]=`listRelatives -s $qvxianname`;
    setAttr ($shape[0]+".overrideEnabled") 1;
    setAttr ($shape[0]+".overrideColor") 16;
  //parent   ($qvxianname+"_grp_A") $boliang;
    
    
    ////////////////////表达式//////////////////////////
   
    float $rsd= ($kaishi_pos_A[0]*0.35);
    float$aaaa= `abs ($rsd)`;
     float $temp=$aaaa;
    addAttr -ln "upty"  -at double  -dv 1 -k 1 $qvxianname;
    addAttr -ln "dnty"  -at double  -dv 1 -k 1 $qvxianname;
    addAttr -ln "pianyi"  -at double  -dv 0 -k 1 $qvxianname;
    addAttr -ln "upsl"  -at double  -dv $temp -k 1 $qvxianname;
    addAttr -ln "dntsl"  -at double  -dv ($temp*-1) -k 1 $qvxianname;
    setAttr -keyable false -channelBox true ($qvxianname+".upsl");
    setAttr -keyable false -channelBox true ($qvxianname+".dntsl");
    
    

    string $grp_C1=($qvxian_D+"_bolang_cu_grp_C_1");
    string $grp_C2=($qvxian_D+"_bolang_cu_grp_C_2");
    string $grp_C3=($qvxian_D+"_bolang_cu_grp_C_3");
    
    string $grp_B1=($qvxian_D+"_bolang_cu_grp_B_1");
    string $grp_B2=($qvxian_D+"_bolang_cu_grp_B_2");
    string $grp_B3=($qvxian_D+"_bolang_cu_grp_B_3");
   //select -r $grp_C3;
   // print $grp_C3;
    float $temp_[]=`xform -q -ws -t  $grp_C2`;
    move -rpr $temp_[0] $temp_[1] $temp_[2] ($grp_B3+".scalePivot") ($grp_B3+".rotatePivot") ;
    move -rpr $temp_[0] $temp_[1] $temp_[2] ($grp_B1+".scalePivot") ($grp_B1+".rotatePivot") ;
    string $exp="";
    $exp+=($grp_C1+".ty=clamp(("+$qvxianname+".dntsl*"+$qvxianname+".dnty),("+$qvxianname+".upsl*"+$qvxianname+".upty),("+$qvxianname+".ty*0.6+"+$qvxianname+".tx));\n");
    $exp+=($grp_C3+".ty=clamp(("+$qvxianname+".dntsl*"+$qvxianname+".dnty),("+$qvxianname+".upsl*"+$qvxianname+".upty),("+$qvxianname+".ty*0.6-"+$qvxianname+".tx));\n");
    $exp+=($grp_C2+".ty=("+$grp_C1+".ty+"+$grp_C3+".ty);\n");
    $exp+=($grp_C1+".tz="+$grp_C3+".tz=("+$qvxianname+".tz*0.5);\n");
    $exp+=($grp_B2+".tz=("+$grp_B1+".tz+"+$grp_B3+".tz);\n");
    $exp+=($grp_B1+".sx="+$grp_B3+".sx=("+$qvxianname+".sx);\n");
    $exp+=($grp_C1+".tx="+$grp_C2+".tx="+$grp_C3+".tx="+$qvxianname+".pianyi*0.1;\n");
    $exp+=($grp_B3+".rx="+$grp_B1+".rx="+$qvxianname+".rx;\n");
    $exp+=($grp_B3+".ry="+$grp_B1+".ry="+$qvxianname+".ry;\n");
    $exp+=($grp_B3+".rz="+$grp_B1+".rz="+$qvxianname+".rz;\n");
    //print $exp;
    
int$panduan_biaodashi=`objExists ($qvxian_D+"_biaodashi")`;
if($panduan_biaodashi==1){delete ($qvxian_D+"_biaodashi") ;}
expression -s $exp  -o ($qvxian_D+"_biaodashi") -ae 1 -uc all ;

}
}


///////////////////////////////嘴唇反转骨骼创建/////////////////////////////////////////////



global proc zxb_extract_Curves_lip()
 {
  string$qvxianss=`zxb_extract_Curves_proc_extract_WANQV`;
  string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
  zxb_ADD_shuxing_string_proc($head_qvxian,"lip_Curves");
  setAttr -type "string" ($head_qvxian+".lip_Curves")$qvxianss;

  
  }

global proc zxb_extract_Curves_bs_lip()
{
    string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
    string$names=`getAttr ($head_qvxian+".lip_Curves")`;
    zxb_extract_Curves_lipbs($names) ;
    
 }
global proc zxb_extract_Curves_lipbs(string$neme) 
 {
 
string$Array_s[]= stringToStringArray($neme, " ");//字符串转化数组


 string$Curves_Ws[];
 clear $Curves_Ws;//清除数组
 $Curves_Ws[0]=$Array_s[0]; $Curves_Ws[1]=$Array_s[1];
 string$Curves_Ns[];
 clear $Curves_Ns;//清除数组
 $Curves_Ns[0]=$Array_s[2]; $Curves_Ns[1]=$Array_s[3];
 string$Curves_ins[];
 clear$Curves_ins;//清除数组
 $Curves_ins[0]=$Array_s[4]; $Curves_ins[1]=$Array_s[5];
 string$Curves_outers[];
 clear$Curves_outers;//清除数组
 $Curves_outers[0]=$Array_s[6];$Curves_outers[1]=$Array_s[7];
 
 for($u=0;$u<size($Curves_Ws);$u++)
   {
   string$Curve_W=$Curves_Ws[$u];
   string$Curve_N=$Curves_Ns[$u];
   string$Curves_in=$Curves_ins[$u];
   string $Curves_outer=$Curves_outers[$u];
   
   
   

  
  
  
select -r   $Curves_in;
select -add $Curve_W;
string $bs_in[]=`blendShape -frontOfChain `;
$bs_W=$bs_in[0];


select -r $Curves_outer ;
select -add $Curve_N ;

string $bs_outer[]=`blendShape -frontOfChain `;
$bs_N=$bs_outer[0];



select -r $Curve_W ;

string $Curves_N_root=$Curve_N+"_root";
duplicate -rr -n$Curves_N_root; 



select -r $Curve_W ;
select -add  $Curve_N;
select -add  $Curves_N_root;
string $bs_root[]=`blendShape -frontOfChain `;
$bs_G=$bs_root[0];
int $ex=`objExists  "lip_Curve"`;//查询这个物体是否纯在
if($ex==0)
{
circle -c 0 0 0 -nr 0 1 0 -sw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n "lip_Curve";
group  -n "lip_Curve_grp_A";
group  -n "lip_Curve_grp_B";
group  -n "lip_Curve_grp_C";
float$bbobx_Max[]=`getAttr ($Curve_W+".boundingBoxMax")`;////绑定box节点   
setAttr "lip_Curve_grp_C.translateX" $bbobx_Max[0];
setAttr "lip_Curve_grp_C.translateY" $bbobx_Max[1];
setAttr "lip_Curve_grp_C.translateZ" $bbobx_Max[2];
 }
parent "lip_Curve_grp_C" "lip_curve_Group";
string$up_dw="";
if($u==0)
  {
      $up_dw="UP_";
 
  }
if($u==1)
  {
      $up_dw="DW_";
 
  }

string$shuxing_in=$up_dw+$Curves_in;
string$shuxing_outer=$up_dw+$Curves_outer;
string$shuxing_hensui=$up_dw+"gensui_M" ;
addAttr -ln $shuxing_in -at double  -min 0 -max 1 -dv 0 -k 1"lip_Curve";
addAttr -ln  $shuxing_outer  -at double  -min 0 -max 1 -dv 0 -k 1 "lip_Curve";
addAttr -ln $shuxing_hensui  -at double  -min 0 -max 1 -dv 1 -k 1  "lip_Curve";


connectAttr -f  ("lip_Curve."+$shuxing_in) ($bs_W+"."+ $Curves_in) ;
connectAttr -f  ("lip_Curve."+$shuxing_outer) ($bs_N+"."+ $Curves_outer) ;
connectAttr -f  ("lip_Curve."+$shuxing_hensui ) ($bs_G+"."+$Curve_W) ;

string$fanxiangjiedian=($Curve_W+"_reverse");
int $panduan=`objExists $fanxiangjiedian`;//查询这个物体是否纯在
if($panduan==1){delete $fanxiangjiedian;}
shadingNode -asUtility reverse -n $fanxiangjiedian ; //创建返向节点

connectAttr -f   ("lip_Curve."+$shuxing_hensui ) ($fanxiangjiedian+".inputX") ;
connectAttr -f    ($fanxiangjiedian+".output.outputX") ($bs_G+"."+$Curve_N) ;






select -r $Curves_N_root;
CenterPivot;

///////////////////创建关节  并控制关节的位移///////////////////////////////////
select -r ($Curves_N_root+".cv[0:999999999999]");
string$cvs[]=`ls -sl -fl`;
int$duanshu=size($cvs);
string$bn_root=($Curves_N_root+"_root");
int$ex=`objExists $bn_root`;
if($ex==0)
{
    select -cl  ;
    joint -n $bn_root;
    //delete`pointConstraint  $qvxian $bn_root`;
    setAttr ($bn_root+".drawStyle") 2;
    setAttr -l true { ($bn_root+".ds") };
    /*string $qvxian_fu[]=`listRelatives -p  $Curves_N_root`; 
    
    string $qvxian_grp=$qvxian_fu[0];
    int $ex=`objExists $qvxian_grp`;
    if($ex==1){parent $bn_root $qvxian_grp;}*/
     parent $bn_root ("lip_joints_Group")  ;
    
}

select -r $Curves_N_root;
string$qvxian_A=($Curves_N_root+"_zhouxiang");
duplicate -rr -n $qvxian_A;
//parent $qvxian_A("lip_curve_Group") ;


select -r $qvxian_A;
rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s $duanshu -d 3 -tol 0.01  $qvxian_A;

select -cl  ;

string$qvxianjiedian_xingxi=($Curves_N_root+"_nearestPointOnCurve");
int$panduan=`objExists $qvxianjiedian_xingxi`;
if($panduan==1){delete $qvxianjiedian_xingxi;}
createNode nearestPointOnCurve -n $qvxianjiedian_xingxi;//
string $qvxian_Shape[]=`listRelatives -s  $Curves_N_root`; 
string$qvxianShape=$qvxian_Shape[0];
connectAttr -f   ($qvxianShape+".worldSpace[0]")  ($qvxianjiedian_xingxi+".inputCurve");
string$all_bns="";
for($i=0;$i<size($cvs);$i++) 
{
    int$qvyu=$i%3;
    string $cv_dian=$cvs[$i];
    string$qvxian_bn=($Curves_N_root+"_bn_"+$i);
    $all_bns+=$qvxian_bn+" ";
    string$qvxianjiedian=($qvxian_bn+"_pointOnCurveInfo_"+$i);
    float $cv_pos_A[]=` xform -q -ws -t    $cv_dian`;
     select -r $bn_root;
     joint -p$cv_pos_A[0] $cv_pos_A[1] $cv_pos_A[2] -n $qvxian_bn;
     
     int$panduan=`objExists $qvxianjiedian`;
     if($panduan==1){delete $qvxianjiedian;}
     createNode pointOnCurveInfo -n $qvxianjiedian;//创建曲线信息节点
    setAttr -type float3 ($qvxianjiedian_xingxi+".inPosition") $cv_pos_A[0] $cv_pos_A[1] $cv_pos_A[2];
    float $param=`getAttr ($qvxianjiedian_xingxi+".parameter")`;
    setAttr  ($qvxianjiedian+".parameter") $param;
    connectAttr -f   ($qvxianShape+".worldSpace[0]")  ($qvxianjiedian+".inputCurve");
    connectAttr -f    ($qvxianjiedian+".position") ($qvxian_bn+".t");//连接位置
    
    select -r $qvxian_A;
    select -add $qvxian_bn;
   delete `tangentConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene"`;
   
    select -r $qvxian_bn;
    channelBoxCommand -freezeRotate;
    
   if($qvyu==0)
     {
         setAttr ($qvxian_bn+".radius") 0.2;
      }else{setAttr ($qvxian_bn+".radius") 0.1;}

}
delete $qvxianjiedian_xingxi;
   


string$all_bnss[]= stringToStringArray( $all_bns," ");//字符串转化数组
for($uu=0;$uu<size($all_bnss);$uu++) 
  {
  int$qvyu=$uu%3;
  string$bn=$all_bnss[$uu];
  select -add $bn;
  if($qvyu==0&&$uu>0)
    {
     int$kaishi=$uu-3;
     string$aaaa[]=`ls -sl`;
     zxb_fanzhuanzui_xniuqv_proc($aaaa);
     

     select -cl  ;
     select -add $bn;
     }
  }



   } 
  
  
  
 
  
/*select -r $Curves_Ws[0];
select -add $Curves_Ns[0];
string$up_Curves[]=`ls -sl `;
for ($j=0;$j<size($up_Curves);$j++)
{
string$qvxian=$up_Curves[$j];
select -r ($qvxian+".cv[0:99999]");
string$up_A[]=`ls -sl -fl`;
float$temp_pos=0;
string$zuigao_L="";
string$zuigao_R="";
string$cv_MM="";
for ($i=0;$i<size($up_A);$i++) 
     {
      string$cv=$up_A[$i];
      float$cv_pos_y[]=`xform -q -ws -t $cv`;
      if($cv_pos_y[1]>$temp_pos)
        {
         $temp_pos=$cv_pos_y[1];
         $zuigao_L=$cv;
        
         }
  
      float$temp=$cv_pos_y[0];
      float$abs=abs($temp);
      if($abs<0.00000001)
        {
        $cv_MM=$cv;
       
        }
      }
      
      


string$up_LL="";

float$cv_pos_ytemp[]=`xform -q -ws -t $zuigao_L`;
spaceLocator -p 0 0 0 -n "temp_loc";
setAttr -type float3 "temp_loc.translate" (-$cv_pos_ytemp[0]) $cv_pos_ytemp[1] $cv_pos_ytemp[2];

float$loc_pos[]=`xform -q -ws -t "temp_loc"`;
delete "temp_loc" ;
float$mag=100000000000;
for ($i=0;$i<size($up_A);$i++) 
     {
      string$cv=$up_A[$i];
       select -r $cv;
      float$cv_pos_y[]=`xform -q -ws -t $cv`;
      float $weizhi=mag(<<$loc_pos[0],$loc_pos[1],$loc_pos[2]>>-<< $cv_pos_y[0] ,$cv_pos_y[1] ,$cv_pos_y[2]>>);////////计算距离
      if($weizhi<$mag)
        {
          $mag=$weizhi;
         $zuigao_R=$cv;
         
         }
      }
 


for ($i=0;$i<size($up_A);$i++) 
    {
      string$cv=$up_A[$i];
      float$cv_pos_y[]=`xform -q -ws -t $zuigao_L`;

       float$cv_pos_yy[]=`xform -q -ws -t $cv`;
       

       if($cv_pos_yy[0]<$cv_pos_y[0])
        {
         select -add   $cv ;
         }
       if($cv_pos_yy[0]<0.0000001)
         {
             select -d  $cv;
          }
          
     
     }
select -d  $cv_MM;
string$bianliang_dian_A[]=`ls -sl -fl`;
string $IKS[]=$bianliang_dian_A;
         
        
string$all_bn[];
clear $all_bn;  
for($k=0;$k<size($IKS);$k++)
    {
      string$temp_bn=$IKS[$k];
      int$temp_a=size($IKS)-1-$k;
      $all_bn[$temp_a]=$temp_bn;
               
               
      }
          
          string$mingziss="";
 for($k=0;$k<size($all_bn);$k++)
     {
      string$temp=$all_bn[$k]+" ";
       $mingziss+=$temp;
       }
            
$bianliang_dian_A=stringToStringArray($mingziss, " ");//字符串转化数组
            





select -r $up_A ;

for ($i=0;$i<size($up_A);$i++) 
    {
      string$cv=$up_A[$i];
      float$cv_pos_y[]=`xform -q -ws -t $zuigao_R`;

       float$cv_pos_yy[]=`xform -q -ws -t $cv`;
       

       if($cv_pos_yy[0]<=$cv_pos_y[0])
        {
         select -d   $cv ;
         }
     if($cv_pos_yy[0]>0.0000001)
             {
              
             select -d  $cv;
              }
 
          
     
     }
select -d  $cv_MM;
string$bianliang_dian_B[]=`ls -sl -fl`;
select -r  $bianliang_dian_B[0];
select -add  $bianliang_dian_A[0];
int$ex=`objExists $bianliang_dian_A[0]`;
int$ssze=size($bianliang_dian_A);
 float$aa=0;
if($ex==1)
  {
   float$bbobx_Max[]=`getAttr ($Curves_Ws[0]+".boundingBoxMax")`;////绑定box节点   
   float$Curves_sizea=$bbobx_Max[0]/size($up_A)/2;
   for ($ii=0;$ii<size($bianliang_dian_B);$ii++) 
      {
       string$cv=$bianliang_dian_B[$ii];
       string$cv_b=$bianliang_dian_A[$ii];
       $aa=$Curves_sizea*$ii*3;
       float$weiyi=$Curves_sizea+$aa;
        select -r $cv;
       move -r -os -wd 0 $weiyi 0  ;
       select -r $cv_b;
        move -r -os -wd 0 $weiyi 0  ;

      }

      $Curves_sizea=$Curves_sizea*$ssze*3;
     select -r $cv_MM;
     move -r -os -wd 0  $Curves_sizea 0  ;
  } 
    
    
}  */ 


 
 }
 
 
 
global proc string zxb_extract_Curves_proc_extract_WANQV() 
{
       string $xiaba_bn_W=`textFieldGrp -q -tx  UI_mouth_outer_wire `;
       string $xiaba_bn_N=`textFieldGrp -q -tx   UI_mouth_oral_wire`;
       string$Curves_W=zxb_extract_Curves_proc(0,"Curves_W","place",$xiaba_bn_W);
       string$Curves_Ws[]= stringToStringArray($Curves_W, " ");//字符串转化数组
       string$Curves_N=zxb_extract_Curves_proc(0,"Curves_N","place",$xiaba_bn_N);
       string$Curves_Ns[]= stringToStringArray($Curves_N, " ");//字符串转化数组
       
       select -r ($Curves_Ws[0]+".cv[0:99999]") ;
       string$qvxians_A[]=`ls -sl -fl`;
              
       select -r ($Curves_Ns[0]+".cv[0:99999]") ;
       string$qvxians_B[]=`ls -sl -fl`;
       
       
       int $ex_a=size($qvxians_A);
       int $ex_b=size($qvxians_B);
       if($ex_b!=$ex_a)
         {
          select -r $Curves_Ns[0];
          rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 1 -s $ex_a -d 1 -tol 0.001 $Curves_Ns[0];
          select -r $Curves_Ns[1];
          DeleteHistory;
          }
          
       select -r ($Curves_Ws[1]+".cv[0:99999]") ;
       string$qvxians_C[]=`ls -sl -fl`;
              
       select -r ($Curves_Ns[1]+".cv[0:99999]") ;
       string$qvxians_D[]=`ls -sl -fl`;
       
       
       int $ex_C=size($qvxians_C);
       int $ex_D=size($qvxians_C);  
        if($ex_D!=$ex_C)
         {
          select -r $Curves_Ns[1];
          rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 1 -s $ex_C -d 1 -tol 0.001 $Curves_Ns[1];
          select -r $Curves_Ns[1];
          DeleteHistory;
          }
                
        select -r $Curves_Ws;
        DeleteHistory;
        select -r $Curves_Ns;
        DeleteHistory;


float $cv_pos_kaishi_a[]=` xform -q -ws -t   $qvxians_A[0]`;
float $cv_pos_kaishi_b[]=` xform -q -ws -t   $qvxians_B[0]`;
if($cv_pos_kaishi_a[0]<0)
  {
   select -r $Curves_Ws[0];
   reverseCurve -ch 0 -rpo 1 $Curves_Ws[0];
   select -r $Curves_Ws[1];
   reverseCurve -ch 0 -rpo 1 $Curves_Ws[1];
  }

 if($cv_pos_kaishi_b[0]<0)
  {
   select -r $Curves_Ns[0];
   reverseCurve -ch 0 -rpo 1 $Curves_Ns[0];
   select -r $Curves_Ns[1];
   reverseCurve -ch 0 -rpo 1 $Curves_Ns[1];
  } 
  
  
string$in_in="";
string$out_out="";
string$in_out="";
zxb_ADD_kongzu_proc("lip_curve_Group");
zxb_ADD_kongzu_proc("lip_joints_Group");
parent("lip_joints_Group")("head_all_bn_Group");
parent("lip_curve_Group")("head_all_curve_Group") ;
for($u=0;$u<size($Curves_Ws);$u++)
 {
string$Curve_W=$Curves_Ws[$u];
string$Curve_N=$Curves_Ns[$u];
  
select -r $Curve_W; 
string $Curves_in=$Curve_W+"_in";
duplicate -rr -n $Curves_in; 
select -r $Curve_N; 
string $Curves_outer=$Curve_N+"_outer";
duplicate -rr -n $Curves_outer; 
$in_out+=$Curves_in+" ";
$out_out+=$Curves_outer+" ";

  parent  $Curve_W ("lip_curve_Group");
  parent  $Curve_N("lip_curve_Group");
   parent   $Curves_in("lip_curve_Group");
   parent   $Curves_outer("lip_curve_Group");
  }

 $in_out+= $in_in+$out_out;
 string$fanhui=$Curves_Ws[0]+" "+$Curves_Ws[1]+" "+$Curves_Ns[0]+" "+$Curves_Ns[1]+" "+$in_out;
 return $fanhui;



  }
global proc string zxb_extract_Curves_proc(int$a,string$mingzi,string$qianzui,string$xian_A)//int 区分线段的平均值或者法线朝向 $mingzi名字 $qianzui前缀 $xian_A 线段名称
{

string$xian=$xian_A;
string$Axianxian=$qianzui;
string$mingzi=$mingzi;
string$qvxianss[]= stringToStringArray($xian, " ");//字符串转化数组
string $bianliang[]=$qvxianss;//提取曲线名字
string$temp_qvxian[];
clear $temp_qvxian;
int $nemt=`tokenize $bianliang[0]"."  $temp_qvxian`;//分离字符串存到变量
string$moxing=$temp_qvxian[0];
select -r $bianliang;
ConvertSelectionToVertices;
string $dingdian[]=`ls -sl -fl`;


      string$R_cv="";
      string$L_cv="";
     string$vtxs[]=$dingdian;
     float$dd=-100000000000000;
     float$xx=1000000000000000;
     string$dian_L="";
     string$dian_R="";
     for ($i=0;$i<size($vtxs);$i++)
          {
           string$vtx=$vtxs[$i];
           float$bn_pos[]=`xform -q -ws -t $vtx`;
           if($bn_pos[0]>$dd)
             {
             $dd=$bn_pos[0];
             $dian_L=$vtx;
             }
             if($bn_pos[0]<$xx)
             {
             $xx=$bn_pos[0];
             $dian_R=$vtx;
             }
             
           }
           
           
     $L_cv=$dian_L;   
     $R_cv=$dian_R;
 float $R_POS[]=`xform -q -ws -t $R_cv`; 
 string$qvxian_mingzi=$Axianxian+"_temp_curve";
  select -r $qvxianss;
  polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $qvxian_mingzi;
 DeleteHistory;
 float$pamte=zxb_return_curve_U($R_POS[0],$R_POS[1],$R_POS[2],$qvxian_mingzi);
 select -r ($qvxian_mingzi+".u["+$pamte+"]") ;
float $tempp_POS[]=`xform -q -ws -t $dingdian[0]`; 
int$jisuan=size($dingdian)-1;
float $tempp_POS_A[]=`xform -q -ws -t $dingdian[$jisuan]`; 
float $R_POaS=$R_POS[0]+$R_POS[1]+$R_POS[2];
float $R_PObS=$tempp_POS[0]+$tempp_POS[1]+$tempp_POS[2];
if($R_POaS!=$R_PObS)
  {
    moveNurbsCurveSeam;
   }
 

 select -r ($qvxian_mingzi+".cv[0:999999999]");
 
 string $qvxian_A[]=`ls -sl -fl`;
 
 
string$dianLL="";
float $cv_pos[]=`xform -q -ws -t $L_cv`;
float$maga=1000000000000;
     
for($iii=0;$iii<size($qvxian_A);$iii++)
   { 
     string$mag_cv=$qvxian_A[$iii];
     float $mag_po[]=`xform -q -ws -t $mag_cv`;
     float $weizhi=mag(<<$cv_pos[0],$cv_pos[1],$cv_pos[2]>>-<< $mag_po[0] ,$mag_po[1] ,$mag_po[2]>>);////////计算距离
     if($weizhi<$maga){$maga=$weizhi;$dianLL=$mag_cv;}
     } 
    
//print $dianLL;
  string$ccv[];
  clear $ccv;
  int $nemt=`tokenize $dianLL"[" $ccv`;//分离字符串存到变量
   int $nemt=`tokenize $ccv[1]"]" $ccv`;//分离字符串存到变量
  string$shu=$ccv[0];
 
 
 int$qvxiancv_size=size($qvxian_A);
int$temp_a=$shu;

float$exa=0;
float$exb=0;


if($a==0)
{
select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
$exb=`zxb_qvfengshangzi`;

select -r ($qvxian_mingzi+".cv[0:999999999]");
select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
$exa=`zxb_qvfengshangzi`;
}
if($a==1)
 {
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $exa=zxb_normal_pingjunshu($moxing);
  
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $exb=`zxb_normal_pingjunshu($moxing)`;
  }


string$up_qvxiancvs[];
clear$up_qvxiancvs;
string$dw_qvxiancvs[];
clear$dw_qvxiancvs;



if($exb>$exa)
  {
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
 $dw_qvxiancvs =`ls -sl -fl`;
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $up_qvxiancvs =`ls -sl -fl`;
  }
if($exa>$exb)
  {
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $up_qvxiancvs =`ls -sl -fl`;
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $dw_qvxiancvs=`ls -sl -fl`;
   }
string$UP_zuijing="";
string$DW_zuijing="";


for($o=0;$o<2;$o++)
{
    string$temp_suzu[];
    clear$temp_suzu;
   if($o==0){$temp_suzu=$up_qvxiancvs;}
   if($o==1){$temp_suzu=$dw_qvxiancvs;}
   for($i=0;$i<size($temp_suzu);$i++)
    {
     string$temp_cv=$temp_suzu[$i];
     float $cv_pos[]=`xform -q -ws -t $temp_cv`;
     float$mag=1000000000000;
     string$dian="";
     for($ii=0;$ii<size($dingdian);$ii++)
        { 
         string$mag_cv=$dingdian[$ii];
         float $mag_po[]=`xform -q -ws -t $mag_cv`;
         float $weizhi=mag(<<$cv_pos[0],$cv_pos[1],$cv_pos[2]>>-<< $mag_po[0] ,$mag_po[1] ,$mag_po[2]>>);////////计算距离
         if($weizhi<$mag){$mag=$weizhi;$dian=$mag_cv+" ";}
         } 
     if($o==0){$UP_zuijing+=$dian;}
     if($o==1){$DW_zuijing+=$dian;}  
     }
    
 }   
string$up_zuijingdw[]= stringToStringArray($UP_zuijing, " ");//字符串转化数组
string$dw_zuijingdw[]= stringToStringArray($DW_zuijing, " ");//字符串转化数组       
string$head_qvxian=$Axianxian+"_"+$mingzi+"_UP";//open  
select -r $up_zuijingdw;
select -add $R_cv;
select -add $L_cv;
ConvertSelectionToContainedEdges;
polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $head_qvxian;

string$head_qvxian_b=$Axianxian+"_"+$mingzi+"_DW";//open
select -r $dw_zuijingdw;
select -add $R_cv;
select -add $L_cv;
ConvertSelectionToContainedEdges;
polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $head_qvxian_b;


string$temp_mingzi="";
$temp_mingzi+=$head_qvxian+" "+$head_qvxian_b+" ";
delete $qvxian_mingzi;



string$dian_LRA=$head_qvxian+".cv[0]";
float $pos_A[]=`xform -q -ws -t$dian_LRA`;
string$dian_LRB=$head_qvxian_b+".cv[0]";
float $pos_B[]=`xform -q -ws -t $dian_LRB`;

if($pos_A[0]!=$pos_B[0]){reverseCurve -ch 1 -rpo 1 $head_qvxian;}


 return $temp_mingzi;
}





global proc zxb_fanzhuanzui_xniuqv_proc(string $bns_name[])
{
////////////按顺序选中要控制与要被控制的关节 //////////////////////////
string $bns[]=$bns_name;
int$bnsize=size($bns);
string$bn_R= $bns[0];
string$bn_L= $bns[($bnsize-1)];
float$aa=1.0/($bnsize-1);



int$panduansb=1;


for($i=1;$i<($bnsize-1);$i++) 
{
    string$bn=$bns[$i];
    string$chengchu=($bn+"_multiplyDivide_"+$i+"_rx");
    string$chengchu_A=($bn+"_multiplyDivide_A"+$i+"_rx");
    string$chengchu_B=($bn+"_multiplyDivide_B"+$i+"_rx");

    string$fanxiang=($bn+"_reverse"+$i+"_rx");
    string$jianjian=($bn+"_plusMinusAverage"+$i+"_rx");
    
    
    float$ab=1-$aa*$i;
    float$sb=smoothstep (0,1,$ab);
     float$bb=$ab;
     if($panduansb==1)
     {
      $bb=$sb;
      }
     int$ex=`objExists ($bn+".rooweigth")`;
    if($ex==0)
    {
          addAttr -ln "rooweigth"  -at double  -min 0 -max 1 -dv $bb -k 1 $bn;
          setAttr -keyable false -channelBox true ($bn+".rooweigth");
    }
    
    
    
    
    int$ex=`objExists ($bn+".rooallx")`;
    if($ex==0)
    {
          addAttr -ln "rooallx"  -at double  -min 0 -max 2 -dv 1 -k 1 $bn;
          setAttr -keyable false -channelBox true ($bn+".rooallx");
    }
   
    int$ex=`objExists ($bn+".rooally")`;
    if($ex==0)
    {
          addAttr -ln "rooally"  -at double  -min 0 -max 2 -dv 1 -k 1 $bn;
          setAttr -keyable false -channelBox true ($bn+".rooally");
    }
    
     int$ex=`objExists ($bn+".rooallz")`;
    if($ex==0)
    {
          addAttr -ln "rooallz"  -at double  -min 0 -max 2 -dv 1 -k 1 $bn;
          setAttr -keyable false -channelBox true ($bn+".rooallz");
    }
    
    
    
    
   
    
    
  int$ex=`objExists $chengchu`;
  if($ex==1){delete  $chengchu;}
  shadingNode -asUtility multiplyDivide -n $chengchu;
  connectAttr -f ($bn_R+".r") ($chengchu+".input1");
  connectAttr -f ($bn+".rooweigth") ($chengchu+".input2X");
  connectAttr -f ($bn+".rooweigth") ($chengchu+".input2Y");
  connectAttr -f ($bn+".rooweigth") ($chengchu+".input2Z");

  
  
  int$ex=`objExists $chengchu_A`;
  if($ex==1){delete  $chengchu_A;}
  shadingNode -asUtility multiplyDivide -n $chengchu_A;
  connectAttr -f ($bn_L+".r") ($chengchu_A+".input1");

  
  int$ex=`objExists $fanxiang`;
  if($ex==1){delete  $fanxiang;}
  shadingNode -asUtility reverse -n $fanxiang; //创建返向节点
  
  connectAttr -f ($bn+".rooweigth") ($fanxiang+".inputX");
  connectAttr -f ($bn+".rooweigth") ($fanxiang+".inputY");
  connectAttr -f ($bn+".rooweigth") ($fanxiang+".inputZ");

  connectAttr -f ($fanxiang+".output") ($chengchu_A+".input2");
  
   
  int$ex=`objExists $jianjian`;
  if($ex==1){delete  $jianjian;}
 shadingNode -asUtility plusMinusAverage -n $jianjian;//创建加减节
  connectAttr -f ($chengchu+".output") ($jianjian+".input3D[0]");
 connectAttr -f ($chengchu_A+".output") ($jianjian+".input3D[1]");

  int$ex=`objExists $chengchu_B`;
  if($ex==1){delete  $chengchu_B;}
  shadingNode -asUtility multiplyDivide -n $chengchu_B;
  
connectAttr -f ($jianjian+".output3D") ($chengchu_B+".input1");
connectAttr -f ($bn+".rooallx") ($chengchu_B+".input2X");
connectAttr -f ($bn+".rooally") ($chengchu_B+".input2Y");
connectAttr -f ($bn+".rooallz") ($chengchu_B+".input2Z");

connectAttr -f  ($chengchu_B+".output") ($bn+".r")  ;


}
}







////////////////////////////////////////////创建眼睛控制器//////////////////////////////////////////
global proc zxb_chuangjianyanjingguyanjie_fangfa_proc()
{
 string $xiaba_bn=`textFieldGrp -q -tx  UI_zxb_eye`;
 string $toubukongzhiqi=`textFieldGrp -q -tx UI_head_controller `;
 string $toubuguanjie=`textFieldGrp -q -tx UI_head_bn `;
 //string $zongkongzhiqi=`textFieldGrp -q -tx  zxb_zairuzongkongzhiqi`;

 int$xingwei=`checkBox -q  -value  xingwei`;
  int$duicheng_bn=`checkBox -q  -value   duicheng`;

  string$bns[];
  clear $bns;
  int $nemt=`tokenize $xiaba_bn" " $bns`;//分离字符串存到变量
  string$bn=$bns[0];
  string$bn_p[]=`listRelatives -p $bn`;
  int$panduan_A=`objExists $bn_p[0]`;
  if($panduan_A==1)
  {  
  select -r $bn;
  parent -w;
  }


  string$bn_end[]=`listRelatives -c $bn`;
   //float$temp_poss=1.1072335187;

 //  float$temp_poss_Aa[]=`getAttr  ($bn_end[0]+".translateX")`;
 float$temp_poss_A=`getAttr  ($bn_end[0]+".translateX")`;
 float$temp_poss=$temp_poss_A*3;
  //float$temp_poss=$temp_poss_Aa[0]*3;
  float$bn_pos[]=`xform -q -ws -t $bn`;
  string$LLRR="";
  string$jingxiang="";
  string$array[];
  clear $array;
  if($bn_pos[0]>0.001)
    {
     $LLRR="L";  
     $jingxiang="R";
     $array= stringToStringArray($bn, $LLRR);//字符串转化数组
     int$size=size($array);


      if($size<1){error "关节利面没有镜像名称";}
    select -r  $bn;
    if($duicheng_bn==1){
         if($xingwei==0)
         {
         mirrorJoint -mirrorYZ -mirrorBehavior -searchReplace $LLRR $jingxiang;
          }else
              {
                mirrorJoint -mirrorYZ -searchReplace $LLRR $jingxiang;
              }
    
         }
    }
    if($bn_pos[0]<0.001)
   {
     $LLRR="R";  
     $jingxiang="L";
     $array= stringToStringArray($bn, $LLRR);//字符串转化数组
     int$size=size($array);
     if($size<=1){error "关节利面没有镜像名称";}
      select -r  $bn;
    if($duicheng_bn==1)
      {
       if($xingwei==0)
          {
           mirrorJoint -mirrorYZ -mirrorBehavior -searchReplace $LLRR $jingxiang;
          }else
              {
                mirrorJoint -mirrorYZ -searchReplace $LLRR $jingxiang;
                }
       }
     }
    string$temp_bn=($array[0]+$jingxiang+$array[1]);
    select -r $bn; 
    if($duicheng_bn==1){select -add $temp_bn; }
   
   string$alleyebns[]=`ls -sl`;  
   string$kongzhiqi_D=($bn+"_eye_kongzhiqi_D");
   string$kongzhiqi_D_GRP_A=($bn+"_eye_kongzhiqi_D_grp_A");
   string$kongzhiqi_D_GRP_B=($bn+"_eye_kongzhiqi_D_grp_B");
   string$kongzhiqi_D_GRP_C=($bn+"_eye_kongzhiqi_D_grp_C"); 
   
   
   string$loc=$bn+"dingwei_loc";
   string$loc_grp_A=$bn+"dingwei_loc_grp_A";
   spaceLocator -p 0 0 0 -n $loc ;
   group -n $loc_grp_A;
   parent  $loc_grp_A $toubuguanjie;
   setAttr -type float3 ($loc_grp_A+".translate") 0 0 0;
   setAttr -type float3  ($loc_grp_A+".rotate") 0 0 0 ;

   delete`orientConstraint $bn $loc_grp_A` ;
   setAttr ($loc_grp_A+".visibility") 0;
   setAttr -lock true ($loc_grp_A+".v");
   string$kongzhiqi="";
   for ($i=0;$i<size($alleyebns);$i++)
       {
       string$temp_BN=$alleyebns[$i];
       string$BN=$temp_BN+"_zhengti";
       string$en_BN=$BN+"end";
       string$kongzhiqi_A=($temp_BN+"_eye_kongzhiqi_A");
       string$kongzhiqi_A_GRP_A=($temp_BN+"_eye_kongzhiqi_A_GRP_A");
       string$kongzhiqi_A_GRP_B=($temp_BN+"_eye_kongzhiqi_A_GRP_B");
       string$kongzhiqi_A_GRP_C=($temp_BN+"_eye_kongzhiqi_A_GRP_C");
       
       string$kongzhiqi_B=($temp_BN+"_eye_kongzhiqi_B");
       string$kongzhiqi_B_GRP_A=($temp_BN+"_eye_kongzhiqi_B_grp_A");
       string$kongzhiqi_B_GRP_B=($temp_BN+"_eye_kongzhiqi_B_grp_B");
       string$kongzhiqi_B_GRP_C=($temp_BN+"_eye_kongzhiqi_B_grp_C");
       
       string$kongzhiqi_C=($temp_BN+"_eye_kongzhiqi_C");
       string$kongzhiqi_C_GRP_A=($temp_BN+"_eye_kongzhiqi_C_grp_A");
       string$kongzhiqi_C_GRP_B=($temp_BN+"_eye_kongzhiqi_C_grp_B");
       string$kongzhiqi_C_GRP_C=($temp_BN+"_eye_kongzhiqi_C_grp_C");
       
     $kongzhiqi+=$kongzhiqi_A+" ";
       
       select -r  $temp_BN;
       duplicate -rr -n $BN ;
       string$BN_end[]=`listRelatives -c -pa $BN`;
       rename $BN_end[0]  $en_BN;
       select -r  $en_BN;
       setAttr ($en_BN+".translateX") ($temp_poss*0.5);

       //move -r -os -wd 0 0 ($temp_poss*-0.5) ;
       //setAttr ($en_BN+".tx") ($temp_poss*0.5);
       circle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($temp_poss*0.2) -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $kongzhiqi_A; 
       group -n $kongzhiqi_A_GRP_A;
       group -n $kongzhiqi_A_GRP_B;    
       group -n $kongzhiqi_A_GRP_C;
      // string$qvxian_shap[]=`listRelatives -s $kongzhiqi_A`;
       setAttr ($kongzhiqi_A+".overrideEnabled") 1;
       setAttr  ($kongzhiqi_A+".overrideColor") 13;
       delete`parentConstraint $temp_BN  $kongzhiqi_A_GRP_C`;
       select -r ($kongzhiqi_A+".cv[0:999]") ;
       move -r -os -wd $temp_poss 0 0 ;
       parentConstraint  $kongzhiqi_A $BN ;
       
       circle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($temp_poss*0.1) -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $kongzhiqi_B; 
       group -n $kongzhiqi_B_GRP_A;
       group -n $kongzhiqi_B_GRP_B;    
       group -n $kongzhiqi_B_GRP_C;
       string$qvxian_shap_B[]=`listRelatives -s $kongzhiqi_B`;
       setAttr ($kongzhiqi_B+".overrideEnabled") 1;
       setAttr  ($kongzhiqi_B+".overrideColor") 17;
       delete`parentConstraint $temp_BN  $kongzhiqi_B_GRP_C`;
       select -r ($kongzhiqi_B+".cv[0:999]") ;
       move -r -os -wd $temp_poss 0 0 ;
       parentConstraint  $kongzhiqi_B $temp_BN ;

       //select -r ($kongzhiqi_B+".cv[1]") ($kongzhiqi_B+".cv[5]") ($kongzhiqi_B+".cv[3]")  ($kongzhiqi_B+".cv[7]");
       //scale -r -p 0.469494cm 14.99773cm 0.943909cm 0.2 0.2 0.2 ;


       string$bn_dingwei=$temp_BN+"_temp";
       select -r $temp_BN;
       duplicate -rr -n $bn_dingwei;
       select -r $bn_dingwei;
       move -r -os -wd ($temp_poss*3) 0 0 ;
       
       circle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($temp_poss*0.2) -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $kongzhiqi_C; 
       group -n $kongzhiqi_C_GRP_A;
       group -n $kongzhiqi_C_GRP_B;    
       group -n $kongzhiqi_C_GRP_C;
       setAttr ($kongzhiqi_C+".overrideEnabled") 1;
       setAttr  ($kongzhiqi_C+".overrideColor") 17;
       delete`parentConstraint $bn_dingwei  $kongzhiqi_C_GRP_C`;
      

      int$ex=`objExists $kongzhiqi_D`;
      if($ex==0)
         {  
       circle -c 0 0 0 -nr 1 0 0 -sw 360 -r ($temp_poss) -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $kongzhiqi_D; 
       group -n $kongzhiqi_D_GRP_A;
       group -n $kongzhiqi_D_GRP_B;    
       group -n $kongzhiqi_D_GRP_C;
       setAttr ($kongzhiqi_D+".overrideEnabled") 1;
       setAttr  ($kongzhiqi_D+".overrideColor") 17;
       delete`parentConstraint $bn_dingwei  $kongzhiqi_D_GRP_C`;
       setAttr ($kongzhiqi_D_GRP_C+".translateX") 0;
        setAttr -type float3 ($kongzhiqi_D_GRP_C+".r") 0 -90 0;
        select -r ($kongzhiqi_D+".cv[0:7]") ;

          }
          
      delete $bn_dingwei;
      parent $kongzhiqi_A_GRP_C  $toubukongzhiqi;
      parent $kongzhiqi_B_GRP_C  $toubukongzhiqi;
      parent $kongzhiqi_C_GRP_C  $kongzhiqi_D;
      if($i==0){parent $kongzhiqi_D_GRP_C  $toubukongzhiqi;}
      parent  $temp_BN $toubuguanjie;
       parent  $BN $toubuguanjie ;
      select -r $kongzhiqi_C;
      select -add $kongzhiqi_B_GRP_B;
      aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "objectrotation" -worldUpVector 0 1 0 -worldUpObject $loc;
      connectAttr -f ($kongzhiqi_B_GRP_B+".rotate") ($kongzhiqi_A_GRP_B+".rotate");
      connectAttr -f ($kongzhiqi_B_GRP_B+".t") ($kongzhiqi_A_GRP_B+".t");
      connectAttr -f ($kongzhiqi_A+".t") ($kongzhiqi_B_GRP_A+".t");
      connectAttr -f ($kongzhiqi_A+".r") ($kongzhiqi_B_GRP_A+".r");

      connectAttr -f ($kongzhiqi_A+".s") ($temp_BN+".s");
       connectAttr -f ($kongzhiqi_A+".s") ( $BN+".s");
       connectAttr -f ($kongzhiqi_A+".s") ( $kongzhiqi_B_GRP_B+".s");
       }
       
     
  
zxb_ADD_shuxing_string_proc($toubukongzhiqi,"eye_con");
setAttr -type "string" ($toubukongzhiqi+".eye_con")$kongzhiqi ;


 
}





////////////////////////////////////创建眼皮绑定//////////////////////////////////////////
global proc zxb_chuangjianyanpiguanjie_fangfa_proc()
{
 string $xiaba_bn=`textFieldGrp -q -tx  UI_zxb_eye`;//眼球关节
 string $toubukongzhiqi=`textFieldGrp -q -tx UI_head_controller `;//头部控制器
 string $toubuguanjie=`textFieldGrp -q -tx UI_head_bn `;//头部关节
 string$temp_commm=`getAttr ($toubukongzhiqi+".eye_con")`;
 
  string $eye_con=$temp_commm;//眼球控制器
    string $eye_cons[]= stringToStringArray($eye_con, " ");//字符串转化数组

  string $diana=`textFieldGrp -q -tx UI_zxb_eye_point_up`;
   string $dianb=`textFieldGrp -q -tx  UI_zxb_eye_point_dw`;
   
zxb_ADD_shuxing_string_proc($toubukongzhiqi,"eye_lip_ik");
zxb_ADD_kongzu_proc("zxb_fase_eye_loc");
zxb_ADD_kongzu_proc("zxb_fase_eye_ikHandle");
zxb_ADD_kongzu_proc("zxb_fase_eye_joints");
zxb_ADD_kongzu_proc("zxb_fase_eye_grp");
zxb_ADD_kongzu_proc("Face_Group");
zxb_ADD_kongzu_proc("zxb_eye_loc");
parent ("zxb_eye_loc")("head_all_loc_Group");
parent ("zxb_fase_eye_loc")("zxb_fase_eye_grp");
parent ("zxb_fase_eye_ikHandle")("zxb_fase_eye_grp");
parent ("zxb_fase_eye_joints")("zxb_fase_eye_grp");
parent("zxb_fase_eye_grp")("Face_Group");

string$ik_eye_ikHandle="";
 //string $zongkongzhiqi=`textFieldGrp -q -tx  zxb_zairuzongkongzhiqi`;
  float$diana_pos[]=`xform -q -ws -t $diana`;
  float$dianb_pos[]=`xform -q -ws -t $dianb`;

 int$xingwei=`checkBox -q  -value  xingwei`;
  int$duicheng_bn=`checkBox -q  -value   duicheng`;
  
  
  string$bns[];
  clear $bns;
  int $nemt=`tokenize $xiaba_bn" " $bns`;//分离字符串存到变量
  string$bn=$bns[0];
  string$yanpi_UP_bn=$bn+"_UP_yanpi";
  string$yanpi_UP_bn_end=$bn+"_UP_yanpi_end";
   
  string$yanpi_DW_bn=$bn+"_DW_yanpi";
  string$yanpi_UP_DW_end=$bn+"_DW_yanpi_end";
  
  select -r  $bn;
  duplicate -rr -n $yanpi_UP_bn;
  string$bn_end[]=`listRelatives -c -pa -type "joint" $yanpi_UP_bn`;
  string$bn_end_a[]=`listRelatives -c -pa  $yanpi_UP_bn`;
  select -r $bn_end_a;
  select -d $bn_end[0];
  doDelete;
  
  rename $bn_end[0] $yanpi_UP_bn_end;
  float$temp_poss=`getAttr  ($yanpi_UP_bn_end+".tx")`;
  select -r $yanpi_UP_bn;
  move -r -os -wd 0 ($temp_poss*0.025) 0 ;
  
  
   select -r  $bn;
  duplicate -rr -n $yanpi_DW_bn;
  string$bn_end_dw[]=`listRelatives -c -pa -type "joint" $yanpi_DW_bn`;
  string$bn_end_dwa[]=`listRelatives -c -pa  $yanpi_DW_bn`;
  select -r $bn_end_dwa;
  select -d $bn_end_dw[0];
  doDelete;
  
  rename$bn_end_dw[0] $yanpi_UP_DW_end;
  float$temp_posd=`getAttr  ($yanpi_UP_DW_end+".tx")`;
  select -r $yanpi_DW_bn;
  move -r -os -wd 0 ($temp_posd*-0.025) 0 ;
  
  
  string $tepup_loc=$bn+"_temp_uploca";
  string $tepdw_loc=$bn+"_temp_dwloca";
  spaceLocator -p 0 0 0  -n $tepup_loc ;
  parent $tepup_loc $yanpi_UP_bn_end;
  setAttr -type float3 ($tepup_loc+".translate") 0 0 0;
  spaceLocator -p 0 0 0  -n $tepdw_loc ;
  
  parent $tepdw_loc $yanpi_UP_DW_end;
  setAttr -type float3 ($tepdw_loc+".translate") 0 0 0;
  
  float$diss=10000000;
   select -r  $yanpi_DW_bn ;
    select -add  $yanpi_UP_bn ;
   string $bianliang[]=`ls -sl`;
   float$rz=0;
   for ($i=0;$i<size($bianliang);$i++)
       {
        string$guge=$bianliang[$i];
        string$temp_zi[]=`listRelatives -c  $guge`;
        string$temp_loc[]=`listRelatives -c  $temp_zi[0]`;
        float$temp_po[];
        clear$temp_po;
        if($i==0){$temp_po=$diana_pos;}else{$temp_po=$dianb_pos;$diss=10000000; }
        for ($ii=0;$ii<360;$ii++)
            {
              setAttr ($guge+".rotateZ") $ii;
              float$pos[]=`xform -q -ws -t $temp_loc[0]`;
              float$cdiss=mag(<<$temp_po[0],$temp_po[1],$temp_po[2]>>-<<$pos[0],$pos[1],$pos[2]>>);
              if($cdiss<$diss)
                {
                $diss=$cdiss;
                $rz=$ii;
                }
             
             }
             //print $rz;
        setAttr ($guge+".rotateZ") $rz;
        }
        
        
   float$diss=10000000;
   select -r $yanpi_DW_bn ;
    select -add $yanpi_UP_bn;
   string $bianliang[]=`ls -sl`;
   float$rz=0;
   for ($i=0;$i<size($bianliang);$i++)
       {
        string$guge=$bianliang[$i];
        string$temp_zi[]=`listRelatives -c  $guge`;
        string$temp_loc[]=`listRelatives -c  $temp_zi[0]`;
        float$temp_po[];
        clear$temp_po;
        if($i==0){$temp_po=$diana_pos;}else{$temp_po=$dianb_pos;$diss=10000000; }
        for ($ii=0;$ii<360;$ii++)
            {
              setAttr ($guge+".rotateY") $ii;
              float$pos[]=`xform -q -ws -t $temp_loc[0]`;
              float$cdiss=mag(<<$temp_po[0],$temp_po[1],$temp_po[2]>>-<<$pos[0],$pos[1],$pos[2]>>);
              if($cdiss<$diss)
                {
                $diss=$cdiss;
                $rz=$ii;
                }
             
             }
             //print $rz;
        setAttr ($guge+".rotateY") $rz;
        }
             
     delete  $tepup_loc  $tepdw_loc;
     float$upry=` getAttr  ($yanpi_UP_bn+".ry")`;
     float$dwry=` getAttr  ($yanpi_DW_bn+".ry")`;
     float$rot=($upry+$dwry)*0.5;
     setAttr  ($yanpi_UP_bn+".ry")  $rot;
     setAttr  ($yanpi_DW_bn+".ry")  $rot;
     
     
     select -r  $yanpi_UP_bn $yanpi_DW_bn;
     FreezeTransformations;
     parent -w;

     
     string$root_bn=($bn+"_root_bn");
     float$temp_pos[]=`xform -q -ws -t $yanpi_UP_bn`;
     select -cl  ;
      joint -p 0 $temp_pos[1]  $temp_pos[2] -n $root_bn;
      
    parent $root_bn("zxb_fase_eye_joints");
      
      
     
      string$AA="";
      string$bb="";
      string$R_bn="";
      if($duicheng_bn==1)
      {
      float$aa_pos[]=`xform -q -ws -t  $bn`;
      if($aa_pos[0]<0.001){$AA="R"; $bb="L";}else{$AA="L"; $bb="R";}
      string$zhuguanjioeS[]= stringToStringArray($bn, $AA);//字符串转化数组
      int$size=size($zhuguanjioeS);
      if($size<=1){error "关节利面没有镜像名称";}
     $R_bn=$zhuguanjioeS[0]+$bb+$zhuguanjioeS[1];
     }

     
     
      if($duicheng_bn==1)
     {
     select -r  $bn  $R_bn;
     }else
         {
             select -r  $bn;
         }
         
     string$rrlll[];
     clear $rrlll ;
     string $RL_bn[]=`ls -sl`;
     for ($i=0;$i<size($RL_bn);$i++)
     {
         
      string$c_bn=$RL_bn[$i];
      string$kongzu_A= $c_bn+"_ROOT_zu_A";
      string$kongzu_Aa= $c_bn+"_ROOT_zu_Aa";
      string$kongzu_B= $c_bn+"_ROOT_zu_B";
      string$kongzu_Bb= $c_bn+"_ROOT_zu_Bb";
      select -cl  ;
      group -empty -n  $kongzu_A;
      group -n $kongzu_Aa;
      delete`parentConstraint $c_bn $kongzu_Aa`;
      parentConstraint   -mo $c_bn $kongzu_Aa;
      parent   $kongzu_Aa ("head_all_loc_Group") ;
      
      select -cl  ;
      group -empty -n  $kongzu_B;
      group -n $kongzu_Bb;
      delete`parentConstraint  $c_bn $kongzu_Bb`;
      parentConstraint  -mo $toubuguanjie $kongzu_Bb;
      parent  $kongzu_Bb ("zxb_eye_loc");
      orientConstraint -mo $kongzu_A $kongzu_B ;
      
      
     string$root_gensui_bn_root="zxb_eye_loc_bn_"+$c_bn;;
     float$temp_pos[]=`xform -q -ws -t $yanpi_UP_bn`;
     select -cl  ;
     joint -p 0 0 0 -n $root_gensui_bn_root;
     $rrlll[$i]=$root_gensui_bn_root;
     delete`parentConstraint  $c_bn  $root_gensui_bn_root`;
     select -r $root_gensui_bn_root;
     makeIdentity -apply true -t 0 -r 1 -s 0 -n 0 -pn 1;

     parent $root_gensui_bn_root $root_bn;
     connectAttr -f   ($kongzu_B+".r")   ($root_gensui_bn_root+".r");
      //parent $root_gensui_bn  $toubuguanjie;
     }
    string$LLRR="";
    string$jingxiang="";
    string$array[];
    clear $array;
    string$up[];
    clear$up;
    string$dw[];
    clear$dw;
  for ($i=0;$i<size($bianliang);$i++)
      {
       string$temp_bn=$bianliang[$i];
      float$bn_pos[]=`xform -q -ws -t $temp_bn`; 
     

    if($bn_pos[0]>0.001)
      {
       $LLRR="L";  
       $jingxiang="R";
      
       $array= stringToStringArray($temp_bn, $LLRR);//字符串转化数组
        if($i==0){$dw=$array;}else{$up=$array;}
       int$size=size($array);


       if($size<=1){error "关节利面没有镜像名称";}
       select -r  $temp_bn;
       if($duicheng_bn==1)
         {
           
           mirrorJoint -mirrorYZ -mirrorBehavior -searchReplace $LLRR $jingxiang;
           
    
         } 
    }
    if($bn_pos[0]<0.001)
      {
     $LLRR="R";  
     $jingxiang="L";
     $array= stringToStringArray($bn, $LLRR);//字符串转化数组
     if($i==0){$dw=$array;}else{$up=$array;}

     int$size=size($array);
     if($size<=1){error "关节利面没有镜像名称";}
      select -r  $bn;
    if($duicheng_bn==1)
      {
       
           mirrorJoint -mirrorYZ -mirrorBehavior -searchReplace $LLRR $jingxiang;
         
       }
     }
  }

  string$shang_bn=$dw[0]+$jingxiang+$dw[1];
  string$xia_bn=$up[0]+$jingxiang+$up[1];
 if($duicheng_bn==1) 
    { 
    select -r $yanpi_DW_bn  $yanpi_UP_bn $shang_bn $xia_bn ;
    }else
       {
           select -r $yanpi_DW_bn  $yanpi_UP_bn;
        }

 string $RL_BNS[]=`ls -sl`;
 select -add ("zxb_fase_eye_joints");
 parent;
 string$jiajian_s[];
 clear $jiajian_s;
  string$fk_c[];
 clear $fk_c;
   string$fk_gensui[];
 clear $fk_gensui;
 
    string$Fk_[];
 clear $Fk_;
 

 for ($i=0;$i<size($RL_BNS);$i++)
     {
      string$temp_bn=$RL_BNS[$i];
      string$upik=$temp_bn+"_IK";
      string$upik_end=$temp_bn+"_IK_end";
      string$upfk=$temp_bn+"_FK";
      string$upfk_end=$temp_bn+"_FK_end";
      string$lik_loc=$temp_bn+"_ik_loc"+$i;
       string$lik_loc_grp=$lik_loc+"_grp";
      
  
     select -r $temp_bn;
     duplicate -rr -n $upik;
     setAttr ($upik+".visibility") 0;
     string$bn_up_end_ik[]=`listRelatives -c -pa  $upik`;
     rename $bn_up_end_ik[0] $upik_end;
  
     select -r $yanpi_DW_bn;
     duplicate -rr -n $upfk;
     setAttr ($upfk+".visibility") 0;
     string$bn_up_end_fk[]=`listRelatives -c -pa  $upfk`;
     rename $bn_up_end_fk[0] $upfk_end;
     
     string$jiajianjiedian=($temp_bn+"_plusMinusAverage_eye_A");
     int $ex=`objExists $jiajianjiedian`;//查询这个物体是否纯在
     if($ex==1){delete $jiajianjiedian;}
      shadingNode -asUtility plusMinusAverage -n $jiajianjiedian;//创建加减节点
      $jiajian_s[$i]=$jiajianjiedian;
      connectAttr -f ($upik+".rotateZ") ($jiajianjiedian+".input3D[0].input3Dz");
      connectAttr -f ($upfk+".rotate") ($jiajianjiedian+".input3D[1]");

      connectAttr -f ($jiajianjiedian+".output3D") ($temp_bn+".rotate");
      
      spaceLocator -p 0 0 0 -n $lik_loc ;
      group -n  $lik_loc_grp;
      setAttr  ($lik_loc+".visibility") 0;
     setAttr -lock true ($lik_loc+".v");
      parent $lik_loc_grp("zxb_fase_eye_loc");
      parent $upik $root_bn;
      parent $upfk $root_bn;
      select -r $upik;
      select -add $upik_end;
     string$ikhade[]=`ikHandle`;
     delete`parentConstraint  $ikhade[0]  $lik_loc_grp`;
     parent$ikhade[0]("zxb_fase_eye_ikHandle");
     $ik_eye_ikHandle+=$ikhade[0]+" ";
     setAttr  ($ikhade[0]+".visibility") 0;
     setAttr -lock true ($ikhade[0]+".v");
     select -r $lik_loc_grp;
     move -r -os -wd 0.02 0 0 ;
     select -r $lik_loc;
     select -add $ikhade[0];
     poleVectorConstraint -weight 1;
     float$rx=`getAttr ($temp_bn+".rx")`;
     if($i<=1)
       {
        if($rx>0){$rx=$rx*-1;}else{float$abs=abs($rx);$rx=$abs;}
        }
     
     setAttr ($ikhade[0]+".twist") $rx;
     // parent $temp_bn $root_bn; 
     //select -add $yanpi_UP_bn;
     
      string$upfk_C=$temp_bn+"_FK_C";
      string$upfkC_end=$temp_bn+"_FK_end_C";
      select -r $temp_bn;
      duplicate -rr -n $upfk_C;  
      setAttr ($upfk_C+".visibility") 0;
      string$bn_up_end_fkC[]=`listRelatives -c -pa  $upfk_C`;
      rename $bn_up_end_fkC[0] $upfkC_end;
      
      string$upfk_gensui=$temp_bn+"_FK_gensui";
      string$upfk_gensui_end=$temp_bn+"_FK_end_gensui";
      select -r $temp_bn;
      duplicate -rr -n $upfk_gensui;  
      setAttr ($upfk_gensui+".visibility") 0;
      string$bn_upfk_gensui[]=`listRelatives -c -pa  $upfk_gensui`;
      rename $bn_upfk_gensui[0] $upfk_gensui_end;
      
      
      orientConstraint   $upfk_gensui  $upfk_C;
      string $fk_qvxian=$temp_bn+"_fk_com";
      string$fk_qvxian_grp_A=$fk_qvxian+"_A";
      string$fk_qvxian_grp_B=$fk_qvxian+"_B";


      parent  $upfk_C $root_bn;
      string$rrll_bn="";
      if($i<=1){$rrll_bn=$rrlll[0];}else{$rrll_bn=$rrlll[1];}
      parent  $upfk_gensui  $rrll_bn ;
      $fk_c[$i]=$upfk_C;
     $fk_gensui[$i]=$upfk_gensui;
     $Fk_[$i]=$upfk;
  }
  
 for ($i=0;$i<size($eye_cons);$i++)
   {

      int$a=0;
      int$b=1;
      if($i==1){$a=2; $b=3;}
      
       string$con=$eye_cons[$i];
       addAttr -ln "shang"  -at double  -dv 0 -k 1 $con ;
       addAttr -ln "xia"  -at double   -dv 0 -k 1 $con ;
       addAttr -ln "biyan"  -at double   -dv 0 -k 1 $con ;
       addAttr -ln "beishu"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
       addAttr -ln "shangxia"  -at double   -dv 0 -k 1 $con ;
       
       
     addAttr -ln "gensui_rx_up"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
     addAttr -ln "gensui_ry_up"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
     addAttr -ln "gensui_rz_up"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
     
     addAttr -ln "gensui_rx_dw"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
     addAttr -ln "gensui_ry_dw"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
     addAttr -ln "gensui_rz_dw"  -at double  -min 0 -max 1 -dv 0.5 -k 1 $con ;
     
     setAttr -keyable false -channelBox true($con+".gensui_rx_up");
     setAttr -keyable false -channelBox true($con+".gensui_ry_up");
     setAttr -keyable false -channelBox true($con+".gensui_rz_up");
     setAttr -keyable false -channelBox true($con+".gensui_rx_dw");
     setAttr -keyable false -channelBox true($con+".gensui_ry_dw");
     setAttr -keyable false -channelBox true($con+".gensui_rz_dw");
     
     
     setAttr -keyable false -channelBox true($con+".beishu");
     string$chengchu_A=$con+"_multiplyDivide_A";
     string$chengchu_B=$con+"_multiplyDivide_B";
     
      string$chengchu_C=$con+"_multiplyDivide_C";
     
     string$chengchu_D=$con+"_multiplyDivide_D";
      string$chengchu_E=$con+"_multiplyDivide_E";
     string$chengchu_F=$con+"_multiplyDivide_F";
     int $ex=`objExists $chengchu_A`;//查询这个物体是否纯在
     if($ex==1){delete $chengchu_A;}
     shadingNode -asUtility multiplyDivide -n $chengchu_A;//创建乘除节点
     
     int $ex=`objExists $chengchu_B`;//查询这个物体是否纯在
     if($ex==1){delete $chengchu_B;}
     shadingNode -asUtility multiplyDivide -n $chengchu_B;//创建乘除节点
     
      int $ex=`objExists $chengchu_C`;//查询这个物体是否纯在
     if($ex==1){delete $chengchu_C;}
     shadingNode -asUtility multiplyDivide -n $chengchu_C;//创建乘除节点
     
     int $ex=`objExists $chengchu_D`;//查询这个物体是否纯在
     if($ex==1){delete $chengchu_D;}
     shadingNode -asUtility multiplyDivide -n $chengchu_D;//创建乘除节点
     
     
     int $ex=`objExists $chengchu_E`;//查询这个物体是否纯在
     if($ex==1){delete $chengchu_E;}
     shadingNode -asUtility multiplyDivide -n $chengchu_E;//创建乘除节点
     
     int $ex=`objExists $chengchu_F`;//查询这个物体是否纯在
     if($ex==1){delete $chengchu_F;}
     shadingNode -asUtility multiplyDivide -n $chengchu_F;//创建乘除节点
     
     
    connectAttr -f   ($con+".biyan") ($chengchu_A+".input1X");
    connectAttr -f   ($con+".beishu") ($chengchu_A+".input2X");
    connectAttr -f ($chengchu_A+".outputX") ($jiajian_s[$b]+".input3D[2].input3Dz");
    setAttr ($chengchu_B+".input2X") -1;
    connectAttr -f   ($con+".biyan") ($chengchu_B+".input1X");
    connectAttr -f ($chengchu_B+".outputX") ($jiajian_s[$a]+".input3D[2].input3Dz");
    
    
    connectAttr -f($con+".shang")  ($chengchu_C+".input1X");
    connectAttr -f($con+".xia")  ($chengchu_D+".input1X");
    setAttr  ($chengchu_D+".input2X") -1;

    connectAttr -f ($chengchu_C+".outputX") ($jiajian_s[$b]+".input3D[3].input3Dz");
    connectAttr -f ($chengchu_D+".outputX") ($jiajian_s[$a]+".input3D[3].input3Dz");

    connectAttr -f ($con+".shangxia")  ($jiajian_s[$b]+".input3D[4].input3Dz");
    connectAttr -f ($con+".shangxia")  ($jiajian_s[$a]+".input3D[4].input3Dz");
    
    connectAttr -f ($con+".gensui_rx_up")  ($chengchu_E+".input1X");
    connectAttr -f ($con+".gensui_ry_up")  ($chengchu_E+".input1Y");
    connectAttr -f ($con+".gensui_rz_up")  ($chengchu_E+".input1Z");
    
    connectAttr -f ($fk_c[$a]+".r")     ($chengchu_E+".input2");
    connectAttr -f ($chengchu_E+".output") ($Fk_[$a]+".r")   ; 
    
    
     connectAttr -f ($con+".gensui_rx_dw")  ($chengchu_F+".input1X");
    connectAttr -f ($con+".gensui_ry_dw")  ($chengchu_F+".input1Y");
    connectAttr -f ($con+".gensui_rz_dw")  ($chengchu_F+".input1Z");
    
    connectAttr -f ($fk_c[$b]+".r")     ($chengchu_F+".input2");
    connectAttr -f ($chengchu_F+".output") ($Fk_[$b]+".r")   ; 
     // parent $yanpi_UP_bn  $root_bn;
     // parent $yanpi_DW_bn  $root_bn;
 }
 
 setAttr -type "string" ($toubukongzhiqi+".eye_lip_ik") $ik_eye_ikHandle;
zxb_eye_lip_con_controller;
} 




//////////////////////////////////////////////////////////////嘴巴次级骨骼创建///////////////////////////////////////////////////////////////////////////
global proc string zxb_zuibajici_joint_proc(int$chongjian,string$qianzui)
{

  /*string $qvxianssa=`textFieldGrp -q -tx zxb_zairuqvxian `;*/
 string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
float $temp[]=`getAttr ($head_qvxian+".boundingBoxSize")`;//头的BOX
float $con_size=$temp[2]/70.0;//半径
string $xiaba_bn=`textFieldGrp -q -tx  UI_mouth_outer_wire  `;
string$name_lip=zxb_extract_Curves_proc(0,"lip","place",$xiaba_bn);
string$qvxiansaa[]=stringToStringArray($name_lip, " ");
select -r $qvxiansaa;
DeleteHistory;
string$nurbsSphere=$qianzui+"_nurbsSphere_Group";
string$Cluster=$qianzui+"_Cluster_Group";
string$hairfollicle=$qianzui+"_hairfollicle_Group";
string$joints=$qianzui+"_joint_Group";
string$temp_on_neme=$qianzui+"_temp_ciji_GRP";
string$Cluster_neme="";
zxb_ADD_kongzu_proc($nurbsSphere);
zxb_ADD_kongzu_proc($Cluster);
zxb_ADD_kongzu_proc($hairfollicle);
zxb_ADD_kongzu_proc($joints);
int $ex=`objExists "Face_Group"`;//查询这个物体是否纯在
if($ex==1)
  {
   parent ($joints) "head_all_bn_Group";
   parent $nurbsSphere "head_all_nurbsSphere_Group";
   parent ($hairfollicle) "head_all_hairfollicle";
   parent ($Cluster) "head_all_Cluster_Group";
  }else
      {
       zxb_ADD_kongzu_proc($temp_on_neme);
       parent ($joints) $temp_on_neme;
       parent $nurbsSphere $temp_on_neme;
       parent ($hairfollicle) $temp_on_neme;
       parent ($Cluster) $temp_on_neme;
       }

string $bianliang[]=$qvxiansaa;//选中嘴巴曲线
int$sssd=$chongjian;
//int$sssd=1;
/*string $qvxianssb=`textFieldGrp -q -tx zxb_zairuqvxianA `;
string$qvxiansbb[]=stringToStringArray($qvxianssb, " ");*/
if($sssd==1)
 { 
   select -r $qvxiansaa[0];
   duplicate -rr -n ($qvxiansaa[0]+"temp");
   select -r $qvxiansaa[1];
   duplicate -rr -n ($qvxiansaa[1]+"temp");
 }
string $kongzhi_qvxianA=($qvxiansaa[0]+"temp");
string $kongzhi_qvxianB=($qvxiansaa[1]+"temp");
string $qvxian_kong[];
clear$qvxian_kong;
if($sssd==1)
 {
   select -cl  ;
   int $panduan=`objExists $kongzhi_qvxianA`;//查询这个物体是否纯在
   if($panduan==1){select -add $kongzhi_qvxianA;}
   int $panduan=`objExists $kongzhi_qvxianB`;//查询这个物体是否纯在
   if($panduan==1){select -add $kongzhi_qvxianB;}
   $qvxian_kong=`ls -sl`;//选中嘴巴曲线   
  }
int $size_qvxian=size ($qvxian_kong);
//print $bianliang;
string $temp_shuzzu[];
clear $temp_shuzzu;
int $cv_size;

for($i=0;$i<size($bianliang);$i++) 
{
     string $qvxian=$bianliang[$i];
     string $qvxian_AAA="";
     if($sssd==1){$qvxian_AAA=$qvxian_kong[$i];}   
     float $temp_pos_A[]=`xform -q -ws -t ($qvxian+".cv[0]")`;
     select -cl  ;
     
    ///////////////////////创建跟骨骼///////////////////////////
    string$zuiba_bn_root=($bianliang[0]+"zuiba_bn_root");
    int $panduan=`objExists $zuiba_bn_root`;
    if($panduan==0)
      {
        joint -p 0 $temp_pos_A[1] $temp_pos_A[2] -n $zuiba_bn_root ;
        setAttr ($zuiba_bn_root+".drawStyle") 2;
        group -n ("zuiba_bn_grp");
        setAttr -l true { ($zuiba_bn_root+".ds") };
        parent ("zuiba_bn_grp") ("lip_joint_Group");
       }
    /////////////////创建子关节///////////////////////////////////////
    select -r ($qvxian+".cv[0:9999999999999]") ;
    string $qvxian_cv[]=`ls -sl -fl`;//选中点
    string $bn=($qvxian+"_UPbn_");
    if($i==1){$bn=($qvxian+"_DWbn_");}
    string $qvmian_plane=($qvxian+"_UP_plane_");
    if($i==1){$qvmian_plane=($qvxian+"_DW_plane_");} 
    string $qvmian_clust=($qvxian+"_UP_clust_");
    if($i==1){$qvmian_clust=($qvxian+"_DW_clust_");} 
    string $qvmian_con=($qvxian+"_UP_con_");
    if($i==1){$qvmian_con=($qvxian+"_DW_con_");} 
     string $qvmian_qvxian=($qvxian+"_UP_qvxian_");
    if($i==1){$qvmian_qvxian=($qvxian+"_DW_qvxian_");} 
     string $xing_bn[];
     clear $xing_bn;
     int$xuanhuan=0;
     int$xuanhuan_size=size($qvxian_cv);
     if($i==1){$xuanhuan=1;$xuanhuan_size=$xuanhuan_size-1;}
     int$bn_int=0;
    for($ii=$xuanhuan;$ii<$xuanhuan_size;$ii++) 
      {
      string $CVdian=$qvxian_cv[$ii];
      string $qvxian_bn=($qvxian+$bn+$ii);
      float $temp_pos_B[]=`xform -q -ws -t $CVdian`;
      select -r  $zuiba_bn_root;
      joint -p $temp_pos_B[0] $temp_pos_B[1] $temp_pos_B[2]-n  $qvxian_bn ;
      setAttr ($qvxian_bn+".radius") $con_size;
      $xing_bn[$bn_int]=$qvxian_bn;
      $bn_int=$bn_int+1;
      }
      // print  $xing_bn;
     //////////////////////////////////////////////创建曲线 //////////////////////////////////////////////////////
  
   if($sssd==0)
     {
      string $qvxian_D = $qvxian;
      float $kaishi_pos_A[]=`xform -q -ws -t  ($qvxian_D+".cv[0]")`;
      float $kaishi_pos_B[]=`xform -q -ws -t  ($qvxian_D+".cv[+"+(size($qvxian_cv)-1)+"]")`;
      int $panduan=`objExists $qvmian_qvxian`;
      if($panduan==1){ delete $qvmian_qvxian;}
      curve -d 1 -p $kaishi_pos_A[0] $kaishi_pos_A[1] $kaishi_pos_A[2] -p $kaishi_pos_B[0] $kaishi_pos_B[1] $kaishi_pos_B[2] -n $qvmian_qvxian; //创建曲线
     rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.01 $qvmian_qvxian;//重建曲线
     //////////////////坐标中心点的位置保证在0的位置////////////////
    float $temp_pos_A[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[3]")`;
     xform -ws -t 0  $temp_pos_A[1]  $temp_pos_A[2] ($qvmian_qvxian+".cv[3]");//中间点Z轴保证为0 
    /////////////创建曲线信息节点///////////////////////////
     int $panduan=`objExists ($qvxian_D+"qvxianzuijingdianjiedian")`;
     if($panduan==1){ delete ($qvxian_D+"qvxianzuijingdianjiedian");}
     createNode nearestPointOnCurve -n ($qvxian_D+"qvxianzuijingdianjiedian");//创建曲线最近点节点
     string $qvxian_D_shp[]=`listRelatives -s $qvxian_D`;
     connectAttr -force ($qvxian_D_shp[0]+".worldSpace[0]")  ($qvxian_D+"qvxianzuijingdianjiedian"+".inputCurve");//曲线链接到曲线信息节点
    ////////////点3的位置/////////////////////
    for($iii=0;$iii<10;$iii++)//点3的位置
       {
        float $temp_pos_D[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[3]")`;
        setAttr -type float3  ($qvxian_D+"qvxianzuijingdianjiedian.inPosition") $temp_pos_D[0] $temp_pos_D[1] $temp_pos_D[2];
        float $qvxian_pos[]=`getAttr ($qvxian_D+"qvxianzuijingdianjiedian.position")`;
        xform -ws -t 0 $qvxian_pos[1] $qvxian_pos[2] ($qvmian_qvxian+".cv[3]");
       }
     ///////////点2的位置///////////
    float $temp_pos_B[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[0]")`;
    float $qvxian_MM_pos[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[3]")`;
    xform -ws -t (($temp_pos_B[0]+$qvxian_MM_pos[0])/2) (($temp_pos_B[1]+$qvxian_MM_pos[1])/2)  (($temp_pos_B[2]+$qvxian_MM_pos[2])/2) ($qvmian_qvxian+".cv[2]");
    float $temp_pos_D[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[2]")`;
    setAttr -type float3  ($qvxian_D+"qvxianzuijingdianjiedian.inPosition") $temp_pos_D[0] $temp_pos_D[1] $temp_pos_D[2];
    float $qvxian_pos[]=`getAttr ($qvxian_D+"qvxianzuijingdianjiedian.position")`;
    xform -ws -t $qvxian_pos[0] $qvxian_pos[1] $qvxian_pos[2] ($qvmian_qvxian+".cv[2]");//点1的位置
    spaceLocator -p 0 0 0 -n ("temp_A");
    spaceLocator -p 0 0 0 -n ("temp_B");
    spaceLocator -p 0 0 0 -n ("temp_C");
    //float $temp_pos_B[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[0]")`;
    float $qvxian_MM_pos[]=`xform -q -ws -t  ($qvmian_qvxian+".cv[2]")`;
    xform -ws -t ($temp_pos_B[0]) ($temp_pos_B[1])  ($temp_pos_B[2]) ("temp_A");
    xform -ws -t $qvxian_MM_pos[0] $qvxian_MM_pos[1] $qvxian_MM_pos[2]  ("temp_B");
    string $yuesu_TEMP[]=`parentConstraint  ("temp_A") ("temp_B") ("temp_C")`;
    setAttr ($yuesu_TEMP[0]+".temp_AW0") 0.666;
    setAttr ($yuesu_TEMP[0]+".temp_BW1") 0.333;
    float $temp_pos_D[]=`xform -q -ws -t  ("temp_C")`;
    setAttr -type float3  ($qvxian_D+"qvxianzuijingdianjiedian.inPosition") $temp_pos_D[0] $temp_pos_D[1] $temp_pos_D[2];
    float $qvxian_pos[]=`getAttr ($qvxian_D+"qvxianzuijingdianjiedian.position")`;
    xform -ws -t $qvxian_pos[0] $qvxian_pos[1] $qvxian_pos[2] ($qvmian_qvxian+".cv[1]");//点1的位置
    delete ("temp_A") ("temp_B")("temp_C");
    ///////////点4的位置//////////////
    float $temp_posG[]=`xform -q -ws -t ($qvmian_qvxian+".cv[2]")`;
    xform  -ws -t ($temp_posG[0]*-1) $temp_posG[1] $temp_posG[2]  ($qvmian_qvxian+".cv[4]");//对称的位置  点3的位置
    ///////////点5的位置//////////////
    float $temp_posG[]=`xform -q -ws -t ($qvmian_qvxian+".cv[1]")`;
    xform  -ws -t ($temp_posG[0]*-1) $temp_posG[1] $temp_posG[2]  ($qvmian_qvxian+".cv[5]");//对称的位置  点3的位置
    /////////////////判断是否翻转曲线起始点/////////////////
    //string $qvxian_D = $qvxian;
    float $dian_temp_kaishi[]=`xform -q -ws -t ($qvmian_qvxian+".cv[0]")`;
    float $dian_temp_jiesu[]=`xform -q -ws -t ($qvmian_qvxian+".cv[6]")`;
    if($dian_temp_jiesu[0]>$dian_temp_kaishi[0])
      {  
       reverseCurve -ch 0 -rpo 1 ($qvmian_qvxian);
      }
   delete ($qvxian_D+"qvxianzuijingdianjiedian");
    
   }else 
          { 
           select -r $qvxian_AAA;
           rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 1 -s 4 -d 3 -tol 0.001 $qvxian_AAA;
           select -r $qvxian_AAA;
           DeleteHistory;
           rename $qvxian_AAA  ($qvmian_qvxian);
           }
 
   ///////////////////////////////////////////////////////////
   float $dian_temp_kaishi[];
   float$dian_temp_jiesu[];
   clear $dian_temp_kaishi  $dian_temp_jiesu;
   if( $size_qvxian!=2)
   { 
   select -r ($qvmian_qvxian+".cv[0:9999999999999]");
    string $qvxian_cv_eee[]=`ls -sl -fl`;//选中点
    float$size=size($qvxian_cv_eee);
    $dian_temp_kaishi=`xform -q -ws -t ($qvmian_qvxian+".cv[0]")`;
   $dian_temp_jiesu=`xform -q -ws -t ($qvmian_qvxian+".cv["+$size+"]")`;
   }
   else 
      { 
       select -r($qvmian_qvxian+".cv[0:9999999999999]"); 
       string $qvxian_cv_eee[]=`ls -sl -fl`;//选中点
       float$size=size($qvxian_cv_eee);
       $dian_temp_kaishi=`xform -q -ws -t ($qvmian_qvxian+".cv[0]")`;
       $dian_temp_jiesu=`xform -q -ws -t ($qvmian_qvxian+".cv["+$size+"]")`;
       if($dian_temp_jiesu[0]>$dian_temp_kaishi[0])
         { 
          reverseCurve -ch 0 -rpo 1 ($qvmian_qvxian);
          }
       select -r($qvmian_qvxian+".cv[0:9999999999999]"); 
     }
     
     ///////////////////////////////////放样曲面//////////////////////////////////////////////////////////////
    string $qvxian_cv_A[]=`ls -sl -fl`;//选中点
    $cv_size=size($qvxian_cv_A);
   $changdu=abs($dian_temp_kaishi[0]-$dian_temp_jiesu[0]);
   offsetCurve  -ch off -rn false -cb 2 -st true -cl true -cr 0 -d ($changdu*-0.01) -tol 0.01 -sd 5 -ugn false  ($qvmian_qvxian) ;
   rename ($qvmian_qvxian+"_A");
   offsetCurve  -ch off -rn false -cb 2 -st true -cl true -cr 0 -d ($changdu*0.01) -tol 0.01 -sd 5 -ugn false  ($qvmian_qvxian) ;
   rename ($qvmian_qvxian+"_B");
   loft -ch 0 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true  -n $qvmian_plane ($qvmian_qvxian+"_A")  ($qvmian_qvxian+"_B") ;
   delete  ($qvmian_qvxian+"_A") ($qvmian_qvxian+"_B") ($qvmian_qvxian);
 //////////////////////////创建毛囊附着/////////////////////////////
   int $panduan=`objExists ($qvmian_plane+"_closestPointOnSurface_temp")`;//查询这个物体是否纯在
   if($panduan==1){ delete($qvmian_plane+"_closestPointOnSurface_temp");}
   createNode "closestPointOnSurface" -n ($qvmian_plane+"_closestPointOnSurface_temp") ;
   string $sheps[]=`listRelatives -s $qvmian_plane`;
   connectAttr -force ($sheps[0]+".worldSpace[0]")  ($qvmian_plane+"_closestPointOnSurface_temp.inputSurface");
   parent$qvmian_plane("lip_nurbsSphere_Group");
   string $plane_Shape= $sheps[0];
   for($iii=0;$iii<size($xing_bn);$iii++) 
   {
       string $zuiba_bn=$xing_bn[$iii];
       string $bn_maonang_shep=($zuiba_bn+"_maonang_Shape");
       spaceLocator -p 0 0 0 -n ($zuiba_bn+"_loc");
       delete`parentConstraint  $zuiba_bn ($zuiba_bn+"_loc") `;
       setAttr ($zuiba_bn+"_loc.visibility") 0;
       setAttr -lock true ($zuiba_bn+"_loc.v");
       float $pos[]=`xform -q -ws -t $zuiba_bn `;
       setAttr -type float3 ($qvmian_plane+"_closestPointOnSurface_temp.inPosition") $pos[0] $pos[1]$pos[2];
       float $U=`getAttr ($qvmian_plane+"_closestPointOnSurface_temp.parameterU")`;
       float $V=`getAttr ($qvmian_plane+"_closestPointOnSurface_temp.parameterV")`;
       createNode "follicle" -n $bn_maonang_shep;//
       string $maonang[]=`listRelatives -p  $bn_maonang_shep`; //列出子物体 -c 列出子物体 -p  关节父物体-ad 所有子物体 - fullPath 全路径 -s 列出型节点
        string $bn_maonang=$maonang[0];
        parent  $bn_maonang ("lip_hairfollicle_Group");
        setAttr ($bn_maonang+".visibility") 0;
        setAttr -lock true ($bn_maonang+".v");
        connectAttr -force ($plane_Shape+".local") ($bn_maonang_shep+".inputSurface");
        connectAttr -force ($plane_Shape+".worldMatrix[0]") ($bn_maonang_shep+".inputWorldMatrix");
        connectAttr -f ($bn_maonang_shep+".outRotate") ($bn_maonang+".rotate");
        connectAttr -f ($bn_maonang_shep+".outTranslate") ($bn_maonang+".translate");
        setAttr ($bn_maonang_shep+".parameterU") $U;
        setAttr ($bn_maonang_shep+".parameterV") $V;
       parent ($zuiba_bn+"_loc")$bn_maonang;
       parentConstraint ($zuiba_bn+"_loc") $zuiba_bn;//父子约束
   }
   for($iii=1;$iii<($cv_size-1);$iii++) 
      {
        string $qvmian_dian=($qvmian_plane+".cv["+$iii+"][0:3]");
        select -r  $qvmian_dian ;
        CreateCluster;
        string $cu=($qvmian_plane+"_Handle_"+$iii);
        rename $cu;
        parent  $cu ("lip_Cluster_Group");
        $Cluster_neme+=$cu+" ";
        setAttr ($cu+".visibility") 0;
        setAttr -lock true ($cu+".v");
     }
   
   $temp_shuzzu[$i]=$qvmian_plane;
}
select -cl  ;
for($j=0;$j<size($temp_shuzzu);$j++) 
   {
   string $qvmian=$temp_shuzzu[$j];
   select -add ($qvmian+".cv[0][0:3]");
    }
CreateCluster;
string $cu_mingzi=($bianliang[0]+"__UP_plane_Handle_0");
rename $cu_mingzi;
parent  $cu_mingzi ("lip_Cluster_Group");
$Cluster_neme+=$cu_mingzi+" ";
setAttr ($cu_mingzi+".visibility") 0;
setAttr -lock true ($cu_mingzi+".v");
select -cl  ;
for($j=0;$j<size($temp_shuzzu);$j++) 
   {
   string $qvmian=$temp_shuzzu[$j];
   select -add ($qvmian+".cv["+($cv_size-1)+"][0:3]");
   }
CreateCluster;

string $cu_mingzi=($bianliang[1]+"_DW_plane__Handle_0");
rename $cu_mingzi;
parent  $cu_mingzi ("lip_Cluster_Group");
setAttr ($cu_mingzi+".visibility") 0;
setAttr -lock true ($cu_mingzi+".v");
$Cluster_neme+=$cu_mingzi+" ";

delete$qvxiansaa[0]$qvxiansaa[1] ;
return $Cluster_neme;
}

////////////////////////////////////////////////////////////////////
global proc string zxb_extract_Curves_proc(int$a,string$mingzi,string$qianzui,string$xian_A)//int 区分线段的平均值或者法线朝向 $mingzi名字 $qianzui前缀 $xian_A 线段名称
{

string$xian=$xian_A;
//string $xian=`textFieldGrp -q -tx  zxb_ganjie `;
string$Axianxian=$qianzui;
string$mingzi=$mingzi;
string$qvxianss[]= stringToStringArray($xian, " ");//字符串转化数组
string $bianliang[]=$qvxianss;//提取曲线名字
string$temp_qvxian[];
clear $temp_qvxian;
int $nemt=`tokenize $bianliang[0]"."  $temp_qvxian`;//分离字符串存到变量
string$moxing=$temp_qvxian[0];
select -r $bianliang;
ConvertSelectionToVertices;
string $dingdian[]=`ls -sl -fl`;


      string$R_cv="";
      string$L_cv="";
     string$vtxs[]=$dingdian;
     float$dd=-100000000000000;
     float$xx=1000000000000000;
     string$dian_L="";
     string$dian_R="";
     for ($i=0;$i<size($vtxs);$i++)
          {
           string$vtx=$vtxs[$i];
           float$bn_pos[]=`xform -q -ws -t $vtx`;
           if($bn_pos[0]>$dd)
             {
             $dd=$bn_pos[0];
             $dian_L=$vtx;
             }
             if($bn_pos[0]<$xx)
             {
             $xx=$bn_pos[0];
             $dian_R=$vtx;
             }
             
           }
           
           
     $L_cv=$dian_L;   
     $R_cv=$dian_R;
 float $R_POS[]=`xform -q -ws -t $R_cv`; 
 string$qvxian_mingzi=$Axianxian+"_temp_curve";
  select -r $qvxianss;
  polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $qvxian_mingzi;
 DeleteHistory;
 float$pamte=zxb_return_curve_U($R_POS[0],$R_POS[1],$R_POS[2],$qvxian_mingzi);
 select -r ($qvxian_mingzi+".u["+$pamte+"]") ;
float $tempp_POS[]=`xform -q -ws -t $dingdian[0]`; 
int$jisuan=size($dingdian)-1;
float $tempp_POS_A[]=`xform -q -ws -t $dingdian[$jisuan]`; 
float $R_POaS=$R_POS[0]+$R_POS[1]+$R_POS[2];
float $R_PObS=$tempp_POS[0]+$tempp_POS[1]+$tempp_POS[2];
if($R_POaS!=$R_PObS)
  {
    moveNurbsCurveSeam;
   }
 

 select -r ($qvxian_mingzi+".cv[0:999999999]");
 
 string $qvxian_A[]=`ls -sl -fl`;
 
 
string$dianLL="";
float $cv_pos[]=`xform -q -ws -t $L_cv`;
float$maga=1000000000000;
     
for($iii=0;$iii<size($qvxian_A);$iii++)
   { 
     string$mag_cv=$qvxian_A[$iii];
     float $mag_po[]=`xform -q -ws -t $mag_cv`;
     float $weizhi=mag(<<$cv_pos[0],$cv_pos[1],$cv_pos[2]>>-<< $mag_po[0] ,$mag_po[1] ,$mag_po[2]>>);////////计算距离
     if($weizhi<$maga){$maga=$weizhi;$dianLL=$mag_cv;}
     } 
    
//print $dianLL;
  string$ccv[];
  clear $ccv;
  int $nemt=`tokenize $dianLL"[" $ccv`;//分离字符串存到变量
   int $nemt=`tokenize $ccv[1]"]" $ccv`;//分离字符串存到变量
  string$shu=$ccv[0];
 
 
 int$qvxiancv_size=size($qvxian_A);
int$temp_a=$shu;

float$exa=0;
float$exb=0;


if($a==0)
{
select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
$exb=`zxb_qvfengshangzi`;

select -r ($qvxian_mingzi+".cv[0:999999999]");
select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
$exa=`zxb_qvfengshangzi`;
}
if($a==1)
 {
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $exa=zxb_normal_pingjunshu($moxing);
  
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $exb=`zxb_normal_pingjunshu($moxing)`;
  }


string$up_qvxiancvs[];
clear$up_qvxiancvs;
string$dw_qvxiancvs[];
clear$dw_qvxiancvs;



if($exb>$exa)
  {
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
 $dw_qvxiancvs =`ls -sl -fl`;
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $up_qvxiancvs =`ls -sl -fl`;
  }
if($exa>$exb)
  {
  select -r ($qvxian_mingzi+".cv[0:999999999]");
  select -d  ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $up_qvxiancvs =`ls -sl -fl`;
  select -r ($qvxian_mingzi+".cv[0:"+$temp_a+"]");
  $dw_qvxiancvs=`ls -sl -fl`;
   }
string$UP_zuijing="";
string$DW_zuijing="";


for($o=0;$o<2;$o++)
{
    string$temp_suzu[];
    clear$temp_suzu;
   if($o==0){$temp_suzu=$up_qvxiancvs;}
   if($o==1){$temp_suzu=$dw_qvxiancvs;}
   for($i=0;$i<size($temp_suzu);$i++)
    {
     string$temp_cv=$temp_suzu[$i];
     float $cv_pos[]=`xform -q -ws -t $temp_cv`;
     float$mag=1000000000000;
     string$dian="";
     for($ii=0;$ii<size($dingdian);$ii++)
        { 
         string$mag_cv=$dingdian[$ii];
         float $mag_po[]=`xform -q -ws -t $mag_cv`;
         float $weizhi=mag(<<$cv_pos[0],$cv_pos[1],$cv_pos[2]>>-<< $mag_po[0] ,$mag_po[1] ,$mag_po[2]>>);////////计算距离
         if($weizhi<$mag){$mag=$weizhi;$dian=$mag_cv+" ";}
         } 
     if($o==0){$UP_zuijing+=$dian;}
     if($o==1){$DW_zuijing+=$dian;}  
     }
    
 }   
string$up_zuijingdw[]= stringToStringArray($UP_zuijing, " ");//字符串转化数组
string$dw_zuijingdw[]= stringToStringArray($DW_zuijing, " ");//字符串转化数组       
string$head_qvxian=$Axianxian+"_"+$mingzi+"_UP";//open  
select -r $up_zuijingdw;
select -add $R_cv;
select -add $L_cv;
ConvertSelectionToContainedEdges;
polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $head_qvxian;

string$head_qvxian_b=$Axianxian+"_"+$mingzi+"_DW";//open
select -r $dw_zuijingdw;
select -add $R_cv;
select -add $L_cv;
ConvertSelectionToContainedEdges;
polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $head_qvxian_b;


string$temp_mingzi="";
$temp_mingzi+=$head_qvxian+" "+$head_qvxian_b+" ";
delete $qvxian_mingzi;



string$dian_LRA=$head_qvxian+".cv[0]";
float $pos_A[]=`xform -q -ws -t$dian_LRA`;
string$dian_LRB=$head_qvxian_b+".cv[0]";
float $pos_B[]=`xform -q -ws -t $dian_LRB`;

if($pos_A[0]!=$pos_B[0]){reverseCurve -ch 1 -rpo 1 $head_qvxian;}


 return $temp_mingzi;
}

global proc  zxb_button_lipjoint_proc()
{
  string$Cluster=zxb_zuibajici_joint_proc(0,"lip"); 
  string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
  zxb_ADD_shuxing_string_proc($head_qvxian,"lip_Cluster");
  setAttr -type "string"($head_qvxian+".lip_Cluster") $Cluster;
}




///////////////////////////////////////嘴巴次级控制器///////////////////////////////////////////////////


global proc zxb_child_object_proc(string$mode_ss,string$head_bn_ss,string$all_bn_ss,int$root_ss,int$duicheng_ss,int$fanxiang_ss,int$maonang_ss)
{//////////////已知项//////////////////模型//////////////旋转物体////////所有次级骨骼或者簇///控制旋转/////////对称///////////////反向 ////////毛囊

int$xuanzhuan=$root_ss;
int$duicheng= $duicheng_ss;
int$dingweiqi_fanxiang= $fanxiang_ss;
int$maonang_fuzhao=$maonang_ss;
string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;

string $toubu_boj=$mode_ss;//模型
string $fangxiang_bn =$head_bn_ss;//骨骼

string $cijibn_sss=$all_bn_ss;//次级骨骼
string$cijibn_ss[]=stringToStringArray($cijibn_sss, " ");
zxb_ADD_kongzu_proc("head_follow_loc_Group");
zxb_ADD_kongzu_proc("head_follow_curve_Group");

$ex=`objExists ("Face_Group")`;
if($ex==1)
  {
    string $temp_fu[]=`listRelatives -p ("head_follow_loc_Group")`; 
    $ex_a=`objExists $temp_fu[0]`; 
    if($ex_a==0)
       {
         parent ("head_follow_loc_Group")("head_all_loc_Group");
         parent ("head_follow_curve_Group")("head_all_curve_Group");
        }
   
   }else
       {zxb_ADD_kongzu_proc("lip_temp_ciji_GRP");
         parent ("head_follow_loc_Group")("lip_temp_ciji_GRP");
         parent ("head_follow_curve_Group")("lip_temp_ciji_GRP");
        }

string $bianliang[]=$cijibn_ss;//选中簇
string $head_bn=$fangxiang_bn;//头部骨骼
string$mensh=$toubu_boj;//模型
int$maonang=$maonang_fuzhao;
//int $ex;//判断
int $ex_A=$xuanzhuan;//判断是否控制簇的旋转
int $ex_B=$duicheng;//判断是否控制器左右对称的位移
int $x_C=$dingweiqi_fanxiang;//判断定位器是否反向控制器旋转
int$vis=`getAttr ($mensh+".v") `;

select -r $mensh;
channelBoxCommand -unlock ;
CBunlockAttr ($mensh+".v");
setAttr  ($mensh+".visibility") 1;
select -cl  ;
string $mash_zi_A[]=`listRelatives -s $mensh `; 
string $mash_shape_A=$mash_zi_A[0];
//////////////////////////////////////////
string $root_grp=($mensh+"_grp");//总组
string $qvxian_grp=($mensh+"_qvxian_grp");//总组


float $temp[]=`getAttr ($head_qvxian+".boundingBoxSize")`;//头的BOX
float $con_size=$temp[2]/50.0;//半径

$ex=`objExists $root_grp`;
if($ex==0){group -empty -n $root_grp ;parent $root_grp ("head_follow_curve_Group");}//创建组

  $ex=`objExists $qvxian_grp`;
if($ex==0)
   {
       group -empty -n $qvxian_grp ;
       setAttr ($qvxian_grp+".visibility") 0;
       setAttr -lock true ($qvxian_grp+".v"); 
       parent $qvxian_grp ("head_follow_curve_Group");
     }//创建组


for ($y=0;$y<size($bianliang);$y++)
{ //////////////////////////需要的变量/////////////////////////////////////
   string $cu=$bianliang[$y];//簇
  
   string $cu_loc_temp=($cu+"_loc");
   string $cu_loc_grp=($cu+"_loc_grp");
   string $cu_loc_grp_B=($cu+"_loc_grp_B");
   string $cu_loc_grp_A=($cu+"_loc_grp_A");
   string $cu_con=($cu+"_con");
   
   string $cu_con_Grp_A=($cu+"_con_grp_A");
   string $cu_con_Grp_B=($cu+"_con_grp_B");
   string $cu_con_Grp_C=($cu+"_con_grp_C");
   string $cu_con_Grp_D=($cu+"_con_grp_D");
   string $cu_con_Grp_E=($cu+"_con_grp_E");
   string $cu_con_Grp_F=($cu+"_con_grp_F");
   string $cu_con_Grp_G=($cu+"_con_grp_G");
   
   
   
   string $cu_con_Grp_ROT=($cu+"_con_grp_ROT");
   string $cu_con_Grp_REV=($cu+"_con_grp_REV");
   string $cu_con_Grp=($cu+"_con_grp");
   
   
    string$loc_rot=("head_ciji_loc_rot");
   string$loc_rot_grp=($loc_rot+"_grp");
    string$loc_follow=($loc_rot+"_follow");
    string$loc_follow_grp=($loc_rot+"_follow_grp");
   
   ///////////////创建控制簇的定位器  位置 缩放//////////////////////////////////
   spaceLocator -p 0 0 0 -n  $cu_loc_temp;
   group -n $cu_loc_grp;
   group -n $cu_loc_grp_B;
   group -n $cu_loc_grp_A;
   
  setAttr ($cu_loc_temp+".visibility") 0;
  setAttr -lock true  ($cu_loc_temp+".v");
   
  ////////////控制整体旋转 缩放 位移 的定位器//////////////// 
   
    $ex=`objExists $loc_rot`;
   if($ex==0)
   {
    spaceLocator -p 0 0 0 -n  $loc_rot;
    group -n $loc_rot_grp;
    parent $loc_rot_grp $root_grp;
    setAttr ($loc_rot_grp+".visibility") 0;
    setAttr -lock true ($loc_rot_grp+".v");
    
    
    spaceLocator -p 0 0 0 -n  $loc_follow;
      int$temp_panduan=`objExists $loc_follow_grp`;
      if($temp_panduan==1){delete $loc_follow_grp;}
    group -n $loc_follow_grp;
    delete`pointConstraint $head_bn $loc_follow_grp`;
    parent $loc_follow_grp ("head_follow_loc_Group");
    //parent $loc_follow_grp $head_bn;
    parentConstraint $head_bn $loc_follow_grp ;
    scaleConstraint -mo $head_bn $loc_follow_grp;
    setAttr ($loc_follow_grp+".visibility") 0;
    setAttr -lock true ($loc_follow_grp+".v");
    parentConstraint $loc_follow $loc_rot;
     scaleConstraint $loc_follow $loc_rot;
     }
   /////////////////////创建控制器///////////////////////////////
   zxb_chuangjianqiuxingkongzhiqi($cu_con,$con_size);
   group -n $cu_con_Grp_A;
   group -n $cu_con_Grp_B;
   group -n $cu_con_Grp_C;
   group -n $cu_con_Grp_D;
   group -n $cu_con_Grp_E;
   group -n $cu_con_Grp_F;
   group -n $cu_con_Grp_G;
   group -n $cu_con_Grp_REV;
   group -n  $cu_con_Grp_ROT;
   group -n $cu_con_Grp;
   delete`parentConstraint $cu $cu_con_Grp`;
  
   parent $cu_con_Grp $root_grp;
   
   
   
   ///////////////////////被头部约束的定位旋转 缩放连接到控制器////////////////////////////////
    connectAttr -force ($loc_rot+".r") ($cu_con_Grp+".r");
    connectAttr -force ($loc_rot+".s") ($cu_con_Grp+".s");
     delete`parentConstraint $cu_con $cu_loc_grp_A`;
    float $pos_temp[]=`xform -q -ws -t $cu_loc_temp`;
    if($ex_B==1)
    {
      if($pos_temp[0]<-0.001)
      {
       setAttr ($cu_con_Grp_ROT+".scaleZ") -1;
       setAttr ($cu_loc_grp_B+".scaleZ") -1;
      }   
    } 
   
   /////////////////控制器的3个组连接簇的最上层组///////////////////////
   addAttr -ln "zhouxiangX"  -at double  -dv 0 -k 1  $cu_con;
   addAttr -ln "zhouxiangY"  -at double  -dv 0 -k 1  $cu_con;
   addAttr -ln "zhouxiangZ"  -at double  -dv 0 -k 1  $cu_con;
   setAttr -keyable false -channelBox true ($cu_con+".zhouxiangZ");
   setAttr -keyable false -channelBox true ($cu_con+".zhouxiangX");
   setAttr -keyable false -channelBox true ($cu_con+".zhouxiangY");
   connectAttr -force ($cu_con+".zhouxiangX")  ($cu_con_Grp_ROT+".rx");
   connectAttr -force ($cu_con+".zhouxiangY")  ($cu_con_Grp_ROT+".ry");
   connectAttr -force ($cu_con+".zhouxiangZ")  ($cu_con_Grp_ROT+".rz");

  if($x_C==1)
      {
          
          float$xuanzhuan_temp[]=`xform -q -ws -t $cu_loc_grp_B`;
          if($xuanzhuan_temp[0]<0)
             {
              string$xuanzhuan_multiplyDivide=($cu+"xuanzhuan_multiplyDivide_"+$y);
              int$exaa=`objExists $xuanzhuan_multiplyDivide`;
              if($exaa==1){delete $xuanzhuan_multiplyDivide;}
              shadingNode -asUtility multiplyDivide -n $xuanzhuan_multiplyDivide;//创建乘除节点 
              setAttr  -type float3 ($xuanzhuan_multiplyDivide+".input2") -1 -1 -1 ;
              connectAttr -force ($cu_con+".zhouxiangX") ($xuanzhuan_multiplyDivide+".input1X");
              connectAttr -force ($cu_con+".zhouxiangY") ($xuanzhuan_multiplyDivide+".input1Y");
              connectAttr -force ($cu_con+".zhouxiangZ") ($xuanzhuan_multiplyDivide+".input1Z");
              
              connectAttr -force  ($xuanzhuan_multiplyDivide+".outputX") ($cu_loc_grp_B+".rx");
              connectAttr -force  ($xuanzhuan_multiplyDivide+".outputY") ($cu_loc_grp_B+".ry");
              connectAttr -force  ($xuanzhuan_multiplyDivide+".outputZ")($cu_loc_grp_B+".rz");
            }else
                 {   connectAttr -force ($cu_con+".zhouxiangX")  ($cu_loc_grp_B+".rx");
                     connectAttr -force ($cu_con+".zhouxiangY")  ($cu_loc_grp_B+".ry");
                     connectAttr -force ($cu_con+".zhouxiangZ")  ($cu_loc_grp_B+".rz");
                 }

  
      }
        else{
              connectAttr -force ($cu_con+".zhouxiangX")  ($cu_loc_grp_B+".rx");
              connectAttr -force ($cu_con+".zhouxiangY")  ($cu_loc_grp_B+".ry");
              connectAttr -force ($cu_con+".zhouxiangZ")  ($cu_loc_grp_B+".rz");
               }
   
   ///////////////////////控制器的3个组 控制控制簇簇的定位器////////////////////////////////////
   
  
  
   
   string $jiajianjiedian_A=($cu+"plusMinusAverage_A"+$y);
   string $jiajianjiedian_B=($cu+"plusMinusAverage_B"+$y);
   string $jiajianjiedian_C=($cu+"plusMinusAverage_C"+$y);
    string $jiajianjiedian_D=($cu+"plusMinusAverage_D"+$y);
   string $jiajianjiedian_E=($cu+"plusMinusAverage_E"+$y);
   string $jiajianjiedian_F=($cu+"plusMinusAverage_F"+$y);
     string $jiajianjiedian_G=($cu+"plusMinusAverage_G"+$y);
     
    addAttr -ln "zhaodao_trs"  -at bool  -dv 0 -k 1  $cu_con;
    setAttr -keyable false -channelBox true ($cu_con+".zhaodao_trs");
    
    addAttr -ln "zhaodao_rot"  -at bool  -dv 0 -k 1  $cu_con;
    setAttr -keyable false -channelBox true ($cu_con+".zhaodao_rot");
    
    addAttr -ln "zhaodao_scl"  -at bool  -dv 0 -k 1  $cu_con;
    setAttr -keyable false -channelBox true ($cu_con+".zhaodao_scl");
    
  
   int $panduan_temp=`objExists $jiajianjiedian_A`;
   if($panduan_temp==1){delete $jiajianjiedian_A;}
   shadingNode -asUtility plusMinusAverage -n $jiajianjiedian_A;//创建加减节点
   
   int $panduan_temp=`objExists $jiajianjiedian_B`;
   if($panduan_temp==1){delete $jiajianjiedian_B;}
   shadingNode -asUtility plusMinusAverage -n $jiajianjiedian_B;//创建加减节点
   
   int $panduan_temp=`objExists $jiajianjiedian_C`;
   if($panduan_temp==1){delete $jiajianjiedian_C;}
   shadingNode -asUtility plusMinusAverage -n $jiajianjiedian_C;//创建加减节点
   
   
      

   
     addAttr -ln "zhaodao_trs"  -at bool  -dv 0  $jiajianjiedian_A;
     addAttr -ln "zhaodao_rot"  -at bool  -dv 0 $jiajianjiedian_B;
     addAttr -ln "zhaodao_scl"  -at bool  -dv 0  $jiajianjiedian_C;
    
     connectAttr -force ($cu_con+".zhaodao_trs") ($jiajianjiedian_A+".zhaodao_trs")  ;
     connectAttr -force ($cu_con+".zhaodao_rot") ($jiajianjiedian_B+".zhaodao_rot")  ;
     connectAttr -force ($cu_con+".zhaodao_scl") ($jiajianjiedian_C+".zhaodao_scl")  ;
   
   select -r $cu_con $cu_con_Grp_A  $cu_con_Grp_B  $cu_con_Grp_C $cu_con_Grp_D $cu_con_Grp_E  $cu_con_Grp_F $cu_con_Grp_G;
   string $bianliang_tempA[]=`ls -sl`;//
   
   for($i=0;$i<size($bianliang_tempA);$i++) 
   {
   string$temp_=$bianliang_tempA[$i];
   connectAttr -force ($temp_+".t")  ($jiajianjiedian_A+".input3D["+$i+"]");
   connectAttr -force ($temp_+".r")  ($jiajianjiedian_B+".input3D["+$i+"]");
   
   if($i==0)
     {
         connectAttr -force ($temp_+".s")  ($jiajianjiedian_C+".input3D["+$i+"]");  
   
      }else
      {
         int $panduan_temp=`objExists ($temp_+"_temp")`;
        if($panduan_temp==1){delete ($temp_+"_temp");}
        shadingNode -asUtility plusMinusAverage -n ($temp_+"_temp");//创建加减节点
        connectAttr -force ($temp_+".s")  ($temp_+"_temp.input3D[0]");  
        setAttr -type float3 ($temp_+"_temp.input3D[1]") 1 1 1;
        setAttr ($temp_+"_temp.operation") 2;
        connectAttr -force ($temp_+"_temp.output3D") ($jiajianjiedian_C+".input3D["+$i+"]");
      }

   }
   
   connectAttr -force  ($jiajianjiedian_C+".output3D") ($cu_loc_temp+".s");
   connectAttr -force  ($jiajianjiedian_B+".output3D") ($cu_loc_temp+".r");
   connectAttr -force  ($jiajianjiedian_A+".output3D") ($cu_loc_temp+".t");
   
   
   ///////////////////////曲线跟随脸/////////////////////////////////
   if($maonang==0)///////////////////////如果是曲线制控制器的组/////////////////////////////
     {
      string $qvxian_wangge=($cu+"curveFromMeshEdge_pos"+$y); 


      string $wangge_zuijingdian=($cu+"closestPointOnMesh"+$y);
      string $qvxian_A=($cu+"_qvxian_"+$y);
   
      string $mash_zi[]=`listRelatives -s $mensh `; 
      string $mash_shape=$mash_zi[0];
   
      int $panduan_temp=`objExists $qvxian_wangge`;
      if($panduan_temp==1){delete $qvxian_wangge;}
      createNode "curveFromMeshEdge" -n $qvxian_wangge;
   
      connectAttr -force ($mash_shape+".worldMesh[0]") ($qvxian_wangge+".inputMesh");
      curve -d 1 -p 0 0 0 -p 1 0 0 -k 0 -k 1 -n($qvxian_A);//创建曲线
      parent $qvxian_A $qvxian_grp;
     
      string $qvxian_shape[]=`listRelatives -s $qvxian_A `; 
      string $qvxian_A_shape=$qvxian_shape[0];
      connectAttr ($qvxian_wangge+".outputCurve") ($qvxian_A+".create");//网格连接到曲线



      int $panduan_temp=`objExists $wangge_zuijingdian`;
      if($panduan_temp==1){delete $wangge_zuijingdian;}

      createNode "closestPointOnMesh" -n $wangge_zuijingdian;//创建模型最近点节点
      connectAttr -force ($mash_shape+".worldMesh[0]") ($wangge_zuijingdian+".inMesh");
  
     float $temp_pos_BB[]=`xform -q -ws -t $cu_con_Grp`;
     setAttr -type float3 ($wangge_zuijingdian+".inPosition") $temp_pos_BB[0] $temp_pos_BB[1] $temp_pos_BB[2];
     int $inddex=`getAttr ($wangge_zuijingdian+".closestVertexIndex")`;
     string $dian_neme=($mensh+".vtx["+$inddex+"]");
     select -r  $dian_neme;
     ConvertSelectionToEdges;
     string $bianliang_B[]=`ls -sl -fl`;//
     string $temp_xian_a[];
     int $temp_shuzi=`tokenize  $bianliang_B[0]  "[" $temp_xian_a`;
     $temp_shuzi=`tokenize  $temp_xian_a[1]  "]" $temp_xian_a`;
     int $edge=$temp_xian_a[0];//提取到模型的边索引
     //setAttr ($qvxian_wangge+".edgeIndex[0]")  $edge;
 
     //select -r $cu_con;   
     addAttr -ln "edgeindex"  -at long  -dv $edge -k 1  $cu_con;//边索引报存到变量
     addAttr -ln "parameter"  -at double  -dv 0.5 -k 1  $cu_con;
     setAttr -keyable false -channelBox true ($cu_con+".edgeindex");
     setAttr -keyable false -channelBox true ($cu_con+".parameter");
     connectAttr -force ($cu_con+".edgeindex")  ($qvxian_wangge+".edgeIndex[0]") ;//曲线跟随网格
     
     //print  $dian_neme;
   //print  $temp_xian_a[0];
   
    int $panduan_temp=`objExists ($cu_con+"_pointOnCurveInfo_grppos")`;
    if($panduan_temp==1){delete ($cu_con+"_pointOnCurveInfo_grppos");}
    createNode "pointOnCurveInfo" -n ($cu_con+"_pointOnCurveInfo_grppos");//创建曲线最近点节点
    connectAttr -force ( $qvxian_A_shape+".worldSpace[0]") ($cu_con+"_pointOnCurveInfo_grppos.inputCurve");
    connectAttr -f  ($cu_con+"_pointOnCurveInfo_grppos.position") ($cu_con_Grp+".translate");//控制控制器的最上层的组
    
    setAttr ($cu_con+"_pointOnCurveInfo_grppos.turnOnPercentage") 1;
    connectAttr -force ($cu_con+".parameter")  ($cu_con+"_pointOnCurveInfo_grppos.parameter");//控制器的属性控制器曲线的parameter
      delete $wangge_zuijingdian;
  }
  else///////////////////////如果是毛囊控制控制器的组/////////////////////////////
      {//////////////////////创建毛囊连接到模型/////////////////////////
          string$maonang_name=($cu+$y+"_maonangShape");
         createNode "follicle" -n $maonang_name;//创建毛囊
         select -r $maonang_name;
         connectAttr -f ($mash_shape_A+".outMesh") ($maonang_name+".inputMesh");
         connectAttr -f ($mash_shape_A+".worldMatrix[0]") ($maonang_name+".inputWorldMatrix");
         string $mangnang_T[]=`listRelatives -p $maonang_name`; 
         string$mangnang_weiyi=$mangnang_T[0];
         connectAttr -f ($maonang_name+".outTranslate") ($mangnang_weiyi+".translate");
         connectAttr -f ($maonang_name+".outRotate") ($mangnang_weiyi+".rotate");
       
       /////////////////////////////////////
        string $wangge_zuijingdian=($cu+"closestPointOnMesh"+$y);
        int $panduan_temp=`objExists $wangge_zuijingdian`;
        if($panduan_temp==1){delete $wangge_zuijingdian;}

        createNode "closestPointOnMesh" -n $wangge_zuijingdian;//创建模型最近点节点
        connectAttr -force ($mash_shape_A+".worldMesh[0]") ($wangge_zuijingdian+".inMesh");
        
         
        spaceLocator -p 0 0 0 -n ($maonang_name+"_temp_loc");
        group -n ($maonang_name+"_temp_loc_A");
        delete`pointConstraint  $cu_con_Grp ($maonang_name+"_temp_loc_A")`;
        delete`normalConstraint $mensh ($maonang_name+"_temp_loc_A")`;
        delete`geometryConstraint $mensh ($maonang_name+"_temp_loc_A")`;
        setAttr ($maonang_name+"_temp_loc.translateX") 0.01;

        float$pos_temp_weizhi[]=`xform -ws -q -t  ($maonang_name+"_temp_loc")`;
        setAttr -type float3 ($wangge_zuijingdian+".inPosition") $pos_temp_weizhi[0] $pos_temp_weizhi[1] $pos_temp_weizhi[2];
        float$U=`getAttr ($wangge_zuijingdian+".parameterU")`;
        float$V=`getAttr ($wangge_zuijingdian+".parameterV")`;
        delete ($maonang_name+"_temp_loc_A");
        setAttr($maonang_name+".parameterV") $V;
        setAttr($maonang_name+".parameterU") $U;//给毛囊的uv赋值
        
        
        string$maonangzu=($mensh+"_maonang_grp");
        $ex=`objExists $maonangzu`;
        if($ex==0)
          {
              group -empty -n $maonangzu ;
              setAttr ($maonangzu+".visibility") 0;
              setAttr -lock true ($maonangzu+".v");
          }//创建组
       
        parent $mangnang_weiyi $maonangzu;
        connectAttr -f  ($mangnang_weiyi+".t")  ($cu_con_Grp+".translate") ;//控制控制器的最上层的组
          delete $wangge_zuijingdian;
       }


   int $panduan_temp=`objExists ($cu+"_temp_fanxiangA")`;
   if($panduan_temp==1){delete ($cu+"_temp_fanxiangA");}
    shadingNode -asUtility plusMinusAverage -n ($cu+"_temp_fanxiangA");//创建加减节点
    int $panduan_temp=`objExists ($cu+"_temp_fanxiangmultiplyDivideA")`;
    if($panduan_temp==1){delete ($cu+"_temp_fanxiangmultiplyDivideA");}
    shadingNode -asUtility multiplyDivide -n ($cu+"_temp_fanxiangmultiplyDivideA");//创建乘除节点
    setAttr -type float3($cu+"_temp_fanxiangmultiplyDivideA.input2") -1 -1 -1;
    connectAttr -force ($cu+"_temp_fanxiangA.output3D") ($cu+"_temp_fanxiangmultiplyDivideA.input1");
    connectAttr -force  ($cu+"_temp_fanxiangmultiplyDivideA.output") ($cu_con_Grp_REV+".t");

   for($i=0;$i<size($bianliang_tempA);$i++) 
   {
     connectAttr -force   ($bianliang_tempA[$i]+".t") ($cu+"_temp_fanxiangA.input3D["+$i+"]");
    }

   //string $cu_t[]=`listRelatives -p  $cu`; 
   $ex=`objExists ("head_follow_loc_Group")`;//查询这个物体是否纯在
   if($ex==1){parent $cu_loc_grp_A ("head_follow_loc_Group");}
   //parent $cu  $cu_loc_temp;
   pointConstraint  $cu_loc_temp $cu ;
   scaleConstraint -mo  $cu_loc_temp $cu ;
   if($ex_A==1){ orientConstraint -mo  $cu_loc_temp $cu ;}


 }
 setAttr ($mensh+".v") $vis ;
}



 

global proc zxb_chuangjianqiuxingkongzhiqi(string  $cu_con,float $con_size)
{

 ///////////////////////////////创建控制器//////////////////////////////////
   circle -c 0 0 0 -nr 0 1 0 -sw 360 -r $con_size -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n$cu_con ; 
    string $qvxian_shape[]=`listRelatives -s  ($cu_con )`; 
    setAttr ($qvxian_shape[0]+".overrideEnabled") 1;
    setAttr ($qvxian_shape[0]+".overrideColor")22;
   duplicate -rr -n ($cu_con+"temp");
   duplicate -rr -n ($cu_con+"temp_A");
   select -r($cu_con+"temp_A");
   rotate -r -os -fo 0 0 90 ;
   FreezeTransformations;
    select -r($cu_con+"temp");
   rotate -r -os -fo 90 0 90 ;
   FreezeTransformations;
   string $qvxian_shape[]=`listRelatives -s  ($cu_con+"temp")`; 
   setAttr ($qvxian_shape[0]+".overrideEnabled") 1;
   setAttr ($qvxian_shape[0]+".overrideColor")22;
   select -r $qvxian_shape[0];
   select -add $cu_con;
   parent -r -s ;
   delete ($cu_con+"temp");
   string $qvxian_shape[]=`listRelatives -s  ($cu_con+"temp_A")`; 
   setAttr ($qvxian_shape[0]+".overrideEnabled") 1;
   setAttr ($qvxian_shape[0]+".overrideColor")22;
   select -r $qvxian_shape[0];
   select -add $cu_con;
   parent -r -s ;
   delete ($cu_con+"temp_A");
   select -r $cu_con;
   
   }
   
   
   
global proc zxb_secondary_controller()
{
  string $head_controller=`textFieldGrp -q -tx UI_head_controller `;
  string$bn_ss=`getAttr ($head_controller+".lip_Cluster")`;
  string $head_mode=`textFieldGrp -q -tx UI_head_mode `;
  string $head_joinr=`textFieldGrp -q -tx UI_head_bn `;
  zxb_child_object_proc($head_mode,$head_joinr,$bn_ss,0,1,0,0); 


}

/////////创建眼眼皮IK控制器

global proc zxb_eye_lip_con_controller()
{
  string $head_controller=`textFieldGrp -q -tx UI_head_controller `;
  string$bn_ss=`getAttr ($head_controller+".eye_lip_ik")`;
  string $head_mode=`textFieldGrp -q -tx UI_head_mode `;
  string $head_joinr=`textFieldGrp -q -tx UI_head_bn `;
  zxb_child_object_proc($head_mode,$head_joinr,$bn_ss,0,1,0,0); 


}





/////////////////////////////////面部簇创建簇//////////////////////////////////////////////
global proc zxb_face_to_Cluster_proc(){
string$mianban_UI[]={"UI_nose","UI_noseguard","UI_basis_nasi","UI_nose_R","UI_cheek","UI_cheekbone_R","UI_jwa_point"};
string$dian="";
int$fan=`checkBox -q -v duicheng`;
for($i=0;$i<size($mianban_UI);$i++)
{
    string$ui_string=$mianban_UI[$i];
    string $xiaba_temp=`textFieldGrp -q -tx  $ui_string `;
    $dian+=$xiaba_temp+" ";
 }
//string $xiaba_bn=`textFieldGrp -q -tx  zxb_ganjie `;
string$bns[]= stringToStringArray($dian, " ");//关节
string $dingdian_s[]=$bns;//选中顶点创建簇
int$jingxiang=$fan;
float$threshoud=0.01;
string$cu_mode_s[];
clear$cu_mode_s;
int $nemt=`tokenize $dingdian_s[0] "." $cu_mode_s`;//分离字符串存到变量
string$cu_mode=$cu_mode_s[0];
string$zu_root=("face_cu_grp");
string$shep_zi[]=`listRelatives -s $cu_mode`;
string$shep=$shep_zi[0];
int$ex_panduan=`objExists $zu_root`;
if($ex_panduan==0){group -empty -n $zu_root; }

int$ex=`objExists ("head_all_Cluster_Group")`;
if($ex==1){parent ("face_cu_grp") ("head_all_Cluster_Group");}
string$closestPointOnMesh=$cu_mode+"_closestPointOnMesh_temp";
int$panduan=`objExists$closestPointOnMesh`;
if($panduan==1){delete $closestPointOnMesh;} 
createNode "closestPointOnMesh" -n $closestPointOnMesh; //模型信息节点	
connectAttr -force ($shep+".worldMesh[0]") ($closestPointOnMesh+".inMesh");
int$fanxiang=$fan;
string$mingzi="";
for ($i=0;$i<size($dingdian_s);$i++)
    {
        string$dingdian=$dingdian_s[$i];
        string$sikn_cu=($cu_mode+"_cluster_Handle"+$i);
        select -r  $dingdian;
        newCluster " -envelope 1  " ;
         string$temp_s[]=`ls -sl`;//选中顶点创建簇
        parent $temp_s[0] $zu_root;
        /*string $loc=($temp_s[0]+"_temp_loc");
        spaceLocator -p 0 0 0 -n $loc ;
        delete`pointConstraint $temp_s[0] $loc`;*/
        $mingzi+=$temp_s[0]+" ";
        if($jingxiang==1)
           {
             float$pos_temp[]=`xform -q -ws -t $dingdian`;
             if($pos_temp[0]>$threshoud||$pos_temp[0]<($threshoud*-1))
                {
                    setAttr -type float3 ($closestPointOnMesh+".inPosition") ($pos_temp[0]*-1) $pos_temp[1] $pos_temp[2];
                    int$index=`getAttr ($closestPointOnMesh+".closestVertexIndex")`;
                     select -r ($cu_mode+".vtx["+$index+"]");
                     newCluster " -envelope 1 " ;
                        string$temp_s_a[]=`ls -sl`;//选中顶点创建簇
                        rename $temp_s_a[0] ($temp_s[0]+"sid");
                         $mingzi+=($temp_s[0]+"sid")+" ";
                        parent ($temp_s[0]+"sid") $zu_root;
                        
                     
                 }
            }
       
    }
    
  

delete $closestPointOnMesh;
select -r $zu_root;
string $head_qvxian=`textFieldGrp -q -tx UI_head_controller `;
zxb_ADD_shuxing_string_proc($head_qvxian,"face_Cluster_name");
setAttr -type "string"($head_qvxian+".face_Cluster_name") $mingzi;
/////////////////////////////////////创建面部控制器///////////////////////////
 string $head_controller=`textFieldGrp -q -tx UI_head_controller `;
  string$bn_ss=`getAttr ($head_controller+".face_Cluster_name")`;
  string $head_mode=`textFieldGrp -q -tx UI_head_mode `;
  string $head_joinr=`textFieldGrp -q -tx UI_head_bn `;
  zxb_child_object_proc($head_mode,$head_joinr,$bn_ss,0,1,0,0); 

}


///////////////////////////////////////创建瞳孔控制器/////////////////////////////////////////////////////
global proc zxb_pupil_bs_mode_extract_proc()
{
    
string $dian_aa=`textFieldGrp -q -tx UI_pupil_middle `;
string $dian_bb=`textFieldGrp -q -tx UI_pupil_up `;
string$temp_string=$dian_aa+" "+$dian_bb;
string $ves[]= stringToStringArray($temp_string, " ");//字符串转化数组
//string $ves[]=`ls -sl -fl`;//顶点  中间  上面
string$temp[];
 clear$temp;
int$shuliang=`tokenize $ves[0] "." $temp`;
string$mode=$temp[0];
float$pos_teme[]=`xform -q -ws -t $ves[0]`;
float$pos_teme_a[]=`xform -q -ws -t $ves[1]`;
if($pos_teme[1]>$pos_teme_a[1])
  {
   $pos_teme=`xform -q -ws -t$ves[1]`;
   $pos_teme_a= `xform -q -ws -t $ves[0]`;
  }
string$loc_A=($mode+"_loca");
string$loc_B=($mode+"_locb");
spaceLocator -p 0 0 0 -n $loc_A;
spaceLocator -p 0 0 0 -n $loc_B;
setAttr -type float3($loc_A+".translate") $pos_teme[0] $pos_teme[1] $pos_teme[2];
setAttr -type float3($loc_B+".translate") $pos_teme_a[0] $pos_teme_a[1] $pos_teme_a[2];

//创建眼球模型跟曲面
string$qiu=($mode+"_qiu");
string$qiunurb=($mode+"_nurb");
polySphere -r 1 -sx 20 -sy 20 -ax 0 0 1 -cuv 2 -ch 1 -n ($mode+"_qiu");
sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 4 -ch 0 -n $qiunurb;
string$qvmian_shapes[]=`listRelatives -s $qiunurb`;
string$qvmian_shape=$qvmian_shapes[0];
select -cl  ;
select -r $mode;
newCluster " -envelope 1";
string$cua[]=`ls -sl`;
delete` pointConstraint $cua[0]  ($mode+"_qiu")`;
select -r $loc_A;
select -add $qiu;
aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "object" -worldUpObject $loc_B;
delete $loc_B $loc_A $cua[0] ;

//创建的模型尽量靠近原始模型
float$boxs[]=`getAttr ($mode+".boundingBoxSize")`;
float$beishu=0.5;
setAttr ($qiu+".s") ($boxs[0]*$beishu) ($boxs[1]*$beishu) ($boxs[2]*$beishu);
delete` pointConstraint $qiu $qiunurb`;
delete` scaleConstraint $qiu $qiunurb`;
string$modejiedian=($mode+"yanqiu_closestPointOnMesh");
string$shaps[]=`listRelatives -s $mode`;
string$shap=$shaps[0];
int$ex=`objExists $modejiedian`;
if($ex==1){delete $modejiedian; }
createNode "closestPointOnMesh" -n $modejiedian; //多边型最近点节点
select -r ($qiu+".vtx[0:999999999]");
connectAttr -force ($shap+".worldMesh[0]")  ($modejiedian+".inMesh");
string $qiu_ves[]=`ls -sl -fl`;//顶点
for($i=0;$i<size($qiu_ves);$i++)
   {
       string$dian=$qiu_ves[$i];
       float$pos_temps[]=`xform -q -ws -t  $dian`;
       setAttr -type float3 ($modejiedian+".inPosition") $pos_temps[0] $pos_temps[1] $pos_temps[2] ;
       float $xingpos[]=`getAttr ($modejiedian+".position")`;
       xform -ws -t $xingpos[0] $xingpos[1] $xingpos[2] $dian;
       
   }




textFieldGrp -e -tx  $qiu UI_eye_create_mesh;
textFieldGrp -e -tx $qiunurb UI_eye_create_Surfaces;
textFieldGrp -e -tx $mode  UI_eye_mode_mesh;

}


//////////////////////////////////////////瞳孔绑定//////////////////////////////////////////////////////////////
global proc zxb_tongkongsuofang_shengcbangd_proc()
{
string$qiu=`textFieldGrp -q -tx  UI_eye_create_mesh`;//生成模型
string$yushess=`textFieldGrp -q -tx  UI_eye_name_preinstall_BS`;//混合变形预设
string$qiunurb=`textFieldGrp -q -tx UI_eye_create_Surfaces`;//生成曲面
string$mode=`textFieldGrp -q -tx UI_eye_mode_mesh`;//当前模型
string$eye_mode_A=`textFieldGrp -q -tx   UI_eyr_mode_L`;
string$eye_mode_B=`textFieldGrp -q -tx   UI_eyr_mode_R`;
int$weiyi= `checkBox -q -value duicheng `;
string $grp=($mode+"_yanqiu_grp");
string$qiu_R=($qiu+"_R");
string$qiunurb_R=($qiunurb+"_R");
string$grp_a=($grp+"_R");
string$kongzhiqi_nn="";
string$kongzhiqi_qq="";
int$left=$weiyi;
string$all_modess[];
clear $all_modess;
$all_modess[0]=$eye_mode_A;
$all_modess[1]=$eye_mode_B;
for($m=0;$m<size($all_modess);$m++)
   {
    string$ming_temp=$all_modess[$m];
    string$MOde[]= stringToStringArray($ming_temp, " ");//模型名字
    string$yushes[]= stringToStringArray($yushess, " ");//混合变形预设
    int$ex=`objExists $MOde[0]`;
    if($ex>0)
      {
      int$ex=`objExists $grp`;
      if($ex==0)
        {
         select -r $qiu;
         select -add $qiunurb;
         doGroup 0 1 1 ;
         rename $grp;
         //复制右眼模型曲面
         select -r $grp;
         duplicate -rr -n $grp_a;
         string$zieutis[]=`listRelatives -c -fullPath  $grp_a`; 
         rename $zieutis[0] $qiu_R;
         rename $zieutis[1] $qiunurb_R;
         setAttr ($grp_a+".scaleX") -1;
         
         setAttr ($grp_a+".visibility") 0;
         setAttr -lock true ($grp_a+".v");
          setAttr ($grp+".visibility") 0;
         setAttr -lock true ($grp+".v");
        } 
    }
    
    int$ex=`objExists $MOde[0]`;
    if($ex>0)
    {

    string$qvmian_shapes_R[]=`listRelatives -s $qiunurb_R`;
    string$qvmian_shape_R=$qvmian_shapes_R[0];
    string$qvmian_shapes[]=`listRelatives -s $qiunurb`;
    string$qvmian_shape=$qvmian_shapes[0];
    string$qvmian_xingjiedian="";
    string$qiu_aaa="";
    string$R_L="L";
    if($m==1)
      {
      $R_L="R";
      $qvmian_xingjiedian=$qvmian_shape_R;
      $qiu_aaa=$qiu_R;
      select -r $qiu_R;
      }
    else
        {
        $R_L="L";
        $qvmian_xingjiedian=$qvmian_shape;
        $qiu_aaa=$qiu;
        select -r $qiu;
        }
   string$qiu_A=($qiu+"_qvxian_meish"+$R_L);
   string$qvxian=($qiu_A+"_tongkongC_"+$R_L);
   
   duplicate -rr -n $qiu_A ; 
   doMenuComponentSelectionExt($qiu_A, "edge", 1);
   select -add   ($qiu_A+".e[0:19]") ($qiu_A+".e[20:39]") ($qiu_A+".e[40:59]") ($qiu_A+".e[60:79]") ($qiu_A+".e[80:99]") ($qiu_A+".e[100:119]")  ($qiu_A+".e [120:139]") ($qiu_A+".e[140:159]") ($qiu_A+".e[360:379]")($qiu_A+".e[160:179]");
   ConvertSelectionToFaces;
   delete;
   select -add   ($qiu_A+".e[160:179]") ;
   polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $qvxian;
   
   DeleteHistory;
   CenterPivot;
   string$qvxiang_grp=($qvxian+"_grp");
   group -n $qvxiang_grp;
   
   //创建曲线2
   string$qvxian_A_bngrp=($qiu_A+"_qvxian_grp"+$R_L);
   int$ex=`objExists $qvxian_A_bngrp`;
   if($ex==0){ group -empty -n $qvxian_A_bngrp ; }
   polySelect -er 322 $qiu_A;
   string $qiu_A_xian[]=`ls -sl -fl`;//线段
   string$eyeqvxian_s[];
   clear$eyeqvxian_s;
   for($i=0;$i<size($qiu_A_xian);$i++)
      {string$string_temp[];
       string$qvxian_B=($qiu_A+"_huanxing"+$i);
       clear $string_temp;
       string$bian=$qiu_A_xian[$i];
       int$temp_A=`tokenize  $bian "[" $string_temp`;
       $temp_A=`tokenize  $string_temp[1] "]" $string_temp`;
       int$index=$string_temp[0];
       polySelect -edgeLoop $index $qiu_A;
       polyToCurve -form 2 -degree 1 -conformToSmoothMeshPreview 1 -n $qvxian_B;
       DeleteHistory;
       parent $qvxian_B $qvxian_A_bngrp;
       $eyeqvxian_s[$i]=$qvxian_B; 
     }
    
    
   //判断曲线正反
   for($i=0;$i<size($eyeqvxian_s);$i++)
      {
      string$qvxian_cv=$eyeqvxian_s[$i];
      select -r ($qvxian_cv+".cv[0:9999999]");
      string $temp_cv[]=`ls -sl -fl`;//顶点
      float$pos_cv_a[]=`xform -q -ws -t $temp_cv[0]`;
      int$qq=(size($temp_cv)-1);
      float$pos_cv_b[]=`xform -q -ws -t ($temp_cv[$qq])`;
      if($pos_cv_a[2]<$pos_cv_b[2])
        {
         reverseCurve -ch 0 -rpo 1 $qvxian_cv;
        }
      }
   
   
   
   //创建关节
   string$qiu_A_bngrp=($qiu_A+"_tongkong_bn_grp"+$R_L);
   int$ex=`objExists $qiu_A_bngrp`;
   if($ex==0){ group -empty -n $qiu_A_bngrp; }
   for($i=0;$i<size($eyeqvxian_s);$i++)
      {
      string$qvxian_cv=$eyeqvxian_s[$i];
      select -r ($qvxian_cv+".cv[0:9999999]");
      string $temp_cv[]=`ls -sl -fl`;//顶点
      int$size=size($temp_cv);
      int$ex=`objExists($qvxian_cv+".zhaodaoBN")`; 
      if($ex==1){deleteAttr ($qvxian_cv+".zhaodaoBN");}
      addAttr -ln "zhaodaoBN"  -dt "string"  $qvxian_cv;
      //setAttr -type "string" ($qvxian_cv+".zhaodaoBN") "";
      for($ii=0;$ii<$size;$ii++)
         { 
          string$bnmane=($qiu_A+"_tongkong_BN_"+$i+$R_L+$ii);
          string$cv=$temp_cv[$ii];
          float$cvpos_temp[]=`xform -q -ws -t  $cv`;
          select -cl  ;
          joint -p $cvpos_temp[0] $cvpos_temp[1] $cvpos_temp[2]-n $bnmane;
          setAttr ($bnmane+".radius") 0.1;
          parent $bnmane $qiu_A_bngrp;
          int$ex=`objExists ($bnmane+".zhaodaoBN")`; 
          if($ex==0){addAttr -ln "zhaodaoBN"  -at bool  $bnmane;}
          string$getbnname=`getAttr($qvxian_cv+".zhaodaoBN")`;
          string$xingming=($getbnname+$bnmane+" ");
          setAttr -type "string" ($qvxian_cv+".zhaodaoBN") $xingming;
         }   
      }
      ////关节跟随曲面并衰减控制
   string$qiu_A_loc_rp=($qiu_A+"_tongkong_loc_grp"+$R_L);
   int$ex=`objExists $qiu_A_loc_rp`;
   if($ex==0){ group -empty -n $qiu_A_loc_rp ; }
   string$qiu_shaps[]=`listRelatives -s   $qiu_aaa`;
   string$qiu_shap=$qiu_shaps[0];
   string$kloc[];
   clear$kloc;
   string$kbn[];
   clear$kbn;
   for($i=0;$i<size($eyeqvxian_s);$i++)
      {
      string$qvxian_B=$eyeqvxian_s[$i];
      string$strings=`getAttr ($qvxian_B+".zhaodaoBN")`;
      string$bns[]=stringToStringArray($strings, " ");
      string$qvxianshaps[]=`listRelatives -s $qvxian_B`;
      string $qvxianshap=$qvxianshaps[0];
      string $qvxianxixi=($qvxian_B+"_eye_yanqiu_curveInfo");
      int$ex=`objExists  $qvxianxixi`;
      if($ex==1){delete   $qvxianxixi;}
      shadingNode -asUtility curveInfo -n  $qvxianxixi; //曲线信息
      connectAttr -force ($qvxianshap+".worldSpace[0]") ($qvxianxixi+".inputCurve");
      float$dis=`getAttr ($qvxianxixi+".arcLength")`;
      float$cdiss=0;
      for($j=0;$j<size($bns);$j++)
         {
         string$bn=$bns[$j];
         string$bn_loc=($bn+"loc"+$j);
         string$bn_loc_grpa=($bn+"loc_A"+$j);
         spaceLocator -p 0 0 0 -n $bn_loc;
         group -n $bn_loc_grpa;
         parent $bn_loc_grpa $qiu_A_loc_rp;
         delete ` pointConstraint  $bn $bn_loc_grpa`;
         string $qvmianjiedian=($bn+"_eye_yanqiu_closestPointOnSurface");
         int$ex=`objExists $qvmianjiedian`;
         if($ex==1){delete  $qvmianjiedian;}
         createNode "closestPointOnSurface" -n $qvmianjiedian ;//曲面信息节点	
         string$locshaps[]=`listRelatives -s $bn_loc`;
         string$locshap=$locshaps[0];
         connectAttr -force ($qvmian_xingjiedian+".worldSpace[0]") ($qvmianjiedian+".inputSurface");
         connectAttr -force ($locshap+".worldPosition[0]") ($qvmianjiedian+".inPosition");
         connectAttr -force  ($qvmianjiedian+".position") ($bn+".t") ;//定位器控制骨骼
         if($j==0)
           {
           $kloc[$i]=$bn_loc;
           $kbn[$i]=$bn;
            }
         if($j>0)
           {
           int$jj=$j-1;
           string$bbn=$bns[$jj];
           float$weizhi[]=`xform -q -ws -t $bbn`;
           float$weizhi_a[]=`xform -q -ws -t $bn`;
           
           float$ccdis=mag(<<$weizhi[0],$weizhi[1],$weizhi[2]>>-<<$weizhi_a[0],$weizhi_a[1],$weizhi_a[2]>>);
           $cdiss+=$ccdis;
           float$changdu=(1-($cdiss/$dis)); 
           string $chenmgcujiedian_A=($bn_loc+"_eye_yanqiu_multiplyDivide_A");
           int$ex=`objExists $chenmgcujiedian_A`;
           if($ex==1){delete  $chenmgcujiedian_A;}
           shadingNode -asUtility multiplyDivide -n $chenmgcujiedian_A;//创建乘除节点
           connectAttr -force ($bns[0]+"loc"+"0"+".t") ($chenmgcujiedian_A+".input1");
           int$ex=`objExists ($bn+".gensui")`;
           if($ex==0){addAttr -ln "gensui"  -at double  -dv $changdu -k 1 $bn;}
           setAttr -keyable false -channelBox true ($bn+".gensui");
           connectAttr -force ($bn+".gensui") ($chenmgcujiedian_A+".input2X");
           connectAttr -force ($bn+".gensui") ($chenmgcujiedian_A+".input2Y");
           connectAttr -force ($bn+".gensui") ($chenmgcujiedian_A+".input2Z");
           connectAttr -force  ($chenmgcujiedian_A+".output") ($bn_loc+".t");
           } 
         }
       }
   //第一排定位器跟随曲线
   string$qvxian_A=($qvxian+"_A");
   $kongzhiqi_qq+=$qvxian_A+" ";
   select -r $qvxian;
   duplicate -rr -n $qvxian_A;
   parent $qvxian $qvxian_A_bngrp;
   float$boxs_a[]=`getAttr ($qvxian_A+".boundingBoxSize")`;
   select -r  ($qvxian_A+".cv[0:99999999999]");
   move -r 0 0 ($boxs_a[0]*0.5);
   //setAttr ($qvxiang_grp+".tz") ;
   string$qvxianshap_Bs[]=`listRelatives -s $qvxian`;
   string$qvxianshap_B=$qvxianshap_Bs[0];
   for($i=0;$i<size($kloc);$i++)
     {
     string$loc_temp= $kloc[$i];
     string $qvxianjiedian_A=($loc_temp+"_eye_yanqiu_qvxian_nearestPointOnCurve_A");
     string $qvxianjiedian_AA=($loc_temp+"_eye_yanqiu_qvxian_pointOnCurveInfo_A");
     int$ex=`objExists $qvxianjiedian_A`;
     if($ex==1){delete  $qvxianjiedian_A;}
     int$ex=`objExists $qvxianjiedian_AA`;
     if($ex==1){delete  $qvxianjiedian_AA;}
     createNode nearestPointOnCurve -n $qvxianjiedian_A ;
     createNode "pointOnCurveInfo" -n $qvxianjiedian_AA;//创建曲线信息节点
     connectAttr -force ($qvxianshap_B+".worldSpace[0]") ($qvxianjiedian_A+".inputCurve");
     connectAttr -force ($qvxianshap_B+".worldSpace[0]") ($qvxianjiedian_AA+".inputCurve");
     float$weizhi_temp[]=`xform -q -ws -t $loc_temp`;
     setAttr -type float3($qvxianjiedian_A+".inPosition")$weizhi_temp[0] $weizhi_temp[1] $weizhi_temp[2];
     float$canshu=`getAttr ($qvxianjiedian_A+".parameter")`;
     setAttr ($qvxianjiedian_AA+".parameter")$canshu;
     string$loc_A=($loc_temp+"_C");
     spaceLocator -p 0 0 0 -n $loc_A;
     connectAttr -force ($qvxianjiedian_AA+".position") ($loc_A+".t");
     parent $loc_A $qiu_A_loc_rp;
     parentConstraint  $loc_A $loc_temp;
    }
   //创建控制曲线的蒙皮关节  并添加融合节点
   string$qvxianshap_Cs[]=`listRelatives -s $qvxian_A`;
   setAttr ($qvxianshap_Cs[0]+".overrideEnabled") 1;
   setAttr($qvxianshap_Cs[0]+".overrideColor") 15;
   //delete`orientConstraint $qiu_aaa $qvxiang_grp `;
   string$root_bn=($qiu+"_root"+$R_L);
   select -cl  ;
   joint -p 0 0 0 -n $root_bn ;
   delete`pointConstraint $qvxian_A $root_bn`;//点约束 
   parent $root_bn $qvxian_A ;
   string$attrs[]=$yushes;
   select -r  $qvxian;
   string$bs_AA[]=`blendShape`;
   string$bstongkong=("tongkongbs_"+$qvxian);
   rename $bs_AA[0] $bstongkong;
   for($i=0;$i<size($attrs);$i++)
      {
      string$name=($qvxian+$attrs[$i]+"_"+$i);
      string$shuxing=$attrs[$i];
      select -r  $qvxian;
      duplicate -rr -n $name;
      blendShape -e  -t $qvxian $i $name 1 $bstongkong;
      select -r $qvxian_A;
      string$shuaxing_a=($qvxian_A+"."+$shuxing);
      int$ex=`objExists $shuaxing_a`;
      if($ex==0){ addAttr -ln $shuxing  -at double  -min 0 -max 1  -dv 0 -k 1 $qvxian_A;}
      setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd ($qvxian_A+"."+$shuxing)  ($bstongkong+"."+$name);
      setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 1 -cd ($qvxian_A+"."+$shuxing)  ($bstongkong+"."+$name);
     }
   //关节控制曲线    
   if($m==0){select -r $qiunurb;}else{select -r $qiunurb_R;}     
   select -add $root_bn;
   normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene";
   select -r $root_bn;
   select -add $qvxian;
   newSkinCluster "-toSelectedBones -mi 1 -omi true -dr 6 -rui 0";  



   //创建眼球中间的关节   
   string$M_pos_cv= ($qiu_aaa+".vtx[381]") ;
   float$M_pos_temp[]=`xform -q -ws -t $M_pos_cv`;
   string$m_root_bn=($qiu_aaa+"_M_root"+$R_L);
   select -cl  ;
   joint -p $M_pos_temp[0] $M_pos_temp[1] $M_pos_temp[2] -n $m_root_bn ;
   parent  $m_root_bn $qiu_A_bngrp;
   string$bn=$m_root_bn;
   string$bn_loc=($bn+"loc_root");
   string$bn_loc_B=($bn+"loc_root_b");
   string$bn_loc_grpa=($bn+"loc_A_root");
   string$bn_loc_grpb=($bn+"loc_B_root");
   spaceLocator -p 0 0 0 -n $bn_loc;
   group -n $bn_loc_grpa;
   parent $bn_loc_grpa $qiu_A_loc_rp;
   delete ` pointConstraint  $bn $bn_loc_grpa`;          
   spaceLocator -p 0 0 0 -n $bn_loc_B;
   group -n $bn_loc_grpb;
   parent $bn_loc_grpb $qiu_A_bngrp;          
   //中间关机在曲面上滑动             
   string $qvmianjiedian=($bn+"_eye_yanqiu_closestPointOnSurface_root");
   int$ex=`objExists $qvmianjiedian`;
   if($ex==1){delete  $qvmianjiedian;}
   createNode "closestPointOnSurface" -n $qvmianjiedian ;//曲面信息节点	
   string$locshaps[]=`listRelatives -s $bn_loc`;
   string$locshap=$locshaps[0];
   string$locshapBs[]=`listRelatives -s $bn_loc_B`;
   string$locshapB=$locshapBs[0];
   connectAttr -force ($qvmian_xingjiedian+".worldSpace[0]") ($qvmianjiedian+".inputSurface");
   connectAttr -force ($locshap+".worldPosition[0]") ($qvmianjiedian+".inPosition");
   connectAttr -force  ($qvmianjiedian+".position") ($bn_loc_B+".t") ;//定位器控制骨骼    
   pointConstraint -mo $qvxian_A $bn_loc;
   scaleConstraint  -mo $qvxian_A $bn_loc_B;
   setAttr ($locshapB+".v") 0;
   setAttr ($locshap+".v") 0;
   setAttr -l 1($locshapB+".v") 0;
   setAttr -l 1 ($locshap+".v") 0;
   //法线约束关节   中间关节是发现约束的定位器            
   string$all_bn[]=`listRelatives -c -ad -type "joint" $qiu_A_bngrp`;     
   select -r $all_bn;
   select -d $m_root_bn;//排除中间关节
   select -add $bn_loc_B;
   string$faxianyuseu_bn[]=`ls -sl `;
   for($i=0;$i<size($faxianyuseu_bn);$i++)
      {
      if($m==0){select -r $qiunurb;}else{select -r $qiunurb_R;}
      select -add $faxianyuseu_bn[$i];
      normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "scene";//法线约束
      }
   parent $bn $bn_loc_B;//中间关节跟随定位器
   //给球的模型蒙皮
   select -r $all_bn;
   select -add $qiu_aaa;            
   newSkinCluster "-toSelectedBones -mi 1 -omi 0 -dr 6 -rui 0"; 
   select -r $kbn  ;
   select -add $bn ;
   string$qaun_bn[]=`ls -sl -type "joint"`;
   select -r ($qiu_aaa+".e[360:379]") ;
   ConvertSelectionToVertices;
   string$qiu_cvs[]=`ls -sl -fl`;
   int$pinghua=2;
   string $skinCluster2=`findRelatedSkinCluster $qiu_aaa` ;//访问蒙皮节点
   float$quznhzong=`skinPercent -tv  $bn 0.75 $skinCluster2  $qiu_cvs`;


   //给内眼球制作控制器
   string$qvxian_B=($qvxian_A+"B");
   $kongzhiqi_nn+=$qvxian_B+" ";
   select -r $qvxian_A ;
   duplicate -rr -n $qvxian_B;
   string$teme_zi_obj[]=`listRelatives -c -type "joint" -fullPath $qvxian_B`;
   delete $teme_zi_obj;
   select -r ($qvxian_B+".cv[0:9999999]");
   newCluster " -envelope 1";
   string$cus[]=`ls -sl`;
   setAttr -type float3 ($cus[0]+".scale") 0.7 0.7 0.7;
   select -r  $qvxian_B;
   DeleteHistory;
   for($i=0;$i<size($attrs);$i++)
      {
      string$shuxing=$attrs[$i];
      catch (`deleteAttr -attribute $shuxing  $qvxian_B`);
      }
   parent $qvxian_B $qvxian_A;
   scaleConstraint $qvxian_B $bn;//缩放约束
   string$mode_a_grp="";
   if($m==0)
     {
      $mode_a_grp=$grp ;
     }
   else
     {
      $mode_a_grp=$grp_a;
     } 
   select -r $MOde;
   string$temp_eyemode[]=`ls -sl`;
   for($i=0;$i<size($temp_eyemode);$i++)
      {
      string$temp_eye_mode=$temp_eyemode[$i];
      string$eye_mode_AA=($temp_eye_mode+"_A");
      
      select -r $temp_eye_mode;
      duplicate -rr -n $eye_mode_AA;
      parent  $eye_mode_AA $grp;
      select -r $eye_mode_AA ;
      select -add $temp_eye_mode ;
      string$eye_hunhebianxing[]=`blendShape -frontOfChain`;
      rename $eye_hunhebianxing[0] ($temp_eye_mode+"_eye_qiu_bs");
      setAttr ($temp_eye_mode+"_eye_qiu_bs"+"."+$eye_mode_AA) 1;
      select -r $all_bn;
      select -add $eye_mode_AA;
      newSkinCluster "-toSelectedBones -mi 1 -omi 0 -dr 6 -rui 0"; 
      select -r $qiu_aaa;
      select -add $eye_mode_AA;
      copySkinWeights  -noMirror -surfaceAssociation closestPoint -influenceAssociation closestJoint;
     }

   //整理层级
   $root_L_grp=($grp+"root_grp"+$R_L);  
   string$zu_zong=("head_pupil_curve_Group");
   zxb_ADD_kongzu_proc("head_pupil_curve_Group");
  // print $root_L_grp;
  
   select -r  $qvxiang_grp $mode_a_grp  $qvxian_A_bngrp $qiu_A_bngrp $qiu_A_loc_rp;
   group-n  $root_L_grp;
   parent $root_L_grp ("head_pupil_curve_Group") ;
   select -r    $qvxian_A_bngrp $qiu_A_bngrp $qiu_A_loc_rp;
   string$temp_gpr[]=`ls -sl`;
   for($i=0;$i<size($temp_gpr);$i++)
      {
       string$grp_q=$temp_gpr[$i];
       setAttr ($grp_q+".visibility") 0;
       setAttr -lock true ($grp_q+".v");
       }

      

  }
    }
textFieldGrp -e -tx $kongzhiqi_nn kongzhiqi_ab;   
textFieldGrp -e -tx $kongzhiqi_qq kongzhiqi_a;  
// print   ($kongzhiqi_nn+"\n"+$kongzhiqi_qq);
}





////////////////////////////////////////瞳孔转混合变形//////////////////////////////////////////////



global proc zxb_tongkong_BSProc()
{

string$eye_mode_A=`textFieldGrp -q -tx   UI_eyr_mode_L`;//L模型
string$eye_mode_B=`textFieldGrp -q -tx   UI_eyr_mode_R`;//R模型
string$kongzhiqisss=`textFieldGrp -q -tx   kongzhiqi`;////添加属性的控制器
string$shuxingkongzhiqisss=`textFieldGrp -q -tx  kongzhiqi_ab `;//内瞳孔
string$kongzhiqi_ABSS[]= stringToStringArray($shuxingkongzhiqisss, " ");//控制器A

string$shuzhi_A=`textFieldGrp -q -tx  fangda `;//数值
string$shuzhi_B=`textFieldGrp -q -tx  suoxiao `;//数值
string$shuzhi_C=`textFieldGrp -q -tx   suoxiaox `;//数值
string$shuzhi_D=`textFieldGrp -q -tx  fangdax `;//数值
string$shuzhi_E=`textFieldGrp -q -tx  suoxiaoy `;//数值
string$shuzhi_F=`textFieldGrp -q -tx  fangday `;//数值

string$shushu=stringArrayToString({ $shuzhi_A, $shuzhi_B,$shuzhi_C,$shuzhi_D,$shuzhi_E,$shuzhi_F }, ", ");
string$shushuSSS[]= stringToStringArray($shushu, ", ");//

string$kongzhiqi_ASS=`textFieldGrp -q -tx   kongzhiqi_a`;//外瞳孔
string$yueshe_BSAsss=`textFieldGrp -q -tx  yueshe_BS_A`;//
string$kongzhiqi_AS[]= stringToStringArray($kongzhiqi_ASS, " ");//控制器A

string$yueshe_BSsss=`textFieldGrp -q -tx   UI_eye_name_preinstall_BS`;
string$yushes[]= stringToStringArray($yueshe_BSsss, " ");//曲线BS数组
string$yushes_A[]= stringToStringArray($yueshe_BSAsss, " ");//曲线BS数组
int$duicheng= `checkBox -q -value duicheng `;


string$kongzhiqiss[]=stringToStringArray($kongzhiqisss, " ");//添加属性的控制器

string$kongzhiqi_L="";
string$kongzhiqi_R="";
for($i=0;$i<size($kongzhiqiss);$i++) 
{
    string$temp_kongzzhiqi=$kongzhiqiss[$i];
    spaceLocator -p 0 0 0 -n "temp_loc";
    delete `parentConstraint  $temp_kongzzhiqi "temp_loc"`;
    float$temp_pos[]=`xform -q -ws -t "temp_loc"`;
    delete "temp_loc" ;
    if($temp_pos[0]>0.000001){$kongzhiqi_L=$temp_kongzzhiqi;}
    if($temp_pos[0]<-0.000001){$kongzhiqi_R=$temp_kongzzhiqi;}
    if($temp_pos[0]==0){error "控制器在世界坐标零的位置";}
}
string$kongzhi="";
string$kk_kongzhiqi[];
clear$kk_kongzhiqi;
$kk_kongzhiqi[0]=$kongzhiqi_L;
$kk_kongzhiqi[1]=$kongzhiqi_R;
//if($duicheng==0){$kongzhi=$kongzhiqi_L;}else{$kongzhi=$kongzhiqi_R;}



string$kongzhiqi_AL="";
string$kongzhiqi_AR="";
for($i=0;$i<size($kongzhiqi_AS);$i++) //外瞳孔控制器
{
    string$temp_kongzzhiqi=$kongzhiqi_AS[$i];
    spaceLocator -p 0 0 0 -n "temp_loc";
    delete `parentConstraint  $temp_kongzzhiqi "temp_loc"`;
    float$temp_pos[]=`xform -q -ws  -t ("temp_loc")`;
    delete "temp_loc";
    if($temp_pos[0]>0.000001){$kongzhiqi_AL=$temp_kongzzhiqi;}
    if($temp_pos[0]<-0.000001){$kongzhiqi_AR=$temp_kongzzhiqi;}
    if($temp_pos[0]==0){error "控制器在世界坐标零的位置";}
}
string$kongzhiA="";
string$kk_kongzhiA[];
clear$kk_kongzhiA;
$kk_kongzhiA[0]=$kongzhiqi_AL;
$kk_kongzhiA[1]=$kongzhiqi_AR;
//if($duicheng==0){$kongzhiA=$kongzhiqi_AL;}else{$kongzhiA=$kongzhiqi_AR;}



string$kongzhiqi_ABL="";
string$kongzhiqi_ABR="";
for($i=0;$i<size($kongzhiqi_ABSS);$i++) //内瞳孔控制器
{
    string$temp_kongzzhiqi=$kongzhiqi_ABSS[$i];
    spaceLocator -p 0 0 0 -n "temp_loc";
    delete `parentConstraint  $temp_kongzzhiqi "temp_loc"`;
    float$temp_pos[]=`xform -q -wd  -t "temp_loc"`;
    delete "temp_loc";
    if($temp_pos[0]>0.000001){$kongzhiqi_ABL=$temp_kongzzhiqi;}
    if($temp_pos[0]<-0.000001){$kongzhiqi_ABR=$temp_kongzzhiqi;}
    if($temp_pos[0]==0){error "控制器在世界坐标零的位置";}
}
string$kongzhiAB="";
string$kk_kongzhiAABB[];
clear$kk_kongzhiAABB;
$kk_kongzhiAABB[0]=$kongzhiqi_ABL;
$kk_kongzhiAABB[1]=$kongzhiqi_ABR;
//if($duicheng==0){$kongzhiAB=$kongzhiqi_ABL;}else{$kongzhiAB=$kongzhiqi_ABR;}

string$mode_SS[];//模型
clear $mode_SS;
$mode_SS[0]=$eye_mode_A+" ";
$mode_SS[1]=$eye_mode_B+" ";
string$mode_S[];//模型


//if($duicheng==0){$mode_S=$MOdeL;}else{$mode_S=$MOdeR;}

for($xi=0;$xi<size($mode_SS);$xi++) 
{
    string$mesh_temp=$mode_SS[$xi];
    string$Mo_temp_mode[]= stringToStringArray($mesh_temp, " ");//字符串转化数组
    $kongzhiAB=$kk_kongzhiAABB[$xi];
    $kongzhiA=$kk_kongzhiA[$xi];
    $kongzhi=$kk_kongzhiqi[$xi];
    clear $mode_S;
    $mode_S=$Mo_temp_mode;
    int $ex=`objExists $Mo_temp_mode[0]`;
    if($ex==1)
      {

for($i=0;$i<size($yushes);$i++) 
   {
        string$mingzi=$yushes[$i];
        int $ex=`objExists ($kongzhi+"."+$mingzi)`;
        if($ex==0)
           {
               select -r $kongzhi;
          
            addAttr -ln $mingzi  -at double  -min 0 -max 1 -dv 0 -k 1;
           }
   }
   


string$grp_root=$kongzhiA+"_bs_grp_root";
string$zu_zong=("head_pupil_curve_Group");
zxb_ADD_kongzu_proc("head_pupil_curve_Group");

int$ex=`objExists$grp_root`;    ///判断
if($ex==0){ group -em -n $grp_root ;setAttr  ($grp_root+".visibility") 0;setAttr -lock true ($grp_root+".v"); parent $grp_root ("head_pupil_curve_Group");}
for($i=0;$i<size($mode_S);$i++) 
   {
    string$temp_mode=$mode_S[$i];
    string$grp=$temp_mode+"_bs_grp";
    int$ex=`objExists $grp`;    ///判断
    if($ex==0){ group -em -n $grp; };
    parent $grp  $grp_root;
    string$bs="";
    string $mode_shape[]=`listRelatives -s $temp_mode `; 
    string $mode_shap=$mode_shape[0];
    string $temp_shuxing[]=`listConnections -d 0 -s 1 ( $mode_shap+".inMesh")`;//列出链接属性  -d输入   -s输出  -p 列出属性
    string$type=`nodeType $temp_shuxing[0]`;
    if($type=="skinCluster")
      {
      string $temp_shuxing_A[]=`listConnections -d 0 -s 1 ( $temp_shuxing[0]+".input[0].inputGeometry")`;//列出链接属性  -d输入   -s输出  -p 列出属性
      $bs=$temp_shuxing_A[0];
      }
    if($type=="blendShape"){$bs=$temp_shuxing[0];}
    for($j=0;$j<size($yushes);$j++) 
        { 
        string$temp_shuxinga=$yushes[$j];
        string$bs_mode=$temp_mode+$temp_shuxinga;
        setAttr ($kongzhiA+"."+$temp_shuxinga) 1;
        select -r   $temp_mode;
        duplicate -rr -n  $bs_mode;
        parent  $bs_mode $grp;
        setAttr ($kongzhiA+"."+$temp_shuxinga) 0;
        string $listOfShapesInNode[] =`listAttr -k -m $bs`;
        string$bsss[];
        clear$bsss;
        for($jj=0;$jj<size($listOfShapesInNode);$jj++)
            {
            string$mmmm=$listOfShapesInNode[$jj];
            int$ex=`objExists $mmmm`; 
            if($ex==1)
                {  
                int$size=size($bsss);
                $bsss[$size]=$mmmm;
                 } 
            
            }
        int$idex=size($bsss);
        select -r   $bs_mode;
        select -add $temp_mode;
        blendShape -e  -t $temp_mode $idex $bs_mode 1 $bs;
        setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd  ($kongzhi+"."+$temp_shuxinga)  ($bs+"."+$bs_mode);  
        setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 1 -cd   ($kongzhi+"."+$temp_shuxinga)  ($bs+"."+$bs_mode);  
         } 
       for($w=0;$w<size($yushes_A);$w++)
          {
          float$temp_zhi=$shushuSSS[$w];
          string$temp_ming=$yushes_A[$w];
          string$bs_mode=$temp_mode+$temp_ming;
          int $ex=`objExists ($kongzhi+"."+$temp_ming)`;
          if($ex==0)
           {
            select -r $kongzhi;
            addAttr -ln $temp_ming -at double  -min 0 -max 1 -dv 0 -k 1;
           }

          if($w==0){setAttr -type float3 ($kongzhiA+".scale") $temp_zhi $temp_zhi $temp_zhi;}
          if($w==1){setAttr -type float3 ($kongzhiA+".scale") $temp_zhi $temp_zhi $temp_zhi;}
          if($w==2){setAttr ($kongzhiA+".scaleX") $temp_zhi;}
          if($w==3){setAttr ($kongzhiA+".scaleX") $temp_zhi;}
          if($w==4){setAttr ($kongzhiA+".scaleY") $temp_zhi;}
          if($w==5){setAttr ($kongzhiA+".scaleY") $temp_zhi;}
          select -r   $temp_mode;
          duplicate -rr -n  $bs_mode;
          parent  $bs_mode $grp;
          string $listOfShapesInNode[] =`listAttr -k -m $bs`;
          string$bsss[];
          clear$bsss;
          for($jj=0;$jj<size($listOfShapesInNode);$jj++)
            {
             string$mmmm=$listOfShapesInNode[$jj];
             int$ex=`objExists $mmmm`; 
             if($ex==1)
               {   
                int$size=size($bsss);
                $bsss[$size]=$mmmm;
                } 
            
            }
          int$idex=size($bsss);
          select -r   $bs_mode;
          select -add $temp_mode;
          blendShape -e  -t $temp_mode $idex $bs_mode 1 $bs;
          setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd  ($kongzhi+"."+$temp_ming)  ($bs+"."+$bs_mode);  
          setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 1 -cd   ($kongzhi+"."+$temp_ming)  ($bs+"."+$bs_mode); 
          setAttr -type float3 ($kongzhiA+".scale") 1 1 1;     
          }  
       for($w=0;$w<size($yushes_A);$w++)
          {
          float$temp_zhi=$shushuSSS[$w];
          string$temp_ming=$yushes_A[$w]+"_nie";
          string$bs_mode=$temp_mode+$temp_ming;
          int $ex=`objExists ($kongzhi+"."+$temp_ming)`;
          if($ex==0)
           {
               select -r $kongzhi;
           
            addAttr -ln $temp_ming -at double  -min 0 -max 1 -dv 0 -k 1;
           }

          if($w==0){setAttr -type float3 ($kongzhiAB+".scale") $temp_zhi $temp_zhi $temp_zhi;}
          if($w==1){setAttr -type float3 ($kongzhiAB+".scale") $temp_zhi $temp_zhi $temp_zhi;}
          if($w==2){setAttr ($kongzhiAB+".scaleX") $temp_zhi;}
          if($w==3){setAttr ($kongzhiAB+".scaleX") $temp_zhi;}
          if($w==4){setAttr ($kongzhiAB+".scaleY") $temp_zhi;}
          if($w==5){setAttr ($kongzhiAB+".scaleY") $temp_zhi;}
          select -r   $temp_mode;
          duplicate -rr -n  $bs_mode;
          parent  $bs_mode $grp;
          string $listOfShapesInNode[] =`listAttr -k -m $bs`;
          string$bsss[];
          clear$bsss;
          for($jj=0;$jj<size($listOfShapesInNode);$jj++)
            {
            string$mmmm=$listOfShapesInNode[$jj];
             int$ex=`objExists $mmmm`; 
             if($ex==1)
                {
                int$size=size($bsss);
                $bsss[$size]=$mmmm;
                 } 
            
            }
          int$idex=size($bsss);
          select -r   $bs_mode;
          select -add $temp_mode;
          blendShape -e  -t $temp_mode $idex $bs_mode 1 $bs;
          setDrivenKeyframe -itt "linear" -ott "spline" -v 0 -dv 0 -cd  ($kongzhi+"."+$temp_ming)  ($bs+"."+$bs_mode);  
          setDrivenKeyframe -itt "linear" -ott "spline" -v 1 -dv 1 -cd   ($kongzhi+"."+$temp_ming)  ($bs+"."+$bs_mode); 
          setAttr -type float3 ($kongzhiAB+".scale") 1 1 1;     
        }
         
    }



}
/////



       }
}









////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////眼皮自动创建次级/////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////
global proc zxb_yanjing_yanpi_qvxian_fangfa_proc()

{
    
    string$all_temp_eye_bn="";
    string$ui_name_s[]={"UI_eye_L_wire","UI_eye_R_wire"};
    string$ui_name_A[]={"UI_eye_L_mode","UI_eye_R_mode"};
    string $UI_head_controller=`textFieldGrp -q -tx  UI_head_controller`;//查询眼眶线的变量   
    string$eye_bs_name_s=`getAttr ($UI_head_controller+".base_bs_mode")`;
    string $eye_bs_name_ss[]= stringToStringArray($eye_bs_name_s, " ");//字符串转化数组
     string$eye_bs_name=$eye_bs_name_ss[4];
    string$EYE_com_SS=`getAttr ($UI_head_controller+".eye_con")`;
    string $EYE_com_S[]= stringToStringArray($EYE_com_SS, " ");//字符串转化数组
    zxb_ADD_shuxing_string_proc($UI_head_controller,"eye_qvmian");
    string$qvmian_temp="";
    string$qvmxian_DDD_temp="";
    
     for ($e=0;$e<size($ui_name_s);$e++)
     {
         string$ui_mingzi=$ui_name_s[$e];
         string $ui_name_mode=$ui_name_A[$e];
         string$eye_con_A=$EYE_com_S[$e];
         
         
         string$fuzhao_qvmian="";
         string$DD_QVXIAN="";
         string$grp_lr_temp="";
         string$zhangkai_qvxian_A="";
         string$gensui_qvxian_D="";
         string$bihe_qvxian="";
         string $mnian_temp=`textFieldGrp -q -tx  $ui_mingzi`;//查询眼眶线的变量
         string $mnians[]= stringToStringArray($mnian_temp, " ");//字符串转化数组
         string$mnianss="";
         for ($zz=0;$zz<size($mnians);$zz++)
             {
              string$xianduan=$mnians[$zz];
              string$temp_clear[];
              clear $temp_clear;//清除数组
              int $nemt=`tokenize $xianduan "." $temp_clear`;//分离字符串存到变量
              $mnianss+=$eye_bs_name+"."+$temp_clear[1]+" ";
              }
         
         string $head_qvxian=`textFieldGrp -q -tx  UI_head_controller`;//查询眼眶线的变量
         string $head_mode=`textFieldGrp -q -tx UI_head_mode `;
         string $head_joinr=`textFieldGrp -q -tx UI_head_bn `;
         
         
         float$bbobx_max[]=`getAttr ($head_qvxian+".boundingBoxMax")`;
         float$pianyi=$bbobx_max[0]/130;
         int$ex=`objExists $mnians[0]`;    ///判断
         if($ex==1)
         {
          string$qvxian="eye_wire";
          string$rrll="";
          int$duicheng_bn=`checkBox -q  -value   duicheng`;
          spaceLocator -p 0 0 0 -n "temp_loc_pos";
          select -r $mnians;
          string$temp_Cluster[]=`newCluster " -envelope 1"`;
          delete`pointConstraint $temp_Cluster[1] "temp_loc_pos" `;
          float$temp_loc_pos= `getAttr "temp_loc_pos.translateX"`;
          if($temp_loc_pos>0.0000000001){$rrll="L";}
          if($temp_loc_pos<-0.0000000001){$rrll="R";}
          delete "temp_loc_pos" $temp_Cluster[1];
          zxb_extract_Curves_proc(1,$rrll,$qvxian,$mnianss);//int 区分线段的平均值或者法线朝向 $mingzi名字 $qianzui前缀 $xian_A 线段名称
          string$eye_cu_grp="eye_grp_cu_"+$rrll;
          zxb_ADD_kongzu_proc($eye_cu_grp);
          string$eye_cu_shuxing="eye_cu_mingzi_"+$rrll;
          zxb_ADD_shuxing_string_proc($head_qvxian,$eye_cu_shuxing);
          
          
          
          string$dw_A=$qvxian+"_"+$rrll+"_DW";
          string$up_A=$qvxian+"_"+$rrll+"_UP";
          select -r $up_A  $dw_A;
          string$qvxians[]=`ls -sl  `;
          float$dian_pos_A[];
          float$dian_pos_B[];
          for ($aa=0;$aa<size($qvxians);$aa++) 
              {
              string$qv_temp=$qvxians[$aa];
             select -r ($qv_temp+".cv[0:999999999]") ;
             string$temp_dian[]=`ls -sl  -fl`;
             if($aa==0){$dian_pos_A=`xform -q -ws -t $temp_dian[0]`;}
             if($aa==1){$dian_pos_B=`xform -q -ws -t $temp_dian[0]`;}  
              }   
         if($dian_pos_A[0]!=$dian_pos_B[0])
             {
             if($duicheng_bn==1){reverseCurve -ch 1 -rpo 1 $up_A;}
             if($duicheng_bn==0){reverseCurve -ch 1 -rpo 1 $dw_A;}
             }
             
        string$grp=$qvxians[0]+"grp";
        int$ex=`objExists $grp`;    ///判断
        $grp_lr_temp=$grp;
        if($ex==0){group -empty -n $grp ;}
        int$ex=`objExists ("zxb_fase_eye_grp")`;
          if($ex==1){parent $eye_cu_grp  "zxb_fase_eye_grp"; parent $grp "zxb_fase_eye_grp";}
        string$qvmians[];
        clear$qvmians; 
        string$HH_qvxian="";  
        string$HH_qvmian="";
        string$xian_d_ss="";
        string$xian_cc_ss="";
        for ($aa=0;$aa<size($qvxians);$aa++) 
            {
            string$temp_qvxian=$qvxians[$aa];
            $bihe_qvxian+=$temp_qvxian+" ";
            string$qvxian_D=$temp_qvxian+"_D";
            $gensui_qvxian_D+=$qvxian_D+" ";
            $xian_d_ss+=$qvxian_D+" ";
            
            string$qvxian_A=$temp_qvxian+"_A";
            $zhangkai_qvxian_A+=$qvxian_A+" ";
            string$qvxian_CC=$temp_qvxian+"_CC";
            $xian_cc_ss+=$qvxian_CC+" ";
            string$qvxian_HH=$temp_qvxian+"_HH";
            $HH_qvxian+=$qvxian_HH+" ";
            string$qvxian_DD=$temp_qvxian+"_DD";
            $DD_QVXIAN+=$qvxian_DD+" ";
            $qvmxian_DDD_temp+=$qvxian_DD+" ";
            string$qvxian_FF=$temp_qvxian+"_FF";
            string$qvxian_qvmian=$temp_qvxian+"_qvmian";
            $HH_qvmian+=$qvxian_qvmian+" ";
            string$qvxian_pianyi_A=$temp_qvxian+"_pianyi_A";
            string$qvxian_pianyi_B=$temp_qvxian+"_pianyi_B";
            select -r $temp_qvxian;
            duplicate -rr -n $qvxian_D;
           select -r $temp_qvxian;
           duplicate -rr -n  $qvxian_A;
           select -r $temp_qvxian;
           duplicate -rr -n  $qvxian_CC;
           select -r $temp_qvxian;
          duplicate -rr -n  $qvxian_HH;
          select -r $temp_qvxian;
          duplicate -rr -n  $qvxian_DD;
          select -r   $temp_qvxian;
          duplicate -rr  -n $qvxian_FF;
          select -r $qvxian_CC ;
          select -add $qvxian_HH ;
          select -add $qvxian_DD ;
          string$bss[]=`blendShape -automatic -tc 0`;
          setAttr ($bss[0]+"."+$qvxian_CC) 1;
          setAttr ($bss[0]+"."+$qvxian_HH) 1;
          select -r  $qvxian_FF;
          rebuildCurve -ch 1 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 4 -d 3 -tol 0.01 $qvxian_FF;
          offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d ($pianyi*-1) -tol 0.01 -sd 5 -ugn false   -n $qvxian_pianyi_A  $qvxian_FF;
          offsetCurve  -ch on -rn false -cb 2 -st true -cl true -cr 0 -d $pianyi -tol 0.01 -sd 5 -ugn false  -n $qvxian_pianyi_B  $qvxian_FF ;
          loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true  -n $qvxian_qvmian $qvxian_pianyi_A $qvxian_pianyi_B;
          int$size=size($qvmians);
          $qvmians[$size]=$qvxian_qvmian;
          delete $qvxian_pianyi_A $qvxian_pianyi_B $qvxian_FF;
          parent  $temp_qvxian $grp;
          parent $qvxian_D  $grp; 
          parent $qvxian_A  $grp;
          parent $qvxian_CC  $grp;
          parent $qvxian_HH $grp;
          parent $qvxian_DD $grp;
          parent $qvxian_qvmian $grp;
          rename $temp_qvxian ($qvxian_A+"A");
          rename $qvxian_A $temp_qvxian;
          rename ($qvxian_A+"A") $qvxian_A; 
          zxb_eye_qvmiankongzhiqqvxian_proc($qvxian_HH,$qvxian_qvmian);
          
         string$mode_qvmian=`zxb_tongkong_qvmian_mode_extract_proc($ui_name_mode)`;//创建曲面球
         string $nurbsSphere_a[]= stringToStringArray($mode_qvmian, " ");//字符串转化数组
         string$nurbsSphere=$nurbsSphere_a[0];
         $fuzhao_qvmian=$nurbsSphere;
         int$ex=`objExists $nurbsSphere`;
         if($ex==1){zxb_qvxian_gensui_yanqiu_fangfa_proc($qvxian_D,$qvxian_CC,$mode_qvmian);}else{error  "眼球曲面模型不存在";}
         
         
          } 
         string$temp_name_cu="";
         for ($aa=0;$aa<size($qvmians);$aa++) 
             {
             string$temp=$qvmians[$aa];
            select -r ($temp+".cv[0:999999999999][0:99999999]");
            string$cvs[]=`ls -sl -fl `;
            int$size=size($cvs);
            string$qw=$cvs[$size-1];
            string$ee[];
            clear$ee;
            int $nemt=`tokenize $qw "[" $ee`;//分离字符串存到变量
            int $nemt=`tokenize $ee[1] "]" $ee`;//分离字符串存到变量
            int$id=$ee[0] ;
            for ($m=1;$m<($id);$m++) 
             {  
             select -r ($temp+".cv["+$m+"][0:3]") ;
             string$temp_cu_s[]=` newCluster " -envelope 1"` ;
             $temp_name_cu+=$temp_cu_s[1]+" ";
             parent $temp_cu_s[1]$eye_cu_grp;
             }
         
           }
         
         select -r ($qvmians[0]+".cv[0][0:3]");
         select -add ($qvmians[1]+".cv[0][0:3]"); 
         string$temp_cu_ss[] =`newCluster " -envelope 1" `;
         $temp_name_cu+=$temp_cu_ss[1]+" ";
         parent $temp_cu_ss[1]$eye_cu_grp;
         select -r ($qvmians[0]+".cv[6][0:3]");
        select -add ($qvmians[1]+".cv[6][0:3]"); 
        string$temp_cu_sss[]=`newCluster " -envelope 1"` ;
        $temp_name_cu+=$temp_cu_sss[1]+" ";
        parent $temp_cu_sss[1]$eye_cu_grp;
        setAttr -type "string" ($head_qvxian+"."+$eye_cu_shuxing) $temp_name_cu;
        
        string$qianzui="L";
        if($e==1){$qianzui="R";}
        string$all_op_cs=$zhangkai_qvxian_A+$bihe_qvxian;
         int$ex=`objExists $mnians[0]`;    ///判断
         if($ex==1)
           {
            $qvmian_temp+=$fuzhao_qvmian+" ";
            zxb_child_object_proc($head_mode,$head_joinr,$temp_name_cu,0,1,0,0); //创建控制器
            string$bn_return=zxb_yanjing_yanpichuangjian_guanjie_proc($DD_QVXIAN,$eye_con_A,$fuzhao_qvmian,$e);
            $all_temp_eye_bn+=$bn_return;
            zxb_dingweiqi_kongzhiqvxian_eye($gensui_qvxian_D,$qianzui);
            zxb_dingweiqi_gensuiqvxian_A($all_op_cs,$qianzui);
            zxb_global_lalian_a($zhangkai_qvxian_A,$bihe_qvxian,$gensui_qvxian_D,$qianzui);
            
            zxb_bolangzui_a($gensui_qvxian_D);
            }
         
          //string$qvmian_zu[]=`listRelatives -p $qvmian_temp`; 
        int$ex=`objExists  $grp_lr_temp`;
        if($ex==1){ parent $fuzhao_qvmian  $grp_lr_temp;}
        string$UP_EYE_all_BN_pengzhuang_L="";
        string$DW_EYE_all_BN_pengzhuang_L="";
        string$UP_EYE_all_BN_pengzhuang_R="";
        string$DW_EYE_all_BN_pengzhuang_R="";
        /*string$string_eye_guge_temp[]={"UP_EYE_all_BN_pengzhuang_L","DW_EYE_all_BN_pengzhuang_L","UP_EYE_all_BN_pengzhuang_R","DW_EYE_all_BN_pengzhuang_R";}
        for ($q=0;$q<size($string_eye_guge_temp);$q++)
            {
             string$shuxing_temp_a=($UI_head_controller+"."+$string_eye_guge_temp;
             string$ex_a=`objExists  $grp_lr_temp`;
             }*/
        string $EYE_qvmian_dd_temp[]= stringToStringArray($DD_QVXIAN, " ");//字符串转化数组
        select -r$EYE_qvmian_dd_temp[0];
       float$ex_floata=`zxb_qvfengshangzi`;
        select -r $EYE_qvmian_dd_temp[1];
       float$ex_floatb=`zxb_qvfengshangzi`;
       string$up_qvxian="";
       string$dw_qvxian="";
       string$eye_kongzhi_L=$EYE_com_S[0];
       string$eye_kongzhi_R=$EYE_com_S[1];
       if($ex_floata>$ex_floatb){$up_qvxian=$EYE_qvmian_dd_temp[0];$dw_qvxian=$EYE_qvmian_dd_temp[1];}else{$up_qvxian=$EYE_qvmian_dd_temp[1];$dw_qvxian=$EYE_qvmian_dd_temp[0];}
       spaceLocator -p 0 0 0 -n "TEMP_LOC";
       delete `pointConstraint  $fuzhao_qvmian  "TEMP_LOC"`;
       float$pos_dia[]=`xform -q -ws -t  "TEMP_LOC"`;
       delete "TEMP_LOC";
       if($pos_dia[0]>0)
         {
         $UP_EYE_all_BN_pengzhuang_L=`getAttr ($UI_head_controller+".UP_EYE_all_BN_pengzhuang_L")`;
         $DW_EYE_all_BN_pengzhuang_L=`getAttr ($UI_head_controller+".DW_EYE_all_BN_pengzhuang_L")`;
         zxb_yanpi_pengzhuang_chengxu_proc($dw_qvxian,$eye_kongzhi_L,$DW_EYE_all_BN_pengzhuang_L,$fuzhao_qvmian);
         zxb_yanpi_pengzhuang_chengxu_proc($up_qvxian,$eye_kongzhi_L,$UP_EYE_all_BN_pengzhuang_L,$fuzhao_qvmian);
         }else
             {
                 
             $UP_EYE_all_BN_pengzhuang_R=`getAttr ($UI_head_controller+".UP_EYE_all_BN_pengzhuang_R")`;
             $DW_EYE_all_BN_pengzhuang_R=`getAttr ($UI_head_controller+".DW_EYE_all_BN_pengzhuang_R")`; 
              zxb_yanpi_pengzhuang_chengxu_proc($dw_qvxian,$eye_kongzhi_R,$DW_EYE_all_BN_pengzhuang_R,$fuzhao_qvmian);
              zxb_yanpi_pengzhuang_chengxu_proc($up_qvxian,$eye_kongzhi_R,$UP_EYE_all_BN_pengzhuang_R,$fuzhao_qvmian); 
             }
      
         
      }


    
    }
    
zxb_ADD_shuxing_string_proc($UI_head_controller,"eye_bn");
setAttr -type "string" ($UI_head_controller+".eye_bn") $all_temp_eye_bn;

}




//////////////////////曲面控制器曲线///////////////
global proc zxb_eye_qvmiankongzhiqqvxian_proc(string$xian,string$mian)
{
string $qvxian_Hs=$xian;
string$eeeee[];
clear $eeeee;
int $nemt=`tokenize $qvxian_Hs " " $eeeee`;//分离字符串存到变量
string $qvxian_H=$eeeee[0];

string $qvmian_Hs=$mian;
string$AAAAAA[];
clear $AAAAAA;
int $nemt=`tokenize  $qvmian_Hs " " $AAAAAA`;//分离字符串存到变量
string  $qvmian_H=$AAAAAA[0];
select -r  $qvxian_H $qvmian_H;
string $bianliang[]=`ls -sl`;//选择曲线 //手动控制曲线 加选曲面

////////////判断曲面还是曲线//////////////////
int$size=size($bianliang);
if($size!=2){error "请选中一个曲线和一个曲面两个物体";}
string$qvxian_temp="";
string$qvmian_temp="";
string$shape_a[]=`listRelatives -s $bianliang[0]`; 
string$shape_b[]=`listRelatives -s $bianliang[1]`; 
int$ex_a=`objExists $shape_a[0]`;
if($ex_a==0){error "选中的第一个物体没有型节点";}
int$ex_b=`objExists $shape_b[0]`;
if($ex_b==0){error "选中的第二个物体没有型节点";}
string$type_a=`nodeType $shape_a[0]`;

if($type_a=="nurbsCurve")
  {
    $qvxian_temp=$bianliang[0];
    $qvmian_temp=$bianliang[1];
  }else
       {
        $qvxian_temp=$bianliang[1];
        $qvmian_temp=$bianliang[0];
       }

  
      
/////////////////////////////创建曲面信息节点/////////////////////////////////////////////////////
string$qvmian_closestPointOnSurface=($qvmian_temp+"_closestPointOnSurface_yanpi");
string$qvmian_shape[]=`listRelatives -s $qvmian_temp`; 
string$qvmianshape=$qvmian_shape[0];
int$panduan_B=`objExists $qvmian_closestPointOnSurface`;
if($panduan_B==1){delete $qvmian_closestPointOnSurface;}
shadingNode -asUtility closestPointOnSurface  -n $qvmian_closestPointOnSurface;
connectAttr -force ($qvmianshape+".worldSpace[0]") ($qvmian_closestPointOnSurface+".inputSurface");

/////////////选中曲线////////////////////////
select -r ($qvxian_temp+".cv[0:999999999]");
string $cvs[]=`ls -sl -fl`;
 
for ($i=0;$i<size($cvs);$i++)
{
    
    
    ////////////////////曲面最近点节点 赋值最近点节点////////////////////////////
   string$cv=$cvs[$i];
   string$qvmian_pointOnSurfaceInfo=($qvmian_temp+"_pointOnSurfaceInfo_yanpi"+$i);
   int$panduan_A=`objExists $qvmian_pointOnSurfaceInfo`;
   if($panduan_A==1){delete $qvmian_pointOnSurfaceInfo;}
   shadingNode -asUtility pointOnSurfaceInfo  -n $qvmian_pointOnSurfaceInfo;
   float$pos_dia[]=`xform -q -ws -t $cv`;
   setAttr -type float3 ($qvmian_closestPointOnSurface+".inPosition") $pos_dia[0] $pos_dia[1] $pos_dia[2];
   float$U=`getAttr ($qvmian_closestPointOnSurface+".parameterU")`;
   float$V=`getAttr ($qvmian_closestPointOnSurface+".parameterV")`;
   setAttr ($qvmian_pointOnSurfaceInfo+".parameterU") $U;//获得U值
   setAttr ($qvmian_pointOnSurfaceInfo+".parameterV") $V;//获得V值
   connectAttr -force ($qvmianshape+".worldSpace[0]") ($qvmian_pointOnSurfaceInfo+".inputSurface");//连接曲面
   
   ///////////////////////////创建定位器连接到曲线上（定位器被曲面控制 定位器控制曲线）//////////////////////////////////////////////////
   string$zu_A=($qvmian_temp+"_eye_grp_loc");
   string$eye_loc=($qvxian_temp+"_eye_loc_"+$i);
   string$eye_loc_grp_a=($eye_loc+"_GRP_A");
   string$eye_loc_grp_b=($eye_loc+"_GRP_B");

   int$panduan_A=`objExists $zu_A`;
   if($panduan_A==0)
      {
          select -cl  ;
         group -empty -n  $zu_A;
         setAttr ($zu_A+".visibility") 0;
         setAttr -lock true ($zu_A+".v");   
         string$qvmian_zu[]=`listRelatives -p $qvmian_temp`; 
         int$panduan_A=`objExists $qvmian_zu[0]`;
         if($panduan_A==1){ parent $zu_A $qvmian_zu[0];}
        
      }
      
      spaceLocator -p 0 0 0 -n $eye_loc;
      group -n $eye_loc_grp_a;
      group -n $eye_loc_grp_b;
      parent $eye_loc_grp_b $zu_A;
      connectAttr -f ($qvmian_pointOnSurfaceInfo+".position") ($eye_loc_grp_b+".t");//连接定位器  这个位置是曲面的位置  与曲线顶点的位置有偏移
      ///////////////////矫正偏移  保证定位器一点在曲线点上/////////////////////
      xform -ws -t $pos_dia[0] $pos_dia[1] $pos_dia[2] $eye_loc_grp_a;
      string$loc_sheps[]=`listRelatives -s $eye_loc`; 
      string$loc_shep=$loc_sheps[0];
      connectAttr -f ($loc_shep+".worldPosition[0]")  ($qvxian_temp+".controlPoints["+$i+"]");//定位器控制曲线
      
      
   } 
   
   delete $qvmian_closestPointOnSurface;
}




////////////////////曲线跟随曲面////////////////////////////////

global proc zxb_qvxian_gensui_qvxian_fangfa_proc()
{
  
string $qvxian_jichus=`textFieldGrp -q -tx  zxb_zairuqvxian_jichu`;
string$eeeee[];
clear $eeeee;
int $nemt=`tokenize $qvxian_jichus " " $eeeee`;//分离字符串存到变量
string $qvxian_jichu=$eeeee[0];

string $qvxian_cs=`textFieldGrp -q -tx  zxb_zairuqvxian_c`;
string$AAAAAA[];
clear $AAAAAA;
int $nemt=`tokenize  $qvxian_cs " " $AAAAAA`;//分离字符串存到变量
string  $qvxian_c=$AAAAAA[0];


string $qvmian_qiu_as=`textFieldGrp -q -tx  zxb_qvmianqiu_c`;
string$ttttt[];
clear $ttttt;
int $nemt=`tokenize  $qvmian_qiu_as " " $ttttt`;//分离字符串存到变量
string   $qvmian_qiu_a=$ttttt[0];

select -r  $qvxian_jichu $qvmian_qiu_a;
  
string $bianliang[]=`ls -sl`;// 跟随眼皮的曲线  加选眼球的曲面  制作曲线附着曲面 （曲线跟随没有删除历史的曲线并附着在眼球曲面上）

////////////判断曲面还是曲线//////////////////
int$size=size($bianliang);
if($size!=2){error "请选中一个曲线和一个曲面两个物体";}
string$qvxian_temp="";
string$qvmian_temp="";

string$shape_a[]=`listRelatives -s $bianliang[0]`; 
string$shape_b[]=`listRelatives -s $bianliang[1]`; 
int$ex_a=`objExists $shape_a[0]`;
if($ex_a==0){error "选中的第一个物体没有型节点";}
int$ex_b=`objExists $shape_b[0]`;
if($ex_b==0){error "选中的第二个物体没有型节点";}
string$type_a=`nodeType $shape_a[0]`;

if($type_a=="nurbsCurve")
  {
    $qvxian_temp=$bianliang[0];
    $qvmian_temp=$bianliang[1];
  }else
       {
        $qvxian_temp=$bianliang[1];
        $qvmian_temp=$bianliang[0];
       }

  


string$gensuiqvxian=$qvxian_c;
select -r ($qvxian_temp+".cv[0:99999999999]");
string $cvs[]=`ls -sl -fl`;
int$CVshu=size($cvs);
string$qvxian_shape[]=`listRelatives -s $qvxian_temp`; 
string$qvmian_shapes[]=`listRelatives -s $qvmian_temp`; 
string$qvxianshape=$qvxian_shape[0];
string$qvmianshape=$qvmian_shapes[0];

string$qvxian_nearestPointOnCurve=($gensuiqvxian+"_nearestPointOnCurve_yanpi");
int$panduan_B=`objExists$qvxian_nearestPointOnCurve`;
if($panduan_B==1){delete $qvxian_nearestPointOnCurve;}
shadingNode -asUtility nearestPointOnCurve  -n $qvxian_nearestPointOnCurve;
connectAttr -force ($qvxianshape+".worldSpace[0]") ($qvxian_nearestPointOnCurve+".inputCurve");
for ($i=0;$i<$CVshu;$i++)
    {
       string$cv_name_A=($qvxian_temp+".cv["+$i+"]");
       string$cv_name_B=($gensuiqvxian+".cv["+$i+"]");
       float$pos_A[]=`xform -q -ws -t $cv_name_A`;
       
       setAttr -type float3 ($qvxian_nearestPointOnCurve+".inPosition") $pos_A[0] $pos_A[1] $pos_A[2];
       float$param=`getAttr ($qvxian_nearestPointOnCurve+".parameter")`;
       
        string$qvxianpointOnCurveInfo=($qvxian_temp+"_pointOnCurveInfo_gensui_loc_"+$i);
        int$ex=`objExists $qvxianpointOnCurveInfo`;
        if($ex==1){delete $qvxianpointOnCurveInfo;}
        shadingNode -asUtility pointOnCurveInfo  -n $qvxianpointOnCurveInfo;
        connectAttr -force ($qvxianshape+".worldSpace[0]") ($qvxianpointOnCurveInfo+".inputCurve");
        setAttr  ($qvxianpointOnCurveInfo+".parameter")  $param;//通过曲线获得一个位置
     
     
        ////////////////////创建曲面球的曲面信息节点//////////////////////////////////
        string$qvmianclosestPointOnSurface=($gensuiqvxian+"_closestPointOnSurface_"+$i);
         int$ex=`objExists $qvmianclosestPointOnSurface`;
        if($ex==1){delete $qvmianclosestPointOnSurface;}
        shadingNode -asUtility closestPointOnSurface  -n $qvmianclosestPointOnSurface;
        connectAttr -force ($qvmianshape+".worldSpace[0]") ($qvmianclosestPointOnSurface+".inputSurface");
        connectAttr -force ($qvxianpointOnCurveInfo+".position") ($qvmianclosestPointOnSurface+".inPosition");

       /* float$pos_weizhi[]=`getAttr   ($qvxianpointOnCurveInfo+".position")`;
        setAttr -type float3 ($qvmianclosestPointOnSurface+".inPosition") $pos_weizhi[0] $pos_weizhi[1] $pos_weizhi[2];//赋值给曲面最近点节点（曲线信息节点的值）  
        
        */
        ////////////创建定位器//////////////////////
        string$loc=($gensuiqvxian+"_eye_yanpi_gensui_loc"+$i);
        string$loc_grp_a=($loc+"_grp_A");
        string$loc_grp_b=($loc+"_grp_B");
        spaceLocator -p 0 0 0 -n $loc;
        group -n $loc_grp_a;
        group -n $loc_grp_b;
        string$root_zu=($gensuiqvxian+"_eye_yanpi_gensui_root_grp");
        int$ex=`objExists $root_zu`;
        if( $ex==0)
          {
           
           select -cl  ;
           group -empty -n  $root_zu;
           setAttr ($root_zu+".visibility") 0;
           setAttr -lock true ($root_zu+".v"); 
           }
        parent $loc_grp_b $root_zu;
        
        
        connectAttr -force  ($qvmianclosestPointOnSurface+".position") ($loc_grp_b+".t");//定位器的组跟随曲面
        xform -ws -t $pos_A[0] $pos_A[1] $pos_A[2] $loc_grp_a;//定位器偏移
        
        string$loc_shapes[]=`listRelatives -s $loc `; 
        string$loc_shape=$loc_shapes[0];
        connectAttr -force ($loc_shape+".worldPosition[0]") ($gensuiqvxian+".controlPoints["+$i+"]");//定位器控制器曲线


    }

delete $qvxian_nearestPointOnCurve; 
}




///////////////////////////////////////生成曲面模型/////////////////////////////////////////////////////
global proc string  zxb_tongkong_qvmian_mode_extract_proc(string$UI_eye_L_mode)
{
    
string $dian_aa=`textFieldGrp -q -tx $UI_eye_L_mode `;


string$moxing_ss[];
clear $moxing_ss;
$moxing_ss[0]=$dian_aa;

string$mode_qvmian_sss="";
for($jjj=0;$jjj<size($moxing_ss);$jjj++)
    {
    string$aaa=$moxing_ss[$jjj];
    string$mode=$aaa;
    int$ex_a=`objExists $mode`;
    if($ex_a==1)
      {
  //创建眼球模型跟曲面
string$qiu=($mode+"_qiu_eye");
string$qiunurb=($mode+"_nur_eye");
$mode_qvmian_sss+=$qiunurb+" ";
int$ex=`objExists $qiunurb`;
if($ex==0)
{

polySphere -r 1 -sx 20 -sy 20 -ax 0 0 1 -cuv 2 -ch 1 -n $qiu;
sphere -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -d 3 -ut 0 -tol 0.01 -s 50 -nsp 50 -ch 0 -n $qiunurb;
string$qvmian_shapes[]=`listRelatives -s $qiunurb`;
string$qvmian_shape=$qvmian_shapes[0];
select -cl  ;
select -r $mode;
newCluster " -envelope 1";
string$cua[]=`ls -sl`;
delete` pointConstraint $cua[0] $qiu`;

delete  $cua[0] ;

//创建的模型尽量靠近原始模型
float$boxs[]=`getAttr ($mode+".boundingBoxSize")`;
float$beishu=0.5;
setAttr -type float3 ($qiu+".s") ($boxs[0]*$beishu) ($boxs[1]*$beishu) ($boxs[2]*$beishu);
delete` pointConstraint $qiu $qiunurb`;
delete` scaleConstraint $qiu $qiunurb`;
string$modejiedian=($mode+"yanqiu_closestPointOnMesh");
string$shaps[]=`listRelatives -s $mode`;
string$shap=$shaps[0];
int$ex=`objExists $modejiedian`;
if($ex==1){delete $modejiedian; }
createNode "closestPointOnMesh" -n $modejiedian; //多边型最近点节点
select -r ($qiu+".vtx[0:999999999]");
connectAttr -force ($shap+".worldMesh[0]")  ($modejiedian+".inMesh");
string $qiu_ves[]=`ls -sl -fl`;//顶点
for($i=0;$i<size($qiu_ves);$i++)
   {
       string$dian=$qiu_ves[$i];
       float$pos_temps[]=`xform -q -ws -t  $dian`;
       setAttr -type float3 ($modejiedian+".inPosition") $pos_temps[0] $pos_temps[1] $pos_temps[2] ;
       float $xingpos[]=`getAttr ($modejiedian+".position")`;
       xform -ws -t $xingpos[0] $xingpos[1] $xingpos[2] $dian;
       
   }

select -r ( $qiunurb+".cv[0:999999999]");
string $qiu_vesa[]=`ls -sl -fl`;//顶点
for($i=0;$i<size($qiu_vesa);$i++)
   {
       string$dian=$qiu_vesa[$i];
       float$pos_temps[]=`xform -q -ws -t  $dian`;
       setAttr -type float3 ($modejiedian+".inPosition") $pos_temps[0] $pos_temps[1] $pos_temps[2] ;
       float $xingpos[]=`getAttr ($modejiedian+".position")`;
       xform -ws -t $xingpos[0] $xingpos[1] $xingpos[2] $dian;
       
   }
delete $qiu;
        }
      }

     
     }


return $mode_qvmian_sss;
}



global proc zxb_qvxian_gensui_yanqiu_fangfa_proc(string$jichu,string$jichu_C,string$jichu_qvmian)
{
  

string $qvxian_jichu=$jichu;
string  $qvxian_c=$jichu_C;
string   $qvmian_qiu_a=$jichu_qvmian;

select -r  $qvxian_jichu $qvmian_qiu_a;
  
string $bianliang[]=`ls -sl`;// 跟随眼皮的曲线  加选眼球的曲面  制作曲线附着曲面 （曲线跟随没有删除历史的曲线并附着在眼球曲面上）

////////////判断曲面还是曲线//////////////////
int$size=size($bianliang);
if($size!=2){error "请选中一个曲线和一个曲面两个物体";}
string$qvxian_temp="";
string$qvmian_temp="";

string$shape_a[]=`listRelatives -s $bianliang[0]`; 
string$shape_b[]=`listRelatives -s $bianliang[1]`; 
int$ex_a=`objExists $shape_a[0]`;
if($ex_a==0){error "选中的第一个物体没有型节点";}
int$ex_b=`objExists $shape_b[0]`;
if($ex_b==0){error "选中的第二个物体没有型节点";}
string$type_a=`nodeType $shape_a[0]`;

if($type_a=="nurbsCurve")
  {
    $qvxian_temp=$bianliang[0];
    $qvmian_temp=$bianliang[1];
  }else
       {
        $qvxian_temp=$bianliang[1];
        $qvmian_temp=$bianliang[0];
       }

  


string$gensuiqvxian=$qvxian_c;
select -r ($qvxian_temp+".cv[0:99999999999]");
string $cvs[]=`ls -sl -fl`;
int$CVshu=size($cvs);
string$qvxian_shape[]=`listRelatives -s $qvxian_temp`; 
string$qvmian_shapes[]=`listRelatives -s $qvmian_temp`; 
string$qvxianshape=$qvxian_shape[0];
string$qvmianshape=$qvmian_shapes[0];

string$qvxian_nearestPointOnCurve=($gensuiqvxian+"_nearestPointOnCurve_yanpi");
int$panduan_B=`objExists$qvxian_nearestPointOnCurve`;
if($panduan_B==1){delete $qvxian_nearestPointOnCurve;}
shadingNode -asUtility nearestPointOnCurve  -n $qvxian_nearestPointOnCurve;
connectAttr -force ($qvxianshape+".worldSpace[0]") ($qvxian_nearestPointOnCurve+".inputCurve");
for ($i=0;$i<$CVshu;$i++)
    {
       string$cv_name_A=($qvxian_temp+".cv["+$i+"]");
       string$cv_name_B=($gensuiqvxian+".cv["+$i+"]");
       float$pos_A[]=`xform -q -ws -t $cv_name_A`;
       
       setAttr -type float3 ($qvxian_nearestPointOnCurve+".inPosition") $pos_A[0] $pos_A[1] $pos_A[2];
       float$param=`getAttr ($qvxian_nearestPointOnCurve+".parameter")`;
       
        string$qvxianpointOnCurveInfo=($qvxian_temp+"_pointOnCurveInfo_gensui_loc_"+$i);
        int$ex=`objExists $qvxianpointOnCurveInfo`;
        if($ex==1){delete $qvxianpointOnCurveInfo;}
        shadingNode -asUtility pointOnCurveInfo  -n $qvxianpointOnCurveInfo;
        connectAttr -force ($qvxianshape+".worldSpace[0]") ($qvxianpointOnCurveInfo+".inputCurve");
        setAttr  ($qvxianpointOnCurveInfo+".parameter")  $param;//通过曲线获得一个位置
     
     
        ////////////////////创建曲面球的曲面信息节点//////////////////////////////////
        string$qvmianclosestPointOnSurface=($gensuiqvxian+"_closestPointOnSurface_"+$i);
         int$ex=`objExists $qvmianclosestPointOnSurface`;
        if($ex==1){delete $qvmianclosestPointOnSurface;}
        shadingNode -asUtility closestPointOnSurface  -n $qvmianclosestPointOnSurface;
        connectAttr -force ($qvmianshape+".worldSpace[0]") ($qvmianclosestPointOnSurface+".inputSurface");
        connectAttr -force ($qvxianpointOnCurveInfo+".position") ($qvmianclosestPointOnSurface+".inPosition");

       /* float$pos_weizhi[]=`getAttr   ($qvxianpointOnCurveInfo+".position")`;
        setAttr -type float3 ($qvmianclosestPointOnSurface+".inPosition") $pos_weizhi[0] $pos_weizhi[1] $pos_weizhi[2];//赋值给曲面最近点节点（曲线信息节点的值）  
        
        */
        ////////////创建定位器//////////////////////
        string$loc=($gensuiqvxian+"_eye_yanpi_gensui_loc"+$i);
        string$loc_grp_a=($loc+"_grp_A");
        string$loc_grp_b=($loc+"_grp_B");
        spaceLocator -p 0 0 0 -n $loc;
        group -n $loc_grp_a;
        group -n $loc_grp_b;
        string$root_zu=($gensuiqvxian+"_eye_yanpi_gensui_root_grp");
        int$ex=`objExists $root_zu`;
        if( $ex==0)
          {
           
           select -cl  ;
           group -empty -n  $root_zu;
           setAttr ($root_zu+".visibility") 0;
           setAttr -lock true ($root_zu+".v"); 
           string$qvxian_fuwuti_s[]=`listRelatives -p $jichu_C`; 
           int$ex=`objExists $qvxian_fuwuti_s[0]`;
           if($ex==1){ parent $root_zu $qvxian_fuwuti_s[0]; }
           }
        parent $loc_grp_b $root_zu;
        
        
        connectAttr -force  ($qvmianclosestPointOnSurface+".position") ($loc_grp_b+".t");//定位器的组跟随曲面
        xform -ws -t $pos_A[0] $pos_A[1] $pos_A[2] $loc_grp_a;//定位器偏移
        
        string$loc_shapes[]=`listRelatives -s $loc `; 
        string$loc_shape=$loc_shapes[0];
        connectAttr -force ($loc_shape+".worldPosition[0]") ($gensuiqvxian+".controlPoints["+$i+"]");//定位器控制器曲线


    }

delete $qvxian_nearestPointOnCurve; 
}





global proc string zxb_yanjing_yanpichuangjian_guanjie_proc(string$qvxian_dds,string$yanjingkongzhiqi,string$qvmianqiu,int$qq_lr) ///////////////////////////////////////创建关节
{
    
string$return_string="";  
    
string $qvxian_Dss=$qvxian_dds;
string $qvxian_Ds[]= stringToStringArray($qvxian_Dss," ");//字符串转化数组
string $head_com=`textFieldGrp -q -tx UI_head_controller `;


string $kongzhiqiss=$yanjingkongzhiqi;
string$AAAAAA[];
clear $AAAAAA;
int $nemt=`tokenize  $kongzhiqiss " " $AAAAAA`;//分离字符串存到变量
string  $kongzhiqi=$AAAAAA[0];


string $qvmian_qiu_as=$qvmianqiu;
string$ttttt[];
clear $ttttt;
int $nemt=`tokenize  $qvmian_qiu_as " " $ttttt`;//分离字符串存到变量
string   $qvmian_qiu_a=$ttttt[0];
//int$duicheng_bn=`checkBox -q  -value   duichengA`;

string $qvxians[]=$qvxian_Ds;//选中曲线  D
string$yanqiu_con=$kongzhiqi;//眼球控制器名字
string$qiuti=$qvmian_qiu_a;
int$L_R=$qq_lr;
string$upqvxian="";
string$dwqvxian="";
string$obj_nanme="";
string$qvmianshapes[]=`listRelatives -s $qiuti`; 
string$qvmianshape=$qvmianshapes[0];


//////添加属性连接连接范围节点及反向节点
int$ex=`objExists ($yanqiu_con+".gensui")`;
if($ex==0){addAttr -ln "gensui"  -at double  -min 0 -max 10 -dv 10 -k 1 $yanqiu_con ;}
string$fanweijiedian=($yanqiu_con+"_eye_yanpi_kongzhiqi_setRange");
int$ex=`objExists $fanweijiedian`;
if($ex==1){delete $fanweijiedian;}
shadingNode -asUtility setRange -n $fanweijiedian;
string$fanxiangjiedian=($yanqiu_con+"_eye_yanpi_kongzhiqi_reverse");
int$ex=`objExists $fanxiangjiedian`;
if($ex==1){delete $fanxiangjiedian;}
shadingNode -asUtility reverse -n $fanxiangjiedian;
setAttr ($fanweijiedian+".oldMaxX") 10;
setAttr ($fanweijiedian+".maxX") 1;
connectAttr -f ($yanqiu_con+".gensui") ($fanweijiedian+".valueX");
connectAttr -f ($fanweijiedian+".outValueX") ($fanxiangjiedian+".inputX");
string$fanweijijiedianshuchu_A=($fanweijiedian+".outValueX");
string$fanxiangjiedianshuchu_B=($fanxiangjiedian+".outputX");

/////////////////////////判断程序那条曲线是上下///////////////////////
float$ty=-10000000000000;
for ($i=0;$i<size($qvxians);$i++)
{
   string$qvxian=$qvxians[$i];
    string$shapes[]=`listRelatives -s $qvxian`; 
    string$shape=$shapes[0];
    string$type=`nodeType $shape`;
    select -r ($qvxian+".cv[0:999999999999]");
    string $cv_s[]=`ls -sl -fl`;
    for ($j=0;$j<size($cv_s);$j++)
        {
         float$pos_cv[]=`xform -q -ws -t $cv_s[$j]`;
         if($pos_cv[1]>$ty)
            {
            $ty=$pos_cv[1];
            $obj_nanme=$qvxian;
            }
         }
    
}

$upqvxian=$obj_nanme;
select -r $qvxians;
select -d $upqvxian;
string $qvxians_dws[]=`ls -sl`;
$dwqvxian=$qvxians_dws[0];
select -r  $upqvxian;
select -add  $dwqvxian;
string $qvxians_s[]=`ls -sl`;




string$eye_bn[];

string$DW_UP="";
string$DW_UP_LR="";
for ($ii=0;$ii<size($qvxians_s);$ii++)
{
    clear $eye_bn;
    string$qvxian=$qvxians_s[$ii];
    string$fuwuti[]=`listRelatives -p $qvxian`;
    int$panduan=`objExists$fuwuti[0]`;

    select -r ($qvxian+".cv[0:9999999999999]");
    string $qvxians_cvs[]=`ls -sl -fl`;
    
    if($ii==0){$DW_UP="UP";}
    if($ii==1){$DW_UP="DW";}
    float $RL_LIST[]= `xform -q -ws -t $qvxians_cvs[0]`;
    if($RL_LIST[0]>0){$DW_UP_LR="L";}
    if($RL_LIST[0]<0){$DW_UP_LR="R";}
    string$eyey_bn_shuxing=$DW_UP+"_EYE_all_BN"+$DW_UP_LR;
    string$eyey_bn_shuxing_pengzhuang=$DW_UP+"_EYE_all_BN_pengzhuang_"+$DW_UP_LR;
    zxb_ADD_shuxing_string_proc($head_com,$eyey_bn_shuxing);
     zxb_ADD_shuxing_string_proc($head_com,$eyey_bn_shuxing_pengzhuang);
    string$temp_eyey_bn_shuxing="";
    string$temp_eyey_bn_shuxing_pengzhuang="";
    //////////区分上眼皮与下眼皮
    int$jiesu=size($qvxians_cvs);
    int$kaishi=0;
    if($ii==1)
      {
          $jiesu=$jiesu-1;
          $kaishi=1;
      }
      
      string$qianzui="L";
      if($L_R==0){$qianzui="R";}
      string$BN_name=("eye_yanpi_"+$qvxian+$qianzui);
      
      
      string$loc_grp=($BN_name+"_grp");
      int$ex=`objExists $loc_grp`;
      if($ex==0)
         {
         select -cl  ;
         group -empty -n  $loc_grp; //创建定位器空组
         setAttr ($loc_grp+".visibility") 0;
         setAttr -lock true ($loc_grp+".v");
         
         if($panduan==1){parent $loc_grp $fuwuti[0];}
         }
     
     string$qvxian_zuijingdianjiedian=($qvxian+"_eye_yanpi_nearestPointOnCurve");//曲线最近点节点（定位器跟随时需要）
     int$ex=`objExists $qvxian_zuijingdianjiedian`;
     if($ex==1){delete $qvxian_zuijingdianjiedian;}
     createNode "nearestPointOnCurve" -n $qvxian_zuijingdianjiedian;
    string$qvxian_shaps[]=`listRelatives -s $qvxian`;
    string$qvxianshap=$qvxian_shaps[0];
    connectAttr -force ($qvxianshap+".worldSpace[0]")  ($qvxian_zuijingdianjiedian+".inputCurve");
   for ($iii=$kaishi;$iii<$jiesu;$iii++)
       {
        string$bn_name=($BN_name+"_"+$iii);
        string$bn_loc=($bn_name+"_loc");
        string$bn_loc_A=($bn_name+"_loc_fuzhao_");
        string$bn_loc_B=($bn_name+"_loc_gensui_qvxian");

        string$bn_loc_A_grp_A=($bn_name+"_loc_fuzhao_grp_A");
        string$bn_loc_A_grp_B=($bn_name+"_loc_fuzhao_grp_B");


        string$cv=$qvxians_cvs[$iii];
        float$pos_temp[]=`xform -q -ws -t  $cv`;
        select -cl  ;
        joint -p $pos_temp[0] $pos_temp[1] $pos_temp[2] -n $bn_name;//创建关节
        $return_string+=$bn_name+" ";
        $temp_eyey_bn_shuxing+=$bn_name+" ";
        if($ii==0)
          {
          if($iii>=1){$temp_eyey_bn_shuxing_pengzhuang+=$bn_name+" ";}
          }
        if($ii==1)
          {
          $temp_eyey_bn_shuxing_pengzhuang+=$bn_name+" ";
          }
        $eye_bn[$iii]=$bn_name;
        spaceLocator -p 0 0 0 -n $bn_loc;//创建定位器
        parent $bn_loc $loc_grp;
        delete`pointConstraint $bn_name $bn_loc`;
        pointConstraint $bn_loc  $bn_name ;//定位器约束关节
        select -r $qiuti;
        select -add $bn_name;
        ////////////////眼球曲面约束骨骼/////////////////////
        normalConstraint -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0;
        
        
        spaceLocator -p 0 0 0 -n $bn_loc_A;//创建定位器  跟随曲面
        group -n $bn_loc_A_grp_A;
        group -n $bn_loc_A_grp_B;
        parent  $bn_loc_A_grp_B  $loc_grp;
        
        spaceLocator -p 0 0 0 -n $bn_loc_B;//创建定位器  跟随曲线
        parent  $bn_loc_B $loc_grp;
        setAttr -type float3 ($qvxian_zuijingdianjiedian+".inPosition") $pos_temp[0] $pos_temp[1] $pos_temp[2] ;
        float$param=`getAttr ($qvxian_zuijingdianjiedian+".parameter")`;
        
        
        
       string$loc_juiedian=($qvxian+"_eye_yanpi_loc_pointOnCurveInfo"+$iii);//曲线信息节点
       int$ex=`objExists $loc_juiedian`;
       if($ex==1){delete $loc_juiedian;}
       createNode "pointOnCurveInfo" -n $loc_juiedian;
       connectAttr -force ($qvxianshap+".worldSpace[0]")  ($loc_juiedian+".inputCurve");
       setAttr ($loc_juiedian+".parameter") $param;
       connectAttr -force ($loc_juiedian+".position") ($bn_loc_B+".t");//定位器跟随曲线
       
       
       string$qvmianzuijiandian=($qvxian+"eye_yanpi_pos_closestPointOnSurface_"+$iii);
       int$ex=`objExists $qvmianzuijiandian`;
       if($ex==1){delete $qvmianzuijiandian;}
       createNode "closestPointOnSurface" -n $qvmianzuijiandian;
       connectAttr -force  ($qvmianshape+".worldSpace[0]") ($qvmianzuijiandian+".inputSurface");
       connectAttr -force  ($bn_loc_B+".t")  ($qvmianzuijiandian+".inPosition");
       connectAttr -force    ($qvmianzuijiandian+".position") ($bn_loc_A_grp_B+".t");//定位器组跟随曲面
       delete`pointConstraint $bn_loc_B $bn_loc_A_grp_A`;

       
       select -r $bn_loc_A;
       select -add $bn_loc_B;
       select -add $bn_loc;
       string$dian_yuesu[]=`pointConstraint`;
       
       connectAttr -force $fanweijijiedianshuchu_A  ($dian_yuesu[0]+"."+$bn_loc_A+"W0");
       connectAttr -force $fanxiangjiedianshuchu_B  ( $dian_yuesu[0]+"."+$bn_loc_B+"W1");

        }  
      
      
      string$bn_root=($qvxian+"eye_root_"+$qianzui);
      int$ex=`objExists $bn_root`;
      if($ex==0)
         {
             select -cl  ;
             joint -p 0 0 0-n $bn_root;//创建跟关节
             setAttr ($bn_root+".drawStyle") 2;
             for ($m=0;$m<size($eye_bn);$m++)
                 {
                     string$aa=$eye_bn[$m];
                     if($aa!="")
                       {
                         select -add $eye_bn[$m];
                        }
                  }
            // select -r $eye_bn;
             select -add $bn_root;
             delete`pointConstraint`;
             if($panduan==1){ parent $bn_root $fuwuti[0];}
             
            
          }
          
       select -cl  ;
       for ($m=0;$m<size($eye_bn);$m++)
       {
           string$aa=$eye_bn[$m];
           if($aa!="")
           {
            select -add $eye_bn[$m];
            }
       }
       select -add $bn_root;
       parent;
     
       //print $qvxians;
       
       delete $qvxian_zuijingdianjiedian;
       
       
       setAttr -type "string" ($head_com+"."+$eyey_bn_shuxing) $temp_eyey_bn_shuxing;
       setAttr -type "string" ($head_com+"."+$eyey_bn_shuxing_pengzhuang) $temp_eyey_bn_shuxing_pengzhuang;
      
}



return $return_string;
}


//////////////定位器控制器曲线/////////////////////

global proc  zxb_dingweiqi_kongzhiqvxian_eye(string$ddd_qvxian,string$qvxian_qianzui)
{
//string $bianliang[]=`ls -sl`;//选中曲线D  没有历史记录的曲线
 string $bianliang_sss=$ddd_qvxian;
string $bianliang[]= stringToStringArray($bianliang_sss, " ");//字符串转化数组
string $qianzui=$qvxian_qianzui;


string$curve_temp="zxb_"+$qianzui+"_curve_follow__grp";

zxb_ADD_kongzu_proc($curve_temp);
parent $curve_temp "Face_Group";
for($i=0;$i<size($bianliang);$i++) 
{
    string $qvxian_A=$bianliang[$i];
    select -r ($qvxian_A+".cv[0:999999999999]");
    string  $cvs[]=`ls -sl -fl`;
    
    int $panduan=`objExists ($qvxian_A+"_locGrp")`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete ($qvxian_A+"_locGrp");
        }
     select -cl  ;
     group -empty -n ($qvxian_A+"_locGrp");
     setAttr ($qvxian_A+"_locGrp.visibility") 0;
     setAttr -lock true ($qvxian_A+"_locGrp"+".v");
     
     parent($qvxian_A+"_locGrp") $curve_temp ;
     int $panduanA=`objExists ($qvxian_A+"_gengsui_"+"nearestPointOnCurve")`;//查询这个物体是否纯在
     if($panduanA==1){ delete ($qvxian_A+"_gengsui_"+"nearestPointOnCurve");}
     createNode nearestPointOnCurve -n  ($qvxian_A+"_gengsui_"+"nearestPointOnCurve");//创建曲线最近点节点
     string $qvxian_shp[]=`listRelatives -s $qvxian_A`;
     connectAttr -force ($qvxian_shp[0]+".worldSpace[0]")  ($qvxian_A+"_gengsui_"+"nearestPointOnCurve.inputCurve");
       
    for($j=0;$j<size($cvs);$j++) 
    {
        string  $cvdian_bianliang=$cvs[$j];
       spaceLocator -p 0 0 0 -n($qvxian_A+"_loc_A_"+$j);
       spaceLocator -p 0 0 0 -n($qvxian_A+"_loc_B_"+$j);
       parent ($qvxian_A+"_loc_B_"+$j)  ($qvxian_A+"_loc_A_"+$j);
       
       select -r ($qvxian_A+"_loc_B_"+$j);
       group -n  ($qvxian_A+"_locgrp_"+$j);
       group -n  ($qvxian_A+"_locgrp_A"+$j);
       group -n  ($qvxian_A+"_locgrp_B"+$j);
       //parent  ($qvxian_A+"_locgrp_B"+$j) ($qvxian_A+"_loc_A_"+$j);
       parent  ($qvxian_A+"_loc_A_"+$j) ($qvxian_A+"_locGrp");
       float $poslist[]= `xform -q -ws -t  $cvdian_bianliang`;
       setAttr -type float3 ($qvxian_A+"_gengsui_"+"nearestPointOnCurve"+".inPosition") $poslist[0] $poslist[1] $poslist[2];
       float $poslist_A[]=`getAttr ($qvxian_A+"_gengsui_"+"nearestPointOnCurve"+".position")`;
      xform -ws -t    $poslist_A[0] $poslist_A[1] $poslist_A[2] ($qvxian_A+"_loc_A_"+$j);//定位器1的位置
       xform -ws -t  $poslist[0] $poslist[1] $poslist[2]($qvxian_A+"_loc_B_"+$j) ;//定位器1的位置
       string $loc_shp[]=`listRelatives -s ($qvxian_A+"_loc_B_"+$j)`;
       connectAttr -f ($loc_shp[0]+".worldPosition[0]") ($qvxian_shp[0]+".controlPoints["+$j+"]");
     }
     
     delete  ($qvxian_A+"_gengsui_"+"nearestPointOnCurve");
}


}



////////////////////////////曲线控制器定位器//////////////////////////////////////////

global proc  zxb_dingweiqi_gensuiqvxian_A(string$qvxian,string$qianzui)
{
//string $bianliang[]=`ls -sl`;//选中另外4条曲线
string $bianliang_sss=$qvxian;
string $bianliang[]= stringToStringArray($bianliang_sss, " ");//字符串转化数组
string $qianzui=$qianzui;

string$qvxianzu="zxb_"+$qianzui+"_curve_open_close_grp";

zxb_ADD_kongzu_proc($qvxianzu);
parent $qvxianzu "Face_Group";
 int $panduan_A=`objExists ("temp_qvxian_nearestPointOnCurve")`;//查询这个物体是否纯在
 if($panduan_A==1){delete ("temp_qvxian_nearestPointOnCurve"); }
createNode nearestPointOnCurve -n  ("temp_qvxian_nearestPointOnCurve");//创建曲线最近点节点

for($i=0;$i<size($bianliang);$i++) 
{
    string $qvxian=$bianliang[$i]; 
     string $qvxian_shp[]=`listRelatives -s $qvxian`;
     connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ("temp_qvxian_nearestPointOnCurve.inputCurve") ;
    
 
    
     int $panduan=`objExists ($qvxian+"_B_Grp")`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete ($qvxian+"_B_Grp");
        }
    
     select -cl  ;
     group -empty -n ($qvxian+"_B_Grp");
     setAttr ($qvxian+"_B_Grp.visibility") 0;
     setAttr -lock true ($qvxian+"_B_Grp"+".v");
     parent ($qvxian+"_B_Grp") $qvxianzu; 
     
    int $panduan=`objExists ($qvxian+"_A_Grp")`;//查询这个物体是否纯在
    if($panduan==1)
        {
         delete ($qvxian+"_A_Grp");
        }
     select -cl  ;
     group -empty -n ($qvxian+"_A_Grp");
     setAttr ($qvxian+"_A_Grp.visibility") 0;
     setAttr -lock true ($qvxian+"_A_Grp"+".v");
    parent ($qvxian+"_A_Grp") $qvxianzu; 
   select -r ($qvxian+".cv[0:99999999999]");
    string $cvs[]=`ls -sl -fl`;
    
  global string $gSelect;
global string $gMainProgressBar;
setToolTo $gSelect;
progressBar -e -st ("创建定位器...") -bp -ii 1 -min 0 -max `size($cvs)` $gMainProgressBar;
    for($j=0;$j<size($cvs);$j++) 
    {
         if(`progressBar -q -ic $gMainProgressBar`)
         break;
         progressBar -e -s 1 $gMainProgressBar;
         string $cv_dian=$cvs[$j];
        spaceLocator -p 0 0 0 -n ($qvxian+"_loc_A_"+$j);
        spaceLocator -p 0 0 0 -n ($qvxian+"_loc_B_"+$j);
        parent ($qvxian+"_loc_B_"+$j) ($qvxian+"_B_Grp");
        parent ($qvxian+"_loc_A_"+$j)  ($qvxian+"_A_Grp");
        float $pos_a[]=`xform -q -ws -t $cvs[$j]`;
        setAttr  -type float3 ("temp_qvxian_nearestPointOnCurve.inPosition")  $pos_a[0] $pos_a[1] $pos_a[2];
         addAttr -ln ("canshu")  -at double   -dv 0 -k  1 ($qvxian+"_loc_A_"+$j);//添加属性
        float $canshu=`getAttr "temp_qvxian_nearestPointOnCurve.parameter"`;
        setAttr  ($qvxian+"_loc_A_"+$j+".canshu") $canshu;
        setAttr -lock true ($qvxian+"_loc_A_"+$j+".canshu");
        
         int $panduan_A=`objExists ($qvxian+"_pointOnCurveInfo_loc_"+$j)`;//查询这个物体是否纯在
         if($panduan_A==1){delete ($qvxian+"_pointOnCurveInfo_loc_"+$j); }
        createNode "pointOnCurveInfo" -n ($qvxian+"_pointOnCurveInfo_loc_"+$j);//创建曲线信息节点
        connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ($qvxian+"_pointOnCurveInfo_loc_"+$j+".inputCurve");
        connectAttr -force ($qvxian+"_loc_A_"+$j+".canshu") ($qvxian+"_pointOnCurveInfo_loc_"+$j+".parameter");
        connectAttr -force ($qvxian+"_pointOnCurveInfo_loc_"+$j+".position") ($qvxian+"_loc_A_"+$j+".t");
        
        float $pos_c[]=`getAttr ($qvxian+"_pointOnCurveInfo_loc_"+$j+".position")`;
         setAttr -type float3 ($qvxian+"_loc_B_"+$j+".t") $pos_c[0] $pos_c[1] $pos_c[2];
     }
     progressBar -e -ep $gMainProgressBar;
    
}
delete ("temp_qvxian_nearestPointOnCurve");



}



///////////////////////创建拉链效果/////////////////////////
global proc zxb_global_lalian_a(string$open_A,string$close_B,string$follow_D,string$qianzui){

//string $bianliang[]=`ls -sl`;//选中默认曲线

string $openA_sss=$open_A;
string $openAs[]= stringToStringArray($openA_sss, " ");//字符串转化数组

string $close_sss=$close_B;
string $close_Bs[]= stringToStringArray($close_sss, " ");//字符串转化数组

 string $follow_sss=$follow_D;
string$follow_Ds[]= stringToStringArray($follow_sss, " ");//字符串转化数组

 string $qianzui_sss=$qianzui;
 string$qianzui_a[];
  clear $qianzui_a;
  int $nemt=`tokenize $qianzui_sss" " $qianzui_a`;//分离字符串存到变量
  string$qianzui=$qianzui_a[0];

string $bianliang[]=$close_Bs;
 int $fanxiang_a=`checkBox -q  -value fanxuan`;
 int $panduan_a=`objExists ($bianliang[0]+"_curveInfo")`;
 if($panduan_a==1){delete ($bianliang[0]+"_curveInfo");}
shadingNode -asUtility curveInfo -n ($bianliang[0]+"_curveInfo");

string $qvxian_shp[]=`listRelatives -c ($bianliang[0])`;
connectAttr -force ($qvxian_shp[0]+".worldSpace[0]") ($bianliang[0]+"_curveInfo.inputCurve");

 int $panduan=`objExists ($bianliang[0]+".changdu")`;
if($panduan==0){addAttr -ln "changdu"  -at double  -dv 0 -k 1($bianliang[0]);}
setAttr -lock 0  ($bianliang[0]+".changdu");
connectAttr -force  ($bianliang[0]+"_curveInfo.arcLength") ($bianliang[0]+".changdu");
setAttr -lock 1  ($bianliang[0]+".changdu");


select -r  ($bianliang[0]+".cv[0:9999999999]") ;
string $qvxian_dian[]=`ls -sl -fl`;
int $qvxian_size=size($qvxian_dian);
float $pos_A[]=`xform -q -ws -t ($bianliang[0]+".cv[0]")`;
float $pos_B[]=`xform -q -ws -t ($bianliang[0]+".cv["+($qvxian_size-1)+"]")`;
float $pos_l_panduan[]=$pos_A;
float $pos_r_panduan[]=$pos_B;
if ( $pos_r_panduan[0]>$pos_l_panduan[0])
{
     $pos_l_panduan=$pos_B;
     $pos_r_panduan=$pos_A;
}

string$zuiba_loc_L=($bianliang[0]+"LL_ZUIBA_LOC");
string$zuiba_loc_R=($bianliang[0]+"RR_ZUIBA_LOC");
spaceLocator -p 0 0 0 -n $zuiba_loc_L;
spaceLocator -p 0 0 0 -n $zuiba_loc_R;
string$qvxianfu_temp[]=`listRelatives -p $openAs[0] `;
parent $zuiba_loc_L $qvxianfu_temp[0];
parent $zuiba_loc_R $qvxianfu_temp[0];
xform  -ws -t  $pos_l_panduan[0]  $pos_l_panduan[1]  $pos_l_panduan[2] $zuiba_loc_L;
xform  -ws -t  $pos_r_panduan[0]  $pos_r_panduan[1]  $pos_r_panduan[2] $zuiba_loc_R;


 int $panduan_b=`objExists ($zuiba_loc_L+".shuaijian")`;
 float $changdu=`getAttr ($bianliang[0]+".changdu")`;
 float $changduzhi= $changdu/5.0;
if($panduan_b==0)
{
addAttr -ln "shuaijian"  -at double  -dv $changduzhi -k 1 ($zuiba_loc_L);
setAttr -keyable false -channelBox true ($zuiba_loc_L+".shuaijian");
}

move -r  ($changduzhi*1.25) 0 0 ($zuiba_loc_L) ;
move -r  ($changduzhi*-1.25) 0 0 ($zuiba_loc_R) ;
//print `size($qvxian_dian)`;
for($j=0;$j<size($bianliang);$j++)
{
 

for($i=0;$i<size($qvxian_dian);$i++)
 {
     
     string $qvxian_B=$close_Bs[$j];
     string$qvxian_A= $openAs[$j];
     string$qvxian_D=$follow_Ds[$j];
     
     string$qvxian_loc=($qvxian_B+"_loc_A_"+$i);
     string$qvxian_locA=($qvxian_A+"_loc_A_"+$i);
     string$qvxian_locD=($qvxian_D+"_loc_A_"+$i);
    
         select -r $qvxian_loc ;
         select -add $qvxian_locA ;
         select -add $qvxian_locD;
     string $dianyuesu_bianliang[]=`pointConstraint`;
     
     
      int $panduan_C=`objExists ($qvxian_B+"_plusMinusAverage_L_"+$i)`;
      if($panduan_C==1){delete ($qvxian_B+"_plusMinusAverage_L_"+$i); }
     shadingNode -asUtility plusMinusAverage -n ($qvxian_B+"_plusMinusAverage_L_"+$i);//创建加减节点
     connectAttr -force  ($zuiba_loc_L+".tx") ($qvxian_B+"_plusMinusAverage_L_"+$i+".input1D[0]");
     connectAttr -force  ($qvxian_locA+".tx") ($qvxian_B+"_plusMinusAverage_L_"+$i+".input1D[1]");
     setAttr ($qvxian_B+"_plusMinusAverage_L_"+$i+".operation") 2;
      
      int $panduan_F=`objExists ($qvxian_B+"setRange_A_"+$i)`;
      if($panduan_F==1){delete ($qvxian_B+"setRange_A_"+$i); }
     shadingNode -asUtility  setRange -n ($qvxian_B+"setRange_A_"+$i);//创建范围节点
     setAttr ($qvxian_B+"setRange_A_"+$i+".maxX") 1;
     connectAttr -f ($zuiba_loc_L+".shuaijian")($qvxian_B+"setRange_A_"+$i+".oldMaxX");
     connectAttr -f ($qvxian_B+"_plusMinusAverage_L_"+$i+".output1D") ($qvxian_B+"setRange_A_"+$i+".valueX");
     
      
     int $panduan_D=`objExists ($qvxian_B+"_plusMinusAverage_R_"+$i)`;
     if($panduan_D==1){delete ($qvxian_B+"_plusMinusAverage_R_"+$i); }
     shadingNode -asUtility plusMinusAverage -n ($qvxian_B+"_plusMinusAverage_R_"+$i);//创建加减节点
     connectAttr -force  ($zuiba_loc_R+".tx") ($qvxian_B+"_plusMinusAverage_R_"+$i+".input1D[1]");//中间减→→右边 右边数值是负数
     connectAttr -force  ($qvxian_locA+".tx") ($qvxian_B+"_plusMinusAverage_R_"+$i+".input1D[0]");
     setAttr ($qvxian_B+"_plusMinusAverage_R_"+$i+".operation") 2;
     
      int $panduan_F=`objExists ($qvxian_B+"setRange_B_"+$i)`;
      if($panduan_F==1){delete ($qvxian_B+"setRange_B_"+$i); }
     shadingNode -asUtility  setRange -n ($qvxian_B+"setRange_B_"+$i);//创建范围节点
     setAttr ($qvxian_B+"setRange_B_"+$i+".maxX") 1;
     connectAttr -f ($zuiba_loc_L+".shuaijian")($qvxian_B+"setRange_B_"+$i+".oldMaxX");
     connectAttr -f ($qvxian_B+"_plusMinusAverage_R_"+$i+".output1D") ($qvxian_B+"setRange_B_"+$i+".valueX");
     
     
     int $panduan_E=`objExists ($qvxian_B+"_plusMinusAverage_M_"+$i)`;
     if( $panduan_E==1){delete ($qvxian_B+"_plusMinusAverage_M_"+$i);}
     shadingNode -asUtility plusMinusAverage -n ($qvxian_B+"_plusMinusAverage_M_"+$i);//创建加减节点
     setAttr ($qvxian_B+"_plusMinusAverage_M_"+$i+".operation") 2;
     setAttr ($qvxian_B+"_plusMinusAverage_M_"+$i+".input1D[0]") 2;
     connectAttr -f ($qvxian_B+"setRange_A_"+$i+".outValueX")  ($qvxian_B+"_plusMinusAverage_M_"+$i+".input1D[1]");
     connectAttr -f ($qvxian_B+"setRange_B_"+$i+".outValueX")  ($qvxian_B+"_plusMinusAverage_M_"+$i+".input1D[2]");



     int $panduan_E=`objExists ($qvxian_B+"setRange_M_"+$i)`;
     if( $panduan_E==1){delete ($qvxian_B+"setRange_M_"+$i);}
     shadingNode -asUtility  setRange -n ($qvxian_B+"setRange_M_"+$i);//创建范围节点
     setAttr ($qvxian_B+"setRange_M_"+$i+".maxX") 1;
     setAttr ($qvxian_B+"setRange_M_"+$i+".oldMaxX") 1;
     connectAttr -f ($qvxian_B+"_plusMinusAverage_M_"+$i+".output1D") ($qvxian_B+"setRange_M_"+$i+".valueX");
     
     
      int $panduan_E=`objExists ($qvxian_B+"reverse_M_"+$i)`;
     if( $panduan_E==1){delete ($qvxian_B+"reverse_M_"+$i);}
     shadingNode -asUtility reverse -n($qvxian_B+"reverse_M_"+$i); //创建反向节点
     connectAttr -f ($qvxian_B+"setRange_M_"+$i+".outValueX") ($qvxian_B+"reverse_M_"+$i+".inputX");
     if($fanxiang_a==1)
        {
         connectAttr -f  ($qvxian_B+"setRange_M_"+$i+".outValueX") ($dianyuesu_bianliang[0]+"."+$qvxian_loc+"W0")  ;
          connectAttr -f  ($qvxian_B+"reverse_M_"+$i+".outputX") ($dianyuesu_bianliang[0]+"."+$qvxian_locA+"W1") ;
         }
        else{
          connectAttr -f  ($qvxian_B+"reverse_M_"+$i+".outputX") ($dianyuesu_bianliang[0]+"."+$qvxian_loc+"W0")  ;
          connectAttr -f   ($qvxian_B+"setRange_M_"+$i+".outValueX")($dianyuesu_bianliang[0]+"."+$qvxian_locA+"W1") ;
           }
        
 }
 
}
 
 
 
}
 


/////////////////////////////////设置嘴巴波浪///////////////////////////
global proc zxb_bolangzui_a(string$qvxian_sss)
{

string $qvxian_temp_D[]= stringToStringArray($qvxian_sss, " ");//字符串转化数组
string $bianliang[]= $qvxian_temp_D;//选中曲线D  



for($i=0;$i<size($bianliang);$i++)
{
   string $qvxian_D=$bianliang[$i];
   select -r $qvxian_D;
  duplicate -rr -n ($qvxian_D+"_bolang");
    string $grpchids[]=`listRelatives -c ($qvxian_D+"_locGrp")`;
    
    int $panduan=`objExists ($qvxian_D+"_bolanggrp") `;
    if ($panduan==0)
    {
        select -cl  ;
        group -empty -n ($qvxian_D+"_bolanggrp");
        setAttr ($qvxian_D+"_bolanggrp.visibility") 0;
        setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolanggrp.v");
        
     }
     
     string$boliang=($bianliang[0]+"_bolang_all");
     
    int $panduan=`objExists $boliang `;
    if ($panduan==0)
    {
        select -cl  ;
        group -empty -n $boliang ;
       setAttr ($boliang+".visibility") 0;
       setAttr -lock true -keyable false -channelBox false ($boliang+".v");
       string$fuwuti_yemp[]=` listRelatives -p $qvxian_D`;
        parent $boliang  $fuwuti_yemp[0];
     
     }
     
     parent ($qvxian_D+"_bolanggrp")  $boliang;
     
     /////////////////////////复制曲线D的定位器   属性控制拉链嘴的组//////////////////////////////
   string $objloc_d[];//定义定位器的所有物体  复制出来的定位器的名字
   clear $objloc_d;
   for($j=0;$j<size($grpchids);$j++)
   {
     string $qvxian_D_locA= $grpchids[$j];
     string $loc_chids[]=`listRelatives -c  -type "transform" $qvxian_D_locA`;
     string $obj="";

     for($ii=0;$ii<size($loc_chids);$ii++)
       {
       int $panduan=`objExists ($loc_chids[$ii]+".offsetZ")`;
       if ($panduan==0){$obj=$loc_chids[$ii];}
       }
     select -r $obj ;
     duplicate -rr -n ($obj+"_bolang");
     parent ($obj+"_bolang") ($qvxian_D+"_bolanggrp");
     string $zu_zi[]=`listRelatives -c -ad  -type  "transform" -fullPath ($obj+"_bolang")`;
     string $zu_zi_A[]=`listRelatives -c -ad  -type  "transform" ($obj+"_bolang")`;
     string $bolangloc="";

     for($iii=0;$iii<size($zu_zi);$iii++)////重命名
      {
          string $ziwuti=$zu_zi[$iii];
          //select -r $ziwuti;
          rename  $ziwuti ($zu_zi_A[$iii]+"_bolang");
          string$loc_shap[]=`listRelatives -s ($zu_zi_A[$iii]+"_bolang")`;
          if($loc_shap[0]==""&&$iii==0){ delete($zu_zi_A[$iii]+"_bolang");}
          if($loc_shap[0]!="")
            {
             string$tepe_B=`nodeType $loc_shap[0]`;
            if($tepe_B=="locator"){$bolangloc=($zu_zi_A[$iii]+"_bolang");}
             }

         
         
        
    
       }
      string $loc_zu[]=`listRelatives -c  -type  "transform"  $obj`;
      string $lalian_loczu=$loc_zu[0];

     connectAttr -f ($bolangloc+".t") ($lalian_loczu+".t");
     select -r $bolangloc;

     $objloc_d[$j] = $bolangloc;//把定位器的名称保存到变量里   复制出来的定位器的名字
   }
  // print $objloc_d;
  
  
  
  ///////////////////创建曲线///////////////////
   float $kaishi_pos_A[]=`xform -q -ws -t  ($qvxian_D+".cv[0]")`;
   float $kaishi_pos_B[]=`xform -q -ws -t  ($qvxian_D+".cv[+"+size($grpchids)+"]")`;
    int $panduan=`objExists ($qvxian_D+"_bolang")`;
    if($panduan==1){ delete ($qvxian_D+"_bolang");}
    
  curve -d 1 -p $kaishi_pos_A[0] $kaishi_pos_A[1] $kaishi_pos_A[2] -p $kaishi_pos_B[0] $kaishi_pos_B[1] $kaishi_pos_B[2] -n($qvxian_D+"_bolang"); //创建曲线
  setAttr ($qvxian_D+"_bolang.visibility") 0;
  setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolang.v");
  rebuildCurve -ch 0 -rpo 1 -rt 0 -end 1 -kr 0 -kcp 0 -kep 1 -kt 0 -s 2 -d 3 -tol 0.01 ($qvxian_D+"_bolang");//重建曲线
  /////////////创建曲线信息节点///////////////////////////
     int $panduan=`objExists ($qvxian_D+"qvxianzuijingdianjiedian")`;
     if($panduan==1){ delete ($qvxian_D+"qvxianzuijingdianjiedian");}
   createNode nearestPointOnCurve -n ($qvxian_D+"qvxianzuijingdianjiedian");//创建曲线最近点节点
   string $qvxian_D_shp[]=`listRelatives -s $qvxian_D`;
   connectAttr -force ($qvxian_D_shp[0]+".worldSpace[0]")  ($qvxian_D+"qvxianzuijingdianjiedian"+".inputCurve");//曲线链接到曲线信息节点

    
    /////////////////判断是否翻转曲线起始点/////////////////
    
    float $dian_temp_kaishi[]=`xform -q -ws -t ($qvxian_D+"_bolang.cv[0]")`;
    float $dian_temp_jiesu[]=`xform -q -ws -t ($qvxian_D+"_bolang.cv[4]")`;
    float $dian_temp_kaishi_A[]=`xform -q -ws -t ($qvxian_D+".cv[0]")`;
    float$dis=mag(<<$dian_temp_kaishi[0],$dian_temp_kaishi[1],$dian_temp_kaishi[2]>>-<<$dian_temp_kaishi_A[0],$dian_temp_kaishi_A[1],$dian_temp_kaishi_A[2]>>);
    float$dis_a=mag(<<$dian_temp_jiesu[0],$dian_temp_jiesu[1],$dian_temp_jiesu[2]>>-<<$dian_temp_kaishi_A[0],$dian_temp_kaishi_A[1],$dian_temp_kaishi_A[2]>>);

    if($dis>$dis_a){reverseCurve -ch 0 -rpo 1 ($qvxian_D+"_bolang");}
    parent ($qvxian_D+"_bolang") $boliang;
    
    //////////////////创建蔟//////////////
    int $cv_size=5;
    for($a=0;$a<$cv_size;$a++)//创建蔟
     {
      select -r ($qvxian_D+"_bolang.cv["+$a+"]"); 
       
     CreateCluster ;
     rename ($qvxian_D+"_bolang_cu_"+$a);
     spaceLocator -p 0 0 0 -n ($qvxian_D+"_bolang_cu_loc_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_D_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_C_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_B_"+$a);
     group -n ($qvxian_D+"_bolang_cu_grp_A_"+$a);
     setAttr ($qvxian_D+"_bolang_cu_grp_A_"+$a+".visibility") 0;
     setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolang_cu_grp_A_"+$a+".v");
     delete`pointConstraint  ($qvxian_D+"_bolang_cu_"+$a) ($qvxian_D+"_bolang_cu_grp_A_"+$a)`;
     parent ($qvxian_D+"_bolang_cu_"+$a) ($qvxian_D+"_bolang_cu_loc_"+$a);
     parent ($qvxian_D+"_bolang_cu_grp_A_"+$a) $boliang;
      }
     
     ///////////////////////蔟控制复制出来定位器//////////////////////////////
     
     
      int $panduan_A=`objExists ($qvxian_D+"_bolanggrp"+"_A")`;
      if ($panduan_A==0)
      { select -cl  ;
        group -empty -n ($qvxian_D+"_bolanggrp"+"_A");
        setAttr ($qvxian_D+"_bolanggrp"+"_A"+".visibility") 0;
        setAttr -lock true -keyable false -channelBox false ($qvxian_D+"_bolanggrp"+"_A"+".v");
         string$fuwuti_yemp[]=` listRelatives -p $qvxian_D`;
        parent ($qvxian_D+"_bolanggrp"+"_A")  $fuwuti_yemp[0];
       }
    string $qvxian_D_boliang_shp[]=`listRelatives -s ($qvxian_D+"_bolang")`;
   connectAttr -force ($qvxian_D_boliang_shp[0]+".worldSpace[0]")  ($qvxian_D+"qvxianzuijingdianjiedian"+".inputCurve");//曲线链接到曲线信息节点
   for($aa=0;$aa<size($objloc_d);$aa++)
   {
        string $loc_d=$objloc_d[$aa];
        float $pos[]=`xform -q -ws -t $loc_d`;
       setAttr -type float3  ($qvxian_D+"qvxianzuijingdianjiedian.inPosition") $pos[0] $pos[1] $pos[2];
      float $weozh=`getAttr  ($qvxian_D+"qvxianzuijingdianjiedian.parameter")`;
      
      int $panduan_l=`objExists ($loc_d+"_pointOnCurveInfo_"+$aa)`;
      if($panduan_l==1){delete ($loc_d+"_pointOnCurveInfo_"+$aa); }
     createNode "pointOnCurveInfo" -n ($loc_d+"_pointOnCurveInfo_"+$aa);//创建曲线最近点节点
     connectAttr -force  ($qvxian_D_boliang_shp[0]+".worldSpace[0]")  ($loc_d+"_pointOnCurveInfo_"+$aa+".inputCurve");
     setAttr ($loc_d+"_pointOnCurveInfo_"+$aa+".parameter") $weozh;
     
     spaceLocator -p 0 0 0 -n ( $loc_d+"_A_loc_"+$a);
     connectAttr -force ($loc_d+"_pointOnCurveInfo_"+$aa+".position") ( $loc_d+"_A_loc_"+$a+".t");
     parent ( $loc_d+"_A_loc_"+$a) ($qvxian_D+"_bolanggrp"+"_A");
     pointConstraint -mo ( $loc_d+"_A_loc_"+$a)   $loc_d;
   }
  
   delete  ($qvxian_D+"qvxianzuijingdianjiedian");
   parent ($qvxian_D+"_bolanggrp"+"_A") $boliang;
   
   ///////////////////创建控制器////////////////////////
   
   string $qvxianname=($qvxian_D+"UP_bolangqvxian");
   if($i==1){$qvxianname=($qvxian_D+"DN_bolangqvxian");}
   float $kaishi_pos_A[]=`xform -q -ws -t  ($qvxian_D+".cv[0]")`;
   float $qvxian_MM_pos[]=`xform -q -ws -t  ($qvxian_D+"_bolang.cv[2]")`;
   float $rsd= `abs($kaishi_pos_A[0]*0.2)`;
  circle -c 0 0 0 -nr 0 1 0 -sw 360 -r $rsd -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $qvxianname; 
  group -n ($qvxianname+"_grp_B");
  group -n ($qvxianname+"_grp_A");
  string$fuwuti_yemp[]=` listRelatives -p $qvxian_D`;
  parent ($qvxianname+"_grp_A") $fuwuti_yemp[0] ;
  select -r  ($qvxianname+".cv[0]") ($qvxianname+".cv[2]") ($qvxianname+".cv[4]") ($qvxianname+".cv[6]") ;
  scale -r -p 0cm 0cm 0cm 0.417937 0.417937 0.417937 ;
  if($i==0)
  {  
  move -r -os -wd 0 ($rsd*0.5) 0 ;
  select -r  ($qvxianname+".cv[0:99999999]");
  move -r -os -wd 0 ($rsd*0.5) ($rsd*1.5) ;
  }else
  {
  move -r -os -wd 0 ($rsd*-0.5) 0 ;
  select -r  ($qvxianname+".cv[0:99999999]");
  move -r -os -wd 0 ($rsd*-0.5) ($rsd*1.5) ;
  }
 
  xform  -ws -t $qvxian_MM_pos[0] $qvxian_MM_pos[1] $qvxian_MM_pos[2]($qvxianname+"_grp_A");
  
  string $shape[]=`listRelatives -s $qvxianname`;
    setAttr ($shape[0]+".overrideEnabled") 1;
    setAttr ($shape[0]+".overrideColor") 16;
  //parent   ($qvxianname+"_grp_A") $boliang;
    
    
    ////////////////////表达式//////////////////////////
   
    float $rsd= ($kaishi_pos_A[0]*0.35);
    float$aaaa= `abs ($rsd)`;
     float $temp=$aaaa;
    addAttr -ln "upty"  -at double  -dv 1 -k 1 $qvxianname;
    addAttr -ln "dnty"  -at double  -dv 1 -k 1 $qvxianname;
    addAttr -ln "pianyi"  -at double  -dv 0 -k 1 $qvxianname;
    addAttr -ln "upsl"  -at double  -dv $temp -k 1 $qvxianname;
    addAttr -ln "dntsl"  -at double  -dv ($temp*-1) -k 1 $qvxianname;
    setAttr -keyable false -channelBox true ($qvxianname+".upsl");
    setAttr -keyable false -channelBox true ($qvxianname+".dntsl");
    
    

    string $grp_C1=($qvxian_D+"_bolang_cu_grp_C_1");
    string $grp_C2=($qvxian_D+"_bolang_cu_grp_C_2");
    string $grp_C3=($qvxian_D+"_bolang_cu_grp_C_3");
    
    string $grp_B1=($qvxian_D+"_bolang_cu_grp_B_1");
    string $grp_B2=($qvxian_D+"_bolang_cu_grp_B_2");
    string $grp_B3=($qvxian_D+"_bolang_cu_grp_B_3");
   //select -r $grp_C3;
   // print $grp_C3;
    float $temp_[]=`xform -q -ws -t  $grp_C2`;
    move -rpr $temp_[0] $temp_[1] $temp_[2] ($grp_B3+".scalePivot") ($grp_B3+".rotatePivot") ;
    move -rpr $temp_[0] $temp_[1] $temp_[2] ($grp_B1+".scalePivot") ($grp_B1+".rotatePivot") ;
    string $exp="";
    $exp+=($grp_C1+".ty=clamp(("+$qvxianname+".dntsl*"+$qvxianname+".dnty),("+$qvxianname+".upsl*"+$qvxianname+".upty),("+$qvxianname+".ty*0.6+"+$qvxianname+".tx));\n");
    $exp+=($grp_C3+".ty=clamp(("+$qvxianname+".dntsl*"+$qvxianname+".dnty),("+$qvxianname+".upsl*"+$qvxianname+".upty),("+$qvxianname+".ty*0.6-"+$qvxianname+".tx));\n");
    $exp+=($grp_C2+".ty=("+$grp_C1+".ty+"+$grp_C3+".ty);\n");
    $exp+=($grp_C1+".tz="+$grp_C3+".tz=("+$qvxianname+".tz*0.5);\n");
    $exp+=($grp_B2+".tz=("+$grp_B1+".tz+"+$grp_B3+".tz);\n");
    $exp+=($grp_B1+".sx="+$grp_B3+".sx=("+$qvxianname+".sx);\n");
    $exp+=($grp_C1+".tx="+$grp_C2+".tx="+$grp_C3+".tx="+$qvxianname+".pianyi*0.1;\n");
    $exp+=($grp_B3+".rx="+$grp_B1+".rx="+$qvxianname+".rx;\n");
    $exp+=($grp_B3+".ry="+$grp_B1+".ry="+$qvxianname+".ry;\n");
    $exp+=($grp_B3+".rz="+$grp_B1+".rz="+$qvxianname+".rz;\n");
    //print $exp;
    
int$panduan_biaodashi=`objExists ($qvxian_D+"_biaodashi")`;
if($panduan_biaodashi==1){delete ($qvxian_D+"_biaodashi") ;}
expression -s $exp  -o ($qvxian_D+"_biaodashi") -ae 1 -uc all ;

}
}




//////////////////////////////////眼皮碰撞/////////////////////////////////////////

global proc zxb_yanpi_pengzhuang_chengxu_proc(string$dd_qvxian_temp,string$eye_kongzhiqi_temp,string$all_bn_joints_temp,string$qvmianqiu_temp)
    {
/////////////////上蒙皮关节 对应下蒙皮带融合变形的曲线/////////////////////////////////////
      string$all_qvxian_string=$dd_qvxian_temp;//DD混合变形曲线
      string $qvxians[]=stringToStringArray($all_qvxian_string," ");
      string$qvxian=$qvxians[0];//带融合变形的曲线
      string$all_kongzhiqi_string=$eye_kongzhiqi_temp;//眼睛控制器  上曲线对应下骨骼
      string $kongzhiqis[]=stringToStringArray($all_kongzhiqi_string," ");
      string$kongzhqi=$kongzhiqis[0];//控制器名字
      string$all_gugebn_string=$all_bn_joints_temp;//所有骨骼
      string $gugebns[]=stringToStringArray($all_gugebn_string," ");//所有骨骼名字
      string$all_qvmian_string=$qvmianqiu_temp;//曲面球
      string $qvmians[]=stringToStringArray($all_qvmian_string," ");//曲面
      string$qvmian=$qvmians[0];
      
      string$fanweijiedian[]= `listConnections -d 1 -s 0 ($kongzhqi+".gensui")`;
      string$fanwei=$fanweijiedian[0];//找到到范围节点
     // select -r$fanxiang;
      string$fanxiangjiedian[]= `listConnections -d 1 -s 0 ($fanwei+".outValueX")`;
      string$fanxiang="";
      for($j=0;$j<size($fanxiangjiedian);$j++)
         {
             string$type=`nodeType $fanxiangjiedian[$j]`;
             if($type=="reverse"){$fanxiang=$fanxiangjiedian[$j];}
         }//找到反向节点
         
      string$fanweishuchu=($fanwei+".outValueX");
      string$fangxiangshuchu=($fanxiang+".outputX");
      
      
      string$qvxianxingxi=($qvxian+"_yanpi_pengzhuang_curveInfo");
      int$ex=`objExists $qvxianxingxi`;
      if($ex==1){delete $qvxianxingxi ;}
     shadingNode -asUtility curveInfo -n $qvxianxingxi; //创建曲线信息节点
     
     string$qvxian_shap[]=`listRelatives -s $qvxian`;
      string$qvxian_fuwuti_s[]=`listRelatives -p $qvxian`;
     string$qvxianshep=$qvxian_shap[0];
     connectAttr -force ($qvxianshep+".worldSpace[0]")  ($qvxianxingxi+".inputCurve");
     float$qvxianchangdu=`getAttr ($qvxianxingxi+".arcLength")`;//获得曲线长度
      
     
      
       for($i=0;$i<size($gugebns);$i++)
           {
              string$bn=$gugebns[$i];
              string$inpute_A[]=`listConnections -d 0 -s 1 ($bn+".tx")`;
              string$yuesu=$inpute_A[0];//找到约束
              string$locs[]=`listConnections -d 0 -s 1 ($yuesu+".target[0].targetTranslate")`;
              string$loc=$locs[0];//找到定位器
              delete$yuesu;//删除点约束约束
              string$bn_A=($bn+"fuzhi_AB");
              select -r $bn;
              duplicate -rr -n $bn_A;//复制关节
              string$bn_zi[]=`listRelatives -c -fullPath  $bn_A`;
              delete $bn_zi[0];//删除没有用的约束节点 
              setAttr ($bn_A+".visibility") 0;//隐藏复制出来的关节
              pointConstraint -mo $loc $bn_A;//定位器点约束复制出来的关节

           }
      
       for($i=0;$i<size($gugebns);$i++)
       {
         string$cbn=$gugebns[$i];
         string$Abn=($gugebns[$i]+"fuzhi_AB");//
         string$qvxian_A=($cbn+"_xiangjiao_"+$i);
         curve -d 1 -p 0 0 0 -p 0 ($qvxianchangdu*10) 0 -k 0 -k 1  -n $qvxian_A;
         select -r $qvxian_A;
         CenterPivot;//居中曲线坐标
         setAttr ($qvxian_A+".visibility") 0;//创建曲线
      
         delete`pointConstraint  $Abn $qvxian_A`;//曲线约束到关节
         parent $qvxian_A $Abn;//曲线P给关节
         string$qvxian_shap_c[]=`listRelatives -s $qvxian_A`;
         string$qvxian_shapc=$qvxian_shap_c[0];//刚创建的曲线型节点
         
         string$xiangjiao=($cbn+"_pengzhuang_curveIntersect"+$i);//创建曲线相交点节点
         int$ex=`objExists $xiangjiao`;
         if($ex==1){delete $xiangjiao ;}
         createNode "curveIntersect" -n $xiangjiao;//创建曲线相交节点
         connectAttr -force ($qvxianshep+".worldSpace[0]") ($xiangjiao+".inputCurve1");//链接曲线1
         connectAttr -force ($qvxian_shapc+".worldSpace[0]") ($xiangjiao+".inputCurve2");//链接曲线2
         setAttr ($xiangjiao+".useDirection") 1;
         setAttr -type float3 ($xiangjiao+".direction") 0 0 1;///设置
         
         string$loc=($cbn+"_pengzhuang_loc_gensui_"+$i);
         spaceLocator -p 0 0 0 -n $loc; //创建定位器  跟随曲线
         
         string$qvxianxingxi=($cbn+"_eye_pengzhuang_pointOnCurveInfo"+$i);
         int$ex=`objExists $qvxianxingxi`;
         if($ex==1){delete $qvxianxingxi ;}
         createNode "pointOnCurveInfo" -n $qvxianxingxi; //创建曲线信息节点
         connectAttr -force ($qvxianshep+".worldSpace[0]") ($qvxianxingxi+".inputCurve");//链接眼皮的曲线
         connectAttr -force  ($qvxianxingxi+".position") ($loc+".t");//控制定位器
         connectAttr -f ($xiangjiao+".parameter1[0]") ($qvxianxingxi+".parameter");

         string$loc_qvmian=($cbn+"_pengzhuang_loc_gensuiqvmian_"+$i);
         spaceLocator -p 0 0 0 -n $loc_qvmian; //创建第二个定位器  跟随曲面
         
         string$qvmian_shaps[]=`listRelatives -s $qvmian`;
         string$qvmian_shap=$qvmian_shaps[0];
         
         string$qvmianposjiedian=($cbn+"_pengzhuang_closestPointOnSurface_"+$i);
         int$ex=`objExists $qvmianposjiedian`;
         if($ex==1){delete $qvmianposjiedian ;}
         shadingNode -asUtility closestPointOnSurface -n $qvmianposjiedian;
         connectAttr -f  ($qvmian_shap+".worldSpace[0]") ($qvmianposjiedian+".inputSurface");
         connectAttr -f  ($loc+".t") ($qvmianposjiedian+".inPosition");//第一个定位器的位置信息输入到曲面上
         connectAttr -f  ($qvmianposjiedian+".position") ($loc_qvmian+".t") ;//第二个定位器跟随曲面
       

         string$loc_qiehuan=($cbn+"_pengzhuang_loc_gensuiqiehuan_"+$i);
         spaceLocator -p 0 0 0 -n $loc_qiehuan; //创建第三个定位器  切换定位器
         string$dianyuesu[]=`pointConstraint  $loc $loc_qvmian $loc_qiehuan`;
         connectAttr -f  $fanweishuchu ($dianyuesu[0]+"."+$loc+"W0") ;//第二个定位器跟随曲面
         connectAttr -f   $fangxiangshuchu  ($dianyuesu[0]+"."+$loc_qvmian+"W1") ;//第二个定位器跟随曲面
      
         string$loc_rootgrp=($qvxian+"eye_pengzhuang_grp_loc");
         int$ex=`objExists $loc_rootgrp`;
         if($ex==0)
            {
                select -cl ;
                group -empty -n $loc_rootgrp;
                setAttr ($loc_rootgrp+".visibility") 0;
                setAttr -lock true ($loc_rootgrp+".v"); //创建总组
                parent $loc_rootgrp $qvxian_fuwuti_s[0];
             }
         parent $loc $loc_qvmian $loc_qiehuan $loc_rootgrp;//定位器方到总组里面
         
         
         
       
         string$loc_juzhong=($cbn+"_pengzhuang_loc_juzhong_"+$i);
         string$loc_grp_a=($loc_juzhong+"_grp_A");
         spaceLocator -p 0 0 0 -n $loc_juzhong; //创建第四个个定位器  居中定位器
         group -n $loc_grp_a;
         
         string$yuesu_B[]=`pointConstraint $Abn $loc_qiehuan $loc_grp_a`;//复制出来的关节+切换定位器 约束第4个定位器
         
         
         setAttr ($yuesu_B[0]+"."+$loc_qiehuan+"W1") 0.5;
         setAttr ($yuesu_B[0]+"."+$Abn+"W0") 0.5;
         parent $loc_grp_a $loc_rootgrp ;
         
         string$yuesu_C[]=`pointConstraint $Abn $loc_juzhong $cbn`;//第四个定位器 跟AB关节点约束最终的关节
         
         
         
         string$loc_jshijie=($cbn+"_pengzhuang_loc_shijie_"+$i);//创建第5个定位器
         spaceLocator -p 0 0 0 -n $loc_jshijie;
         parent $loc_jshijie $loc_rootgrp;
         pointConstraint $Abn $loc_jshijie;
         
         string$upposloc=$loc_jshijie;
         string$dwposloc=$loc_qiehuan;
         
         float$ty_a= `getAttr ($loc_jshijie+".ty")`;
         float$ty_b= `getAttr ($loc_qiehuan+".ty")`;
         
         if($ty_a<$ty_b)
            {
             $upposloc=$loc_qiehuan;
             $dwposloc=$loc_jshijie;
             }
       // select -r $dwposloc;
        string$jianjian_A=($cbn+"_pengzhuang_plusMinusAverage"+$i);
       int$ex=`objExists $jianjian_A`;
       if($ex==1){delete $jianjian_A;}
       
      shadingNode -asUtility plusMinusAverage -n $jianjian_A;//创建加减节点
      connectAttr -f ($upposloc+".ty") ($jianjian_A+".input1D[0]");
      connectAttr -f ( $dwposloc+".ty") ($jianjian_A+".input1D[1]");
      setAttr ($jianjian_A+".operation") 2;
      addAttr -ln "zhi"  -at double  -dv 0 -k 1 $loc_juzhong;
      connectAttr -f ($jianjian_A+".output1D")  ($loc_juzhong+".zhi");
   
      string$tiaojianjiedian=($cbn+"_pengzhuang_condition"+$i);
       int$ex=`objExists $tiaojianjiedian`;
       if($ex==1){delete $tiaojianjiedian;}
      shadingNode -asUtility condition -n $tiaojianjiedian;//创建条件节点
      connectAttr -f ($jianjian_A+".output1D") ($tiaojianjiedian+".firstTerm");
      setAttr ($tiaojianjiedian+".operation") 2;
      setAttr ($tiaojianjiedian+".colorIfTrueR") 1;
      setAttr ($tiaojianjiedian+".colorIfFalseR") 0;
      
      
       string$fanxiangjiedian_a=($cbn+"_pengzhuang_reverse"+$i);//创建反向节点
       int$ex=`objExists $fanxiangjiedian_a`;
       if($ex==1){delete $fanxiangjiedian_a;}
       shadingNode -asUtility reverse -n $fanxiangjiedian_a;
       connectAttr -f ($tiaojianjiedian+".outColorR") ($fanxiangjiedian_a+".inputX");//条件节点连接到反向节点
       connectAttr -f   ($tiaojianjiedian+".outColorR") ($yuesu_C[0]+"."+$Abn+"W0");
       connectAttr -f   ($fanxiangjiedian_a+".outputX") ($yuesu_C[0]+"."+$loc_juzhong+"W1");
       
       string$upgensui=($kongzhqi+".upgensui");
       int$ex=`objExists $upgensui`;
       if($ex==0)
         {
           addAttr -ln "upgensui"  -at double  -dv 0 -k 1 $kongzhqi;
           setAttr -keyable false -channelBox true ($kongzhqi+".upgensui");

          }
          
       string$dwgensui=($kongzhqi+".dwgensui");
       int$ex=`objExists $dwgensui`;
       if($ex==0)
         {
           addAttr -ln "dwgensui"  -at double  -dv 0 -k 1 $kongzhqi;
           setAttr -keyable false -channelBox true ($kongzhqi+".dwgensui");

          }
      /* int$revDV=1;
       if($upposloc==$loc_jshijie){$revDV=-1;}*/
       
       string$upgensui=($kongzhqi+".upRev");
       int$ex=`objExists $upgensui`;
       if($ex==0)
         {
           addAttr -ln "upRev"  -at double -min -1 -max 1  -dv -1 -k 1 $kongzhqi;
           setAttr -keyable false -channelBox true ($kongzhqi+".upRev");

          }
          
        string$dwgensui=($kongzhqi+".dwRev");
       int$ex=`objExists $dwgensui`;
       if($ex==0)
         {
           addAttr -ln "dwRev"  -at double -min -1 -max 1  -dv 1 -k 1 $kongzhqi;
           setAttr -keyable false -channelBox true ($kongzhqi+".dwRev");

          }
          
       string$bngensui=($cbn+".bnRev");
       int$ex=`objExists $bngensui`;
       if($ex==0)
         {
           addAttr -ln "bnRev"  -at double   -dv 0 -k 1 $cbn;
           setAttr -keyable false -channelBox true ( $cbn+".bnRev");
          }
       
       
       string$jiuanjian_jiedian_A=($cbn+"_pengzhuang_plusMinusAverage_A_zonghe_"+$i);
       int$ex=`objExists $jiuanjian_jiedian_A`;
       if($ex==1){delete $jiuanjian_jiedian_A;}
       shadingNode -asUtility plusMinusAverage -n $jiuanjian_jiedian_A;//创建加减节点
       if($upposloc==$loc_jshijie)
          {
          connectAttr -f ($kongzhqi+".upgensui") ($jiuanjian_jiedian_A+".input1D[0]");
          }else
               { 
               connectAttr -f ($kongzhqi+".dwgensui") ($jiuanjian_jiedian_A+".input1D[0]");
               }
               
       connectAttr -f ( $cbn+".bnRev") ($jiuanjian_jiedian_A+".input1D[1]");
       
        string$chengchu_A=($cbn+"_pengzhuang_multiplyDivide_pianyi_"+$i);
       int$ex=`objExists $chengchu_A`;
       if($ex==1){delete $chengchu_A;}
       shadingNode -asUtility multiplyDivide -n $chengchu_A;//创建乘除节点    
       connectAttr -f ($jiuanjian_jiedian_A+".output1D") ($chengchu_A+".input1X");
       if($upposloc==$loc_jshijie)
         {
         connectAttr -f ($kongzhqi+".upRev") ($chengchu_A+".input2X");

         }else
             {
                connectAttr -f ($kongzhqi+".dwRev") ($chengchu_A+".input2X"); 
              }
          
          
       connectAttr -f  ($chengchu_A+".outputX") ($loc_juzhong+".ty") ;
       
       
       string$jiajian_jiedian_B=($cbn+"_pengzhuang_plusMinusAverage_B_jiandiao_"+$i);
       int$ex=`objExists $jiajian_jiedian_B`;
       if($ex==1){delete $jiajian_jiedian_B;}
       shadingNode -asUtility plusMinusAverage -n $jiajian_jiedian_B;//创建加减节点
       
       string$chengchu_B=($cbn+"_pengzhuang_multiplyDivide_shuangbei_"+$i);
       int$ex=`objExists $chengchu_B`;
       if($ex==1){delete $chengchu_B;}
       shadingNode -asUtility multiplyDivide -n $chengchu_B;//创建乘除节点    
       
       connectAttr -f   ($jianjian_A+".output1D") ( $jiajian_jiedian_B+".input1D[0]");
       connectAttr -f  ($chengchu_A+".outputX")($chengchu_B+".input1X");
       setAttr ($chengchu_B+".input2X") 2;

       connectAttr -f  ($chengchu_B+".outputX")( $jiajian_jiedian_B+".input1D[1]");
       setAttr ($jiajian_jiedian_B+".operation") 2;
       connectAttr -f ($jiajian_jiedian_B+".output1D") ($tiaojianjiedian+".firstTerm");
       
       
 
       } 
       
  }    
    

////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////眼皮自动创建次级结束////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////






///////////////////////////////////////////////睫毛次级自动附着///////////////////////////////////////////////////////////////

global proc zxb_fuzhao_mode_proc()
{
 string $UI_head_controller=`textFieldGrp -q -tx  UI_head_controller`;//
 string $UI_eye_L_lashss=`textFieldGrp -q -tx  UI_eye_L_lash`;//查询被附着的对象
 string$aill_bnss= `getAttr ($UI_head_controller+".eye_bn")`;
 string$aill_bns[]=stringToStringArray($aill_bnss," ");//关节名称
 string $UI_eye_L_lashs[]=stringToStringArray( $UI_eye_L_lashss," ");//被附着的对象模型

 string$eye_modes=`getAttr ($UI_head_controller+".base_bs_mode")`;
 string$eye_modess[]=stringToStringArray($eye_modes," ");//眼睛模型
 string$eye_mode=$eye_modess[5];
 for($i=0;$i<size($UI_eye_L_lashs);$i++)
    {
    string$temp_mode=$UI_eye_L_lashs[$i];
    select -r  $aill_bns;
    select -add  $temp_mode;
    newSkinCluster "-toSelectedBones -mi 1 -omi true -dr 6 -rui true"; 
    select -r  $temp_mode;
    select -add $eye_mode;
    CopySkinWeights;
    }
}

///////////////////////////////////睫毛碰撞///////////////////////////////////////////////////

global proc zxb_jiemao_ciji_kongzhiqi()
{
string$all_root_bn=`textFieldGrp -q -tx UI_jiemao_root_bn `;
 string $all_root_bns[]=stringToStringArray($all_root_bn," ");//被附着的对象模型
string $root_bns[]=$all_root_bns;//选择跟关节创建控制器
string$bns[]=`listRelatives -c  $root_bns[0]`;
float$banjin=0.05;
string$cbn_gra_root_grp=($root_bns[0]+"_GRP_root");
 int$ex=`objExists $cbn_gra_root_grp`;
if($ex==0){group -empty -n $cbn_gra_root_grp; }
 string $xiaba_head_con=`textFieldGrp -q -tx UI_head_controller `;//头部控制器
 string$UV_mode=`getAttr  ($xiaba_head_con+".zxb_face_UV_mode")`;


string$grp_temp="";
for($i=0;$i<size($bns);$i++)
   {
       string$cbn=$bns[$i];
       string$bnss[]=`listRelatives -c  $cbn`;
       //float$tx=`getAttr ($bnss[0]+".tx")`;
       float$tx=$banjin;
       string$cbn_con=($cbn+"_kongzhi");
       string$cbn_gra_A=($cbn+"_GRP_A");
       string$cbn_gra_B=($cbn+"_GRP_B");
       string$cbn_gra_C=($cbn+"_GRP_C");
       $grp_temp+=$cbn_gra_C;
       circle -c 0 0 0 -nr 1 0 0 -sw 360 -r $tx -d 3 -ut 0 -tol 0.01 -s 8 -ch 0 -n $cbn_con ;
       group -n $cbn_gra_A;
       group -n $cbn_gra_B;
       group -n $cbn_gra_C;
       select -r ($cbn_con+".cv[0:99999]");
       move -r -os -wd  $tx 0  0 ;
      
       parent $cbn_gra_C $cbn_gra_root_grp;
       delete`parentConstraint  $cbn $cbn_gra_C`;
       connectAttr -force  ($cbn_con+".r") ($cbn+".r");
       string $qvxianshap[]=`listRelatives -s  $cbn_con`;
       setAttr ($qvxianshap[0]+".overrideEnabled") 1;
       setAttr($qvxianshap[0]+".overrideColor") 18;
   }
   
string $all_zu_temp[]=stringToStringArray($grp_temp," ");


zxb_maonang_Follicle(1,$all_zu_temp,$UV_mode);//int 判断是否保持原位置  ,被控制物体，  模型或者曲面



}



//////////////////////////////////毛囊附着模型/////////////////////////////////////////////////////
global proc zxb_maonang_Follicle(int$weizhi,string$obj_all[],string$fuzhao_mode)//int 判断是否保持原位置  ,被控制物体，  模型或者曲面
{
int $stat=$weizhi;  
string $plane=$fuzhao_mode;
int $ex=`objExists $plane`;
if($ex==0)error "请载入附着模型";
string $sel[]=$obj_all;

string $bigManM= $plane;
string $shape[]=`listRelatives -s $bigManM`;

string $type=`objectType  $shape[0]`;
if($type!="mesh"&&$type!="nurbsSurface")error "需要多边形或者曲面作为固定的面";

int $exsit=`objExists ($bigManM+"follicleGrp")`;

if($exsit==0){
group -em -n ($bigManM+"follicleGrp");
}

for($i=0;$i<size($sel);$i++){
spaceLocator -p 0 0 0 -n ($sel[$i]+"Loc");

group -n ($sel[$i]+"LocGrp");

select -r ($sel[$i]);
select -add ($sel[$i]+"LocGrp");
delete `parentConstraint`;
select -r ($sel[$i]+"Loc");
select -add ($sel[$i]);
parentConstraint -mo;
string $shap[]=`listRelatives -s ($sel[$i]+"Loc")`;
setAttr ($shap[0]+".localScaleZ") 0.01;
setAttr ($shap[0]+".localScaleX") 0.01;
setAttr ($shap[0]+".localScaleY") 0.01;

float $pos[]=`xform -q -a -ws -t ($sel[$i]+"Loc")`;
string $type=`objectType  $shape[0]`;

////////////////////////
if($type=="mesh"){
createNode closestPointOnMesh -n ($sel[$i]+"cpom"+$i);
connectAttr -f ($bigManM+".outMesh") ($sel[$i]+"cpom"+$i+".inMesh");

setAttr ($sel[$i]+"cpom"+$i+".inPositionX") $pos[0] ;
setAttr ($sel[$i]+"cpom"+$i+".inPositionY") $pos[1] ;
setAttr ($sel[$i]+"cpom"+$i+".inPositionZ") $pos[2] ;
float $u=`getAttr ($sel[$i]+"cpom"+$i+".parameterU")`;
float $v=`getAttr ($sel[$i]+"cpom"+$i+".parameterV")`;

createNode follicle -n ($sel[$i]+"follicleShape"+$i);
select -r ($sel[$i]+"follicleShape"+$i);
pickWalk -d up;
rename ($sel[$i]+"follicle"+$i);
connectAttr -f ($bigManM+".outMesh") ($sel[$i]+"follicleShape"+$i+".inputMesh");
connectAttr -f ($bigManM+".worldMatrix[0]") ($sel[$i]+"follicleShape"+$i+".inputWorldMatrix");

connectAttr -f ($sel[$i]+"follicleShape"+$i+".outTranslate") ($sel[$i] +"follicle"+$i+".translate");
connectAttr -f ($sel[$i]+"follicleShape"+$i+".outRotate") ($sel[$i]+"follicle"+$i+".rotate");

setAttr  ($sel[$i]+"follicleShape"+$i+".parameterU") $u;
setAttr  ($sel[$i]+"follicleShape"+$i+".parameterV") $v;

select -r ($sel[$i]+"follicle"+$i);
select -add ($bigManM+"follicleGrp");
parent;
select -r ($sel[$i]+"cpom"+$i);
delete;
}
else
{
createNode closestPointOnSurface -n ($sel[$i]+"cpom"+$i);
string $shape[]=`listRelatives -s $bigManM`;
connectAttr -f ($shape[0]+".worldSpace") ($sel[$i]+"cpom"+$i+".inputSurface");

setAttr ($sel[$i]+"cpom"+$i+".inPositionX") $pos[0] ;
setAttr ($sel[$i]+"cpom"+$i+".inPositionY") $pos[1] ;
setAttr ($sel[$i]+"cpom"+$i+".inPositionZ") $pos[2] ;
float $u=`getAttr ($sel[$i]+"cpom"+$i+".parameterU")`;
float $v=`getAttr ($sel[$i]+"cpom"+$i+".parameterV")`;

createNode follicle -n ($sel[$i]+"follicleShape"+$i);
select -r ($sel[$i]+"follicleShape"+$i);
pickWalk -d up;
rename ($sel[$i]+"follicle"+$i);
connectAttr -f ($shape[0]+".local") ($sel[$i]+"follicleShape"+$i+".inputSurface");
connectAttr -f ($shape[0]+".worldMatrix[0]") ($sel[$i]+"follicleShape"+$i+".inputWorldMatrix");

connectAttr -f ($sel[$i]+"follicleShape"+$i+".outTranslate") ($sel[$i] +"follicle"+$i+".translate");
connectAttr -f ($sel[$i]+"follicleShape"+$i+".outRotate") ($sel[$i]+"follicle"+$i+".rotate");

setAttr  ($sel[$i]+"follicleShape"+$i+".parameterU") $u;
setAttr  ($sel[$i]+"follicleShape"+$i+".parameterV") $v;

select -r ($sel[$i]+"follicle"+$i);
select -add ($bigManM+"follicleGrp");
parent;
select -r ($sel[$i]+"cpom"+$i);
delete;

}
if($stat==0){
select -r ($sel[$i]+"follicle"+$i);
select -add ($sel[$i]+"LocGrp");
delete `pointConstraint`;

select -r ($sel[$i]+"LocGrp");
select -add ($sel[$i]+"follicle"+$i);
parent;
        }else{
    string $constraint[]=`listConnections -s 1 -d 0 ($sel[$i]+".tx")`;
    delete ($constraint[0]);
    select -r ($sel[$i]+"follicle"+$i);
    select -add ($sel[$i]+"LocGrp");
    delete `parentConstraint`;

    select -r ($sel[$i]+"LocGrp");
    select -add ($sel[$i]+"follicle"+$i);
    parent;
    float $pos[]=`getAttr ($sel[$i]+"follicle"+$i+".translate")`;
    move $pos[0] $pos[1] $pos[2]  ($sel[$i]+".scalePivot")  ($sel[$i]+".rotatePivot") ;
    select -r ($sel[$i]+"Loc");
    select -add ($sel[$i]);
    parentConstraint -mo;
        }
    }
}


/////////////////////////////////曲线跟随模型或者曲面//////////////////////////////////////////////////////////////
global proc zxb_mesh_nurbsSurface_to_obj_proc()
{

string $UI_head_mode=`textFieldGrp -q -tx  UI_head_mode`;//
string $UI_head_bn=`textFieldGrp -q -tx  UI_head_bn`;//
string$headbn=$UI_head_bn;//载入头部关节 缩放毛囊需要用到
string $UI_head_controller=`textFieldGrp -q -tx  UI_head_controller`;//
zxb_ADD_shuxing_string_proc($UI_head_controller,"pengzhuang_qvxian");

string$pengzhuang_qvxian_ss[]={"UI_jiemao_pengzhuang_qvxian_up_L","UI_jiemao_pengzhuang_qvxian_dw_L","UI_jiemao_pengzhuang_qvxian_up_R","UI_jiemao_pengzhuang_qvxian_dw_R"};
string$qvxian_head_temp="";
string $temp_all_tex="";
for ($i=0;$i<size($pengzhuang_qvxian_ss);$i++)
    {
     string$UI_name=$pengzhuang_qvxian_ss[$i];
    // print $UI_name;
     string $temp_ui_tex=`textFieldGrp -q -tx $UI_name`;//
     $temp_all_tex+=$temp_ui_tex;
     }
string$qvxian_grp_s[]=stringToStringArray($temp_all_tex, " ");

//print $qvxian_grp_s;
for($iii=0;$iii<size($qvxian_grp_s);$iii++)
   {
    string$temp_qvxian=$qvxian_grp_s[$iii];
    int$ex=`objExists $temp_qvxian`;//判断曲线是否存在

    if($ex==1)//如果存在就执行内容
      {

       
     
      select -r $temp_qvxian;
      select -add $UI_head_mode;
      string $bianliang[]=`ls -sl`;//选择曲线  加选曲面
      
      ////////////判断曲面还是曲线//////////////////
      int$size=size($bianliang);
      if($size!=2){error "请选中一个曲线和一个曲面两个物体";}
      string$qvxian_temp="";
      string$qvmian_temp="";
      string$shape_a[]=`listRelatives -s $bianliang[0]`; 
      string$shape_b[]=`listRelatives -s $bianliang[1]`; 
      
      int$ex_a=`objExists $shape_a[0]`;
      if($ex_a==0){error "选中的第一个物体没有型节点";}
      int$ex_b=`objExists $shape_b[0]`;
      if($ex_b==0){error "选中的第二个物体没有型节点";}
      string$type_a=`nodeType $shape_a[0]`;
      if($type_a=="nurbsCurve")
        {
        $qvxian_temp=$bianliang[0];
        $qvmian_temp=$bianliang[1];
        }
     else
       {
        $qvxian_temp=$bianliang[1];
        $qvmian_temp=$bianliang[0];
       }

     select -r  $qvxian_temp;
     string$shape_b[]=`listRelatives -s $qvmian_temp`; 
     string$shape_mode=$shape_b[0];
     string$type_b=`nodeType $shape_b[0]`;
    if($type_b=="nurbsSurface")///
      {
       /////////////////////////////创建曲面信息节点/////////////////////////////////////////////////////
      string$qvmian_closestPointOnSurface=($qvxian_temp+"_closestPointOnSurface_yanpi");
      string$qvmian_shape[]=`listRelatives -s $qvmian_temp`; 
      string$qvmianshape=$qvmian_shape[0];
      int$panduan_B=`objExists $qvmian_closestPointOnSurface`;
      if($panduan_B==1){delete $qvmian_closestPointOnSurface;}
      shadingNode -asUtility closestPointOnSurface  -n $qvmian_closestPointOnSurface;
      connectAttr -force ($qvmianshape+".worldSpace[0]") ($qvmian_closestPointOnSurface+".inputSurface");

      /////////////选中曲线////////////////////////
      select -r ($qvxian_temp+".cv[0:999999999]");
      string $cvs[]=`ls -sl -fl`;
      for ($i=0;$i<size($cvs);$i++)
          {
           ////////////////////曲面最近点节点 赋值最近点节点////////////////////////////
           string$cv=$cvs[$i];
           string$qvmian_pointOnSurfaceInfo=($qvxian_temp+"_pointOnSurfaceInfo_yanpi"+$i);
           int$panduan_A=`objExists $qvmian_pointOnSurfaceInfo`;
           if($panduan_A==1){delete $qvmian_pointOnSurfaceInfo;}
           shadingNode -asUtility pointOnSurfaceInfo  -n $qvmian_pointOnSurfaceInfo;     
           float$pos_dia[]=`xform -q -ws -t $cv`;
           setAttr -type float3 ($qvmian_closestPointOnSurface+".inPosition") $pos_dia[0] $pos_dia[1] $pos_dia[2];
           float$U=`getAttr ($qvmian_closestPointOnSurface+".parameterU")`;
           float$V=`getAttr ($qvmian_closestPointOnSurface+".parameterV")`;
           setAttr ($qvmian_pointOnSurfaceInfo+".parameterU") $U;//获得U值
           setAttr ($qvmian_pointOnSurfaceInfo+".parameterV") $V;//获得V值
           connectAttr -force ($qvmianshape+".worldSpace[0]") ($qvmian_pointOnSurfaceInfo+".inputSurface");//连接曲面
   
           ///////////////////////////创建定位器连接到曲线上（定位器被曲面控制 定位器控制曲线）//////////////////////////////////////////////////
           string$zu_A=($qvxian_temp+"_eye_grp_loc");
           string$eye_loc=($qvxian_temp+"_eye_loc_"+$i);
           string$eye_loc_grp_a=($eye_loc+"_GRP_A");
           string$eye_loc_grp_b=($eye_loc+"_GRP_B");
           string$all_eye_jiemao_grp="all_eye_jiemao_grp";
           zxb_ADD_kongzu_proc($all_eye_jiemao_grp);
           string$mode_ex_grp[]=`listRelatives -p $all_eye_jiemao_grp`; 
           if($mode_ex_grp[0]!="Face_Group"){parent $all_eye_jiemao_grp "Face_Group";}
           string$ex_grps[]=`listRelatives -p $temp_qvxian`; 
           if($ex_grps[0]!=$all_eye_jiemao_grp){parent $temp_qvxian $all_eye_jiemao_grp;}
           int$panduan_A=`objExists $zu_A`;
           if($panduan_A==0)
             {
              select -cl  ;
              group -empty -n  $zu_A;
              setAttr ($zu_A+".visibility") 0;
              setAttr -lock true ($zu_A+".v");   
              string$qvmian_zu[]=`listRelatives -p $qvmian_temp`; 
              //int$panduan_A=`objExists $qvmian_zu[0]`;
              if($qvmian_zu[0]!=$all_eye_jiemao_grp){ parent $zu_A $all_eye_jiemao_grp;}
             }
          spaceLocator -p 0 0 0 -n $eye_loc;
          group -n $eye_loc_grp_a;
          group -n $eye_loc_grp_b;
          parent $eye_loc_grp_b $zu_A;
          scaleConstraint  $headbn $eye_loc_grp_b;//缩放约束
          connectAttr -f ($qvmian_pointOnSurfaceInfo+".position") ($eye_loc_grp_b+".t");//连接定位器  这个位置是曲面的位置  与曲线顶点的位置有偏移
          ///////////////////矫正偏移  保证定位器一点在曲线点上/////////////////////
          xform -ws -t $pos_dia[0] $pos_dia[1] $pos_dia[2] $eye_loc_grp_a;
          string$loc_sheps[]=`listRelatives -s $eye_loc`; 
          string$loc_shep=$loc_sheps[0];
          connectAttr -f ($loc_shep+".worldPosition[0]")  ($qvxian_temp+".controlPoints["+$i+"]");//定位器控制曲线
          
          
           } 
        delete $qvmian_closestPointOnSurface;
     
     }
  
  
  
    if($type_b=="mesh")///如果是模型
      {
       /////////////////////////////创建曲面信息节点/////////////////////////////////////////////////////
       string$qvmian_closestPointOnSurface=($qvxian_temp+"_closestPointOnMesh_yanpi");
       string$qvmian_shape[]=`listRelatives -s $qvmian_temp`; 
       string$qvmianshape=$qvmian_shape[0];
       int$panduan_B=`objExists $qvmian_closestPointOnSurface`;
       if($panduan_B==1){delete $qvmian_closestPointOnSurface;}
       shadingNode -asUtility closestPointOnMesh  -n $qvmian_closestPointOnSurface;
       connectAttr -force ($qvmianshape+".worldMesh[0]") ($qvmian_closestPointOnSurface+".inMesh");
        /////////////选中曲线////////////////////////
      select -r ($qvxian_temp+".cv[0:999999999]");
      string $cvs[]=`ls -sl -fl`;
      for ($i=0;$i<size($cvs);$i++)
         {
         ////////////////////创建毛囊////////////////////////////
         string$cv=$cvs[$i];
         float$pos_dia[]=`xform -q -ws -t $cv`;
         string$maonang=($qvxian_temp+$i+"_gensuiShape");
         createNode "follicle" -n $maonang  ;//创建毛囊
         string$maonang_tt[]=`listRelatives -p $maonang`;
         string$maonang_t=$maonang_tt[0];
         connectAttr -f ($maonang+".outTranslate") ($maonang_t+".translate");
         connectAttr -f ($maonang+".outRotate") ($maonang_t+".rotate");
         setAttr -type float3 ($qvmian_closestPointOnSurface+".inPosition") $pos_dia[0] $pos_dia[1] $pos_dia[2];
         float$U=`getAttr ($qvmian_closestPointOnSurface+".parameterU")`;
         float$V=`getAttr ($qvmian_closestPointOnSurface+".parameterV")`;
         setAttr ($maonang+".parameterU") $U;
         setAttr ($maonang+".parameterV") $V;
         connectAttr -force ($shape_mode+".outMesh") ($maonang+".inputMesh");
         connectAttr -force ($shape_mode+".worldMatrix[0]") ($maonang+".inputWorldMatrix");
  
   
        ///////////////////////////创建定位器连接到曲线上（定位器被曲面控制 定位器控制曲线）//////////////////////////////////////////////////
        string$zu_A=($qvxian_temp+"_eye_grp_loc");
        string$eye_loc=($qvxian_temp+"_eye_loc_"+$i);
        string$eye_loc_grp_a=($eye_loc+"_GRP_A");
        string$eye_loc_grp_b=($eye_loc+"_GRP_B");
        string$all_eye_jiemao_grp="all_eye_jiemao_grp";
        zxb_ADD_kongzu_proc($all_eye_jiemao_grp);  
        string$mode_ex_grp[]=`listRelatives -p $all_eye_jiemao_grp`; 
        if($mode_ex_grp[0]!="Face_Group"){parent $all_eye_jiemao_grp "Face_Group";}
        string$ex_grps[]=`listRelatives -p $temp_qvxian`; 
       if($ex_grps[0]!=$all_eye_jiemao_grp){parent $temp_qvxian $all_eye_jiemao_grp;}
       int$panduan_A=`objExists $zu_A`;
      if($panduan_A==0)
        {
          select -cl  ;
          group -empty -n  $zu_A;
          setAttr ($zu_A+".visibility") 0; 
          setAttr -lock true ($zu_A+".v");  
          string$qvmian_zu[]=`listRelatives -p $qvmian_temp`; 
          if($qvmian_zu[0]!=$all_eye_jiemao_grp){ parent $zu_A $all_eye_jiemao_grp;} 
        }
      
      spaceLocator -p 0 0 0 -n $eye_loc;
      group -n $eye_loc_grp_a;
      group -n $eye_loc_grp_b;
      parent $eye_loc_grp_b $zu_A;
      delete`pointConstraint $maonang_t $eye_loc_grp_b`;
      parent $eye_loc_grp_b $maonang_t ;
      parent $maonang_t  $zu_A;
      scaleConstraint  $headbn $maonang_t;//缩放约束
      //connectAttr -f ($qvmian_pointOnSurfaceInfo+".position") ($eye_loc_grp_b+".t");//连接定位器  这个位置是曲面的位置  与曲线顶点的位置有偏移
      ///////////////////矫正偏移  保证定位器一点在曲线点上/////////////////////
      xform -ws -t $pos_dia[0] $pos_dia[1] $pos_dia[2] $eye_loc_grp_a;
      string$loc_sheps[]=`listRelatives -s $eye_loc`; 
      string$loc_shep=$loc_sheps[0];
      connectAttr -f ($loc_shep+".worldPosition[0]")  ($qvxian_temp+".controlPoints["+$i+"]");//定位器控制曲线
      } 
     delete $qvmian_closestPointOnSurface;
   }
      select -r $temp_qvxian;
      select -add $UI_head_mode;   
      string$yuandi_qvxian=zxb_qvxian_to_qvxian_proc($headbn) ;
      $qvxian_head_temp+=$yuandi_qvxian+" ";
      if($iii==0){ zxb_ADD_shuxing_string_proc($UI_head_controller,"pengzhuang_qvxian_L_UP");setAttr -type "string" ($UI_head_controller+".pengzhuang_qvxian_L_UP") $yuandi_qvxian ;}
      if($iii==1){ zxb_ADD_shuxing_string_proc($UI_head_controller,"pengzhuang_qvxian_L_DW");setAttr -type "string" ($UI_head_controller+".pengzhuang_qvxian_L_DW") $yuandi_qvxian ;}
      if($iii==2){ zxb_ADD_shuxing_string_proc($UI_head_controller,"pengzhuang_qvxian_R_UP");setAttr -type "string" ($UI_head_controller+".pengzhuang_qvxian_R_UP") $yuandi_qvxian ;}
      if($iii==3){ zxb_ADD_shuxing_string_proc($UI_head_controller,"pengzhuang_qvxian_R_DW");setAttr -type "string" ($UI_head_controller+".pengzhuang_qvxian_R_DW") $yuandi_qvxian ;}
  
      }
   }

setAttr -type "string" ($UI_head_controller+".pengzhuang_qvxian") $qvxian_head_temp;
}



//////////////////////////模型上的曲线控制器原地碰撞曲线///////////////////////////////////////////
global proc string zxb_qvxian_to_qvxian_proc(string$head_bn)
{
string $qvxian[]=`ls -sl`;//跟随的曲线
string$headbn=$head_bn;//载入头部关节
string$gensui_qvxian=$qvxian[0];
string$yuandi_qvxian=($qvxian[0]+"_qvxianA");
select -r $gensui_qvxian;
duplicate -rr -n $yuandi_qvxian;
string$yuanshiqvxian_shapes[]=`listRelatives -s $yuandi_qvxian`;
string$yuanshiqvxian_shape=$yuanshiqvxian_shapes[0];
string$gensui_shapes[]=`listRelatives -s $gensui_qvxian`;
string$gensui_shape=$gensui_shapes[0];

string$qvxian_zuijiandian_jiedian=($yuandi_qvxian+"_nearestPointOnCurve_jiemao");
int$ex=`objExists $qvxian_zuijiandian_jiedian`;
 if($ex==1){delete $qvxian_zuijiandian_jiedian;}
createNode nearestPointOnCurve -n $qvxian_zuijiandian_jiedian;//创建曲线最近点节点
connectAttr -force ($gensui_shape+".worldSpace[0]") ($qvxian_zuijiandian_jiedian+".inputCurve");

select -r ($yuandi_qvxian+".cv[0:999999]");
string $cvs[]=`ls -sl -fl`;
for ($i=0;$i<size($cvs);$i++)
    {
    string$cv=$yuandi_qvxian+".cv["+$i+"]";
    float$pos_dia[]=`xform -q -ws -t $cv`;
    string$zu_A=($yuandi_qvxian+"_eye_grp_loc");
    string$eye_loc=($yuandi_qvxian+"_eye_loc_"+$i);
    string$eye_loc_grp_a=($eye_loc+"_GRP_A");
    string$eye_loc_grp_b=($eye_loc+"_GRP_B");
    int$panduan_A=`objExists $zu_A`;
    if($panduan_A==0)
        {
         select -cl  ;
         group -empty -n  $zu_A;
         setAttr ($zu_A+".visibility") 0;
         setAttr -lock true ($zu_A+".v"); 
         zxb_ADD_kongzu_proc("all_eye_jiemao_grp");
         parent   $zu_A ("all_eye_jiemao_grp");
        }
      
      spaceLocator -p 0 0 0 -n $eye_loc;
      group -n $eye_loc_grp_a;
      group -n $eye_loc_grp_b;
      parent $eye_loc_grp_b $zu_A;
      xform -ws -t  $pos_dia[0] $pos_dia[1] $pos_dia[2] $eye_loc_grp_b;
      string$loc_shapes[]=`listRelatives -s $eye_loc`;
      string$loc_shap=$loc_shapes[0];
      connectAttr -f  ($loc_shap+".worldPosition[0]") ($yuanshiqvxian_shape+".controlPoints["+$i+"]");
      
      string$kongzhi_loc=($yuandi_qvxian+"_kongzhi_loc_"+$i);
      string$kongzhi_loc_grp_a=($eye_loc+"konzghi_GRP_A");
      string$kongzhi_loc_grp_b=($eye_loc+"kongzhi_GRP_B");
      string$kongzhi_grp=($yuandi_qvxian+"_konzghi_root_loc_"+$i);

      spaceLocator -p 0 0 0 -n $kongzhi_loc;
      group -n $kongzhi_loc_grp_a;
      group -n $kongzhi_loc_grp_b;
      
      int$panduan_A=`objExists $kongzhi_grp`;
      if($panduan_A==0)
        {
         select -cl  ;
         group -empty -n  $kongzhi_grp;
         setAttr ($kongzhi_grp+".visibility") 0;
         setAttr -lock true ($kongzhi_grp+".v");  
         zxb_ADD_kongzu_proc("all_eye_jiemao_grp");
         zxb_ADD_kongzu_proc("all_eye_jiemao_grp_yuesu");
         string$ex_grp[]=`listRelatives -p "all_eye_jiemao_grp_yuesu"`; 
         if($ex_grp[0]!="all_eye_jiemao_grp"){parent "all_eye_jiemao_grp_yuesu"  "all_eye_jiemao_grp";}
         parent $kongzhi_grp "all_eye_jiemao_grp_yuesu";
         parentConstraint  $headbn $kongzhi_grp;
         scaleConstraint  $headbn $kongzhi_grp;
          
        }
       
     parent $kongzhi_loc_grp_b $kongzhi_grp;
     xform -ws -t $pos_dia[0] $pos_dia[1] $pos_dia[2] $kongzhi_loc_grp_b;
     connectAttr -f  ($kongzhi_loc+".t") ($eye_loc+".t");
     
     
     
      string$gensui_loc=($yuandi_qvxian+"_gensui_loc_"+$i);
      string$gensui_loc_grp_a=($eye_loc+"gensui_GRP_A");
      string$gensui_loc_grp_b=($eye_loc+"gensui_GRP_B");
      string$gensui_grp=($yuandi_qvxian+"_gensui_root_loc_"+$i);

      spaceLocator -p 0 0 0 -n $gensui_loc;
      group -n $gensui_loc_grp_a;
      group -n $gensui_loc_grp_b;
      parent  $gensui_loc_grp_b $zu_A;
      xform -ws -t  $pos_dia[0] $pos_dia[1] $pos_dia[2]  $gensui_loc_grp_b;
      scaleConstraint  $headbn $gensui_loc_grp_a;//缩放约束

       string$qvxianjiedian=($yuandi_qvxian+"_pointOnCurveInfo_jiemao_A"+$i);
       int$ex=`objExists$qvxianjiedian`;
       if($ex==1){delete $qvxianjiedian;}
       createNode "pointOnCurveInfo" -n $qvxianjiedian;//创建曲线信息节点
       connectAttr -force ($gensui_shape+".worldSpace[0]") ($qvxianjiedian+".inputCurve");
       setAttr -type float3 ($qvxian_zuijiandian_jiedian+".inPosition") $pos_dia[0] $pos_dia[1]$pos_dia[2];
       float$UV=`getAttr  ($qvxian_zuijiandian_jiedian+".parameter")`;
       setAttr ($qvxianjiedian+".parameter") $UV;
       delete`pointConstraint $kongzhi_loc $gensui_loc_grp_b `;
       connectAttr -force ($qvxianjiedian+".position")  ($gensui_loc_grp_b +".t");
   
       pointConstraint  $gensui_loc $kongzhi_loc;
      }
      
delete $qvxian_zuijiandian_jiedian;

 return $yuandi_qvxian;
}




////////////////////////////////////////计算碰撞关节的角度////////////////////////////////////////////////////////////////
global proc zxb_jiemao_pengzhuangguanjie_chengxu_proc(){
    
    
string $bns[]=`ls -sl`;//选择计算关节
//string$mode="Mery_geo_up_eyelashMesh_base_pengzhuang";
string$qv_aaa=`textFieldGrp -q -tx  UI_yuandi_qvxian`;
string$loc_aaaa=`textFieldGrp -q -tx  UI_yuandi_loc`;
string$jiaodu_aaaa=`textFieldGrp -q -tx   UI_yuandi_jiaodu`;

string$qv=$qv_aaa;//载入曲线
int$shuliang=$loc_aaaa;
int$jiaodu=$jiaodu_aaaa;


string$qvxian_zuijiandian_jiedian=($qv+"_nearestPointOnCurve_jiemao_jiancha");
int$ex=`objExists $qvxian_zuijiandian_jiedian`;
 if($ex==1){delete $qvxian_zuijiandian_jiedian;}
createNode nearestPointOnCurve -n $qvxian_zuijiandian_jiedian;//创建曲线最近点节点
string$qvxian_shaps[]=`listRelatives -s $qv`;
string$qvxian_shap=$qvxian_shaps[0];
connectAttr -force ($qvxian_shap+".worldSpace[0]") ($qvxian_zuijiandian_jiedian+".inputCurve");


for($i=0;$i<size($bns);$i++)
   {      
    
      
      
    string$bn=$bns[$i];
    string$en_bns[]=`listRelatives -c $bn`;
    string$en_bn=$en_bns[0];
    string$loc_grp=($bn+"_loc_temp_grp");
    select -cl  ; 
    group -em -n $loc_grp;
    parentConstraint  $bn $loc_grp;
    float$en_bn_tsx=`getAttr ($en_bn+".tx")`;
    float$zhi=$en_bn_tsx/($shuliang-1);
    for($j=0;$j<$shuliang;$j++)
       {
         string$loc=($bn+"_loc_temp"+$j);
         spaceLocator -p 0 0 0 -n $loc;
          parent $loc $loc_grp;
          delete`parentConstraint  $loc_grp $loc`;
          setAttr($loc+".tx") ($j*$zhi);
       }
       
       
   global string $gSelect;
   global string $gMainProgressBar;
   setToolTo $gSelect;
    progressBar -e -st ("计算位置...") -bp -ii 1 -min 0 -max $jiaodu $gMainProgressBar;
     float$diss=10000000;  
     float$rz=0;
     int$loc_shu=0;
     for($j=0;$j<$jiaodu;$j++)
        {
            
            
        if(`progressBar -q -ic $gMainProgressBar`)
        break;
        progressBar -e -s 1 $gMainProgressBar;  
        setAttr ($bn+".rz") $j;
        
         for($jj=0;$jj<$shuliang;$jj++)
             {
             string$loc=($bn+"_loc_temp"+$jj);
             float$loc_pos[]=`xform -q -ws -t $loc`;
             setAttr ($qvxian_zuijiandian_jiedian+".inPosition") $loc_pos[0] $loc_pos[1] $loc_pos[2];
             float$qvxian_pos[]=`getAttr ($qvxian_zuijiandian_jiedian+".position")`;
             float$cdiss=mag(<<$qvxian_pos[0],$qvxian_pos[1],$qvxian_pos[2]>>-<<$loc_pos[0],$loc_pos[1],$loc_pos[2]>>);
             if($cdiss<$diss)
                {
                $diss=$cdiss;
                $rz=$j;
                $loc_shu=$jj;
                }
             }
        
        
        }
        
        
     
     setAttr ($bn+".rz") $rz;
     float$txx=`getAttr ($bn+"_loc_temp"+$loc_shu+".tx")`;
     setAttr ($en_bn+".tx") $txx;
     delete $loc_grp; 
     progressBar -e -ep $gMainProgressBar;
   
   }
   
delete $qvxian_zuijiandian_jiedian;   
  
}






///////////////////////////////////////睫毛碰撞//////////////////////////////////////////////////////////


global proc zxb_jiemao_pengzhuang_proc()
{
string$pengzhuang_qvxian_ss[]={"UI_jiemao_pengzhuang_bn_up_L","UI_jiemao_pengzhuang_bn_dw_L","UI_jiemao_pengzhuang_bn_up_R","UI_jiemao_pengzhuang_bn_dw_R"};
string $toubukongzhiqi=`textFieldGrp -q -tx UI_head_controller `;
string$pengzhuang_qvxian_ssa[]={"pengzhuang_qvxian_L_UP","pengzhuang_qvxian_L_DW","pengzhuang_qvxian_R_UP","pengzhuang_qvxian_R_DW"};
string$eye_coms=`getAttr ($toubukongzhiqi+".eye_con")`;
string$eye_coma[]=stringToStringArray($eye_coms, " ");
for ($i=0;$i<size($pengzhuang_qvxian_ss);$i++)
    {
     string$UI_name=$pengzhuang_qvxian_ss[$i];
     string$UI_name_shuxing=$pengzhuang_qvxian_ssa[$i];
     int$qvyu=$i%2;
     string$eye_zongkongzhi="";
     if($i<=1){$eye_zongkongzhi=$eye_coma[0];}else{$eye_zongkongzhi=$eye_coma[1];}
     string $temp_ui_tex=`textFieldGrp -q -tx $UI_name`;//
     string$qvxian_grp_s[]=stringToStringArray($temp_ui_tex, " ");
    
     string$xian="";
      int$ex_ww=`objExists ($toubukongzhiqi+"."+$UI_name_shuxing)`;//判断曲线是否存在
     if($ex_ww==1){ $xian=`getAttr ($toubukongzhiqi+"."+$UI_name_shuxing)`;}
     int$ex_A=`objExists $xian`;//判断曲线是否存在
     int$ex=`objExists $qvxian_grp_s[0]`;//判断曲线是否存在
     int$aaa_ex_panduan=$ex_A+$ex;
     if($aaa_ex_panduan==2)
       {
        select -r $qvxian_grp_s;   
        zxb_jiemao_pengzhuangyuesu_zhucengxu_proc($qvyu,$xian,$eye_zongkongzhi);
        }
     }

}

global proc zxb_jiemao_pengzhuangyuesu_zhucengxu_proc(int$shangxia,string$temp_chuandiqvxian,string$eye_kongzhiqi)
{

string $bns[]=`ls -sl`;//选中所有关节

int$aaa=$shangxia;
string$qvv=$temp_chuandiqvxian;
string$klk=$eye_kongzhiqi ;

string$qv=$qvv;//载入在原地位置的曲线
string$yaqiukongzhii=$klk;//眼睛总控制器
int$shangxia=$aaa;//判断上下睫毛
string$OBJ[];
clear $OBJ;
string$qvxianshap_s[]=` listRelatives -s $qv`;
string$qvxianshap=$qvxianshap_s[0];
string$shuxing="jiemao_gensui_UP";
if($shangxia==1){$shuxing="jiemao_gensui_DW";}
int$ex=`objExists  ($yaqiukongzhii+"."+$shuxing)`;
if($ex==0)
  {
  select -r  $yaqiukongzhii;
  addAttr -ln $shuxing  -at double  -dv 0 -k 1 $yaqiukongzhii;
  setAttr -keyable false -channelBox true ($yaqiukongzhii+"."+$shuxing);
  }

string$all_grp=($qv+"_all_grp");
 int$ex=`objExists $all_grp`; 
 if($ex==0)
   {
         select -cl  ;
         group -empty -n  $all_grp;
         setAttr ($all_grp+".visibility") 0;
         setAttr -lock true ($all_grp+".v");     
   }
for($i=0;$i<size($bns);$i++)
    {
        string$bn=$bns[$i];
        string$bnn=($bn+"_A");
        string$bnn_end=($bn+"_A_s");
        string$qxian_name=($bn+"_xiangjiaoxian_"+$i);
        select -r $bn;
        duplicate -rr -n $bnn ;
        string$bnn_s[]=` listRelatives -c -pa $bn`;
        string$bnn_ss[]=` listRelatives -c -pa $bnn`;
         rename $bnn_ss[0] $bnn_end;
        delete  $bnn_s[0];
        parent $bnn $bn ;
        $OBJ[$i]=$bnn;
        
        float$tx=`getAttr ($bnn_end+".tx")`;
        curve -d 1 -p 0 0 0 -p 0 ($tx*10) 0 -k 0 -k 1 -n $qxian_name;//创建曲线
        select -r $qxian_name;
        CenterPivot;
        delete`pointConstraint $bnn_end $qxian_name`;
        parent $qxian_name $bn ;
        setAttr ($qxian_name+".visibility") 0;
        setAttr -lock true ($qxian_name+".v");
        
        string$xiangjiao=($bn+"_curveIntersect_jiemao_penzguang");
        int$ex=`objExists $xiangjiao`;
        if($ex==1){delete $xiangjiao;}
        createNode "curveIntersect" -n $xiangjiao ;//曲线相交点节点
        string$bnqvxianshap_s[]=` listRelatives -s $qxian_name`;
        string$bnqvxianshap=$bnqvxianshap_s[0];
        connectAttr -force ($qvxianshap+".worldSpace[0]") ($xiangjiao+".inputCurve1");
        connectAttr -force ($bnqvxianshap+".worldSpace[0]") ($xiangjiao+".inputCurve2");
        setAttr ($xiangjiao+".useDirection") 1;
        setAttr -type float3 ($xiangjiao+".direction") 0 0 1;

        string$loc=($bn+"_loc_A_"+$i);
        string$loc_grpA=($loc+"_A");
        spaceLocator -p 0 0 0 -n $loc;
        group -n $loc_grpA;
        
        parent $loc_grpA  $all_grp;
        
        string$qvxianjiedian=($bn+"_pointOnCurveInfo_jiemao_xiangjiao_"+$i);
        int$ex=`objExists $qvxianjiedian`;    ///判断
        if($ex==1){delete $qvxianjiedian;}
        createNode "pointOnCurveInfo" -n $qvxianjiedian;
        connectAttr -force ($qvxianshap+".worldSpace[0]") ($qvxianjiedian+".inputCurve");
        connectAttr -force ($xiangjiao+".parameter1[0]") ($qvxianjiedian+".parameter");
        connectAttr -force  ($qvxianjiedian+".position")  ($loc_grpA+".t");
        string$xiangshang=($bn+"_xiangshang_"+$i);
        select -r $bnn;
        duplicate -rr -n $xiangshang ;
        string$bnn_s_temp[]=` listRelatives -c -pa $xiangshang`;
        delete $bnn_s_temp[0];
        
        float$rot=`getAttr  ($xiangshang+".rz")`;
        if(abs($rot)>40){$rot=40;}
        setAttr ($xiangshang+".rz") ($rot*-1);
        
        string$cbnn_A=($bnn+"_xuanzhuan_temp"+$i);
        select -r $bnn;
        duplicate -rr -n $cbnn_A;
        delete`orientConstraint  $cbnn_A $loc_grpA`;
        delete $cbnn_A;
        if($shangxia==1)
           {
              setAttr   ($bnn+".rz") 0;
            }
        select -r $loc;
        select -add $bnn;
        string$dianyuesu[]=`aimConstraint -mo -weight 1 -aimVector 1 0 0 -upVector 0 0 1 -worldUpType "objectrotation" -worldUpVector 0 0 1 -worldUpObject $xiangshang`;
        float$obj_rot=`getAttr  ($bnn+".rz")`;
        if($shangxia==0)
            { transformLimits -rz -360 0 -erz 1 1 $bnn;
            }else
                {transformLimits -rz 0 360 -erz 1 1 $bnn;}
       
        transformLimits -rx 0 0 -erx 1 1 $bnn;
        transformLimits -ry 0 0 -ery 1 1 $bnn;
        

        string$shuxing_A=($shuxing+$bn+"_A_"+$i);
        int$ex=`objExists  ($yaqiukongzhii+"."+$shuxing_A)`;
        if($ex==0)
          {
          select -r  $yaqiukongzhii;
          addAttr -ln $shuxing_A  -at double  -dv 0 -k 1 $yaqiukongzhii;
          setAttr -keyable false -channelBox true ($yaqiukongzhii+"."+$shuxing_A);
          }
          
          
          
        string$jiajian_A=($bn+"_plusMinusAverage_jiemao_penzguang"+$i);
        int$ex=`objExists $jiajian_A`;    ///判断
        if($ex==1){delete $jiajian_A;}

        shadingNode -asUtility plusMinusAverage -n $jiajian_A;//创建加减节点
        connectAttr -force ($yaqiukongzhii+"."+$shuxing) ($jiajian_A+".input1D[0]");
        connectAttr -force ($yaqiukongzhii+"."+$shuxing_A) ($jiajian_A+".input1D[1]");
        
        string$chengchu_A=($bn+"_multiplyDivide_jiemao_penzguang"+$i);
        int$ex=`objExists $chengchu_A`;    ///判断
        if($ex==1){delete $chengchu_A;}
        shadingNode -asUtility multiplyDivide -n$chengchu_A ;//创建乘除节点
        connectAttr -force  ($jiajian_A+".output1D") ($chengchu_A+".input1X");
        
        float$loc_pos[]=`xform -q -ws -t $loc`;
        float$bn_pos[]=`xform -q -ws -t $bnn_end`;
        float$a_diss=mag(<<$loc_pos[0],$loc_pos[1],$loc_pos[2]>>-<<$bn_pos[0],$bn_pos[1],$bn_pos[2]>>);
        float$offste_diss=($a_diss*0.1);
        setAttr ($chengchu_A+".input2X") $offste_diss;
        
        connectAttr -force  ($chengchu_A+".outputX")  ($loc+".ty");

    }
   
} 




/////////////////////////////////初始化UI//////////////////////////////////////////////////////
zxb_fase_window_proc;
string$face_loc="zxb_face_loc";
int$ex=`objExists $face_loc`;    ///判断
if($ex==1)
  {
   zxb_ui_jiazai;
  }